#' @title calculate LL's for all relationships
#'
#' @description For each pair, calculate the log10-likelihoods of being PO, FS,
#'   HS, GP, FA, 3rd degree relatives, or unrelated. Individuals must be
#'   genotyped or dummifiable, i.e. have at least one genotyped offspring.
#'
#' @details The same pair may be included multiple times, with different sex,
#'   age difference, or focal relationship, to explore their effect on the
#'   likelihoods. Likelihoods are only calculated for relationships that are
#'   possible given the age difference, e.g. PO (parent-offspring) is not
#'   calculated for pairs with an age difference of 0.
#'
#'   Non-genotyped individuals can be included if they have at least one
#'   genotyped offspring and can be turned into a dummy (see
#'   \code{\link{getAssignCat}}); to establish this a pedigree must thus be
#'   provided.
#'
#' @param Pairs  dataframe with columns
#'  \itemize{
#'  \item ID1
#'  \item ID2
#'  \item sex1; Sex of ID1, 1=female, 2=male, 3=unknown. Default: inferred from
#'    pedigree for those occuring as parents, otherwise 3. Hermaphrodites are
#'    currently not implemented.
#'  \item sex2
#'  \item AgeDif; Age difference in whole time units, BirthYear2 - BirthYear1
#'  \item focal; relationship character abbreviation, PO, FS, HS, GP or U. See
#'  Details; Default: U
#'  \item patmat; 1=maternal relatives, 2=paternal relatives. Only relevant for
#'    HS & GP, for which it is currently only predictably implemented for pairs
#'    of two genotyped individuals. Defaults to Sex1, or 1 if Sex1=3.
#'  }
#'  \code{Sex1}, \code{Sex2} and \code{AgeDif} are taken from
#'  \code{LifeHistData} if the latter is provided and the entry in \code{Pairs}
#'    is \code{NA}, or the column missing. To explicitly specify missing values,
#'    use \code{Sex1=3} or \code{AgeDif = 999}. Sexes must be compatible with
#'    the pedigree, if one is provided.
#' @param GenoM the genotype matrix
#' @param Pedigree  dataframe with columns id-dam-sire; likelihoods will be
#'   calculated conditional on the pedigree.
#' @param LifeHistData Dataframe with columns ID - Sex - Birth year
#' @param dropPar When calculating the likelihoods for a pair, first drop the
#'   parents of ID1 (\code{dropPar=1}), as is done when calculating the parental
#'   LLR's, or condition on both sets of parents (\code{dropPar=0}), drop both
#'   sets of parents (\code{dropPar=12}) or only the parents of ID2
#'   (\code{dropPar=2}). Defaults to 0, i.e. condition on the complete pedigree
#'   if any is provided.
#' @param AgePrior Agepriors matrix, as generated by \code{\link{MakeAgePrior}}
#'   and included in the \code{\link{sequoia}} output. Affects which
#'   relationships are considered possible (only those where \eqn{P(A|R) / P(A)
#'   > 0}).
#' @param Specs Named vector with parameter values, as in the
#'   \code{\link{sequoia}} output. If provided, all relevant input parameters
#'   will be ignored.
#' @param Complex  determines which relationships are considered as
#'   alternatives. Either "full" (default), "simp" (simplified, ignores inbred
#'   relationships), or "mono" (monogamous).
#' @param Err estimated genotyping error rate, as a single number or 3x3 matrix.
#'   If a matrix, this should be the probability of observed genotype (columns)
#'   conditional on actual genotype (rows). Each row must therefore sum to 1.
#' @param ErrFlavour function that takes \code{Err} as input, and returns a 3x3
#'   matrix of observed (columns) conditional on actual (rows) genotypes, or
#'   choose from inbuilt ones as used in sequoia 'version2.0', 'version1.3', or
#'   'version1.1'. Ignored if \code{Err} is a matrix. See \code{\link{ErrToM}}.
#' @param Tassign  minimum LLR required for acceptance of proposed relationship.
#'   Used to determine whether or not to consider some more exotic relationships
#'   when Complex="full".
#' @param Tfilter threshold LLR, used in determining whether to consider certain
#'   alternative relationships.
#' @param quiet logical, suppress messages
#' @param Plot logical, display histograms and scatterplots
#'
#'
#' @return the \code{Pairs} dataframe with additional columns:
#'  \item{LL_xx}{Log10-Likelihood of this pair having relationship xx, with xx
#'    being one of PO, FS, etc. as detailed below.}
#'  \item{TopRel}{Most likely relationship}
#'  \item{LLR}{Likelihood ratio between most-likely relationship and second most likely}
#'
#' @section Relationship abbreviations:
#' \describe{
#'   \item{PO}{Parent - offspring}
#'   \item{FS}{Full siblings}
#'   \item{HS}{Half siblings}
#'   \item{GP}{Grandparent}
#'   \item{FA}{Full avuncular}
#'   \item{HA}{Half avuncular and other 3rd degree relationships}
#'   \item{U}{Unrelated}
#'   \item{2nd}{Unclear which type of 2nd degree relatives
#'     (HS, GP, FA)}
#'   \item{??}{Unclear which type of 1st, 2nd or 3rd degree
#'     relatives}}
#'
#' @section Double relationships & focal relationship:
#'   Especially when Complex='full', many more than seven relationship
#'   alternatives are considered, but rather a whole range of possible double
#'   and even tripple relationships. For example, mother A and offspring B (PO)
#'   may also be paternal half-siblings (HS, A and A's mother mated with same
#'   male), grandmother and grandoffspring (GP, B's father is A's son), or
#'   paternal aunt (B's father is a full or half sib of A).
#'
#'   The likelihood reported as 'LL_PO' is the most-likely one of the possible
#'   alternatives, among those that are not impossible due to age differences or
#'   due to the pedigree (as reconstructed up to that point). In the example, if
#'   B already has a father assigned, who in turn has parents assigned that are
#'   not A, than all the double relationships become impossible.
#'
#'   Whether e.g. the likelihood to be both PO & HS is counted as PO or as HS,
#'   depends on the situation and is determined by the variable 'focal': During
#'   parentage assignment, it is counted as PO but not HS, while during sibship
#'   clustering, it is counted as HS but not PO -- not omitting from the
#'   alternative relationship would result in a deadlock.
#'
#'
#' @section Likelihood special codes:
#' Likelihoods are always negative; any positive values are one of the following:
#' \describe{
#'   \item{222}{Maybe (via) other parent}
#'   \item{444}{Not (yet) implemented}
#'   \item{777}{Impossible, would create an invalid pedigree}
#'   \item{888}{Already assigned}
#'   \item{999}{NA (not calculated)}}
#'
#' @seealso \code{\link{CalcOHLLR}} to calculate LLR for parents & parent-pairs
#'   in a pedigree; \code{\link{GetRelCat}} to find all pairwise relatives
#'   according to the pedigree; \code{\link{GetMaybeRel}} to get likely relative
#'   pairs not in the pedigree.
#'
#' @examples
#'
#' data(Ped_griffin, SeqOUT_griffin, package="sequoia")
#' Geno.griffin <- SimGeno(Ped_griffin, nSnp=200, SnpError = 0.01, ParMis=0.4)
#'
#' MR <- GetMaybeRel(GenoM = Geno.griffin,
#'                   LifeHistData = SeqOUT_griffin$LifeHist,
#'                   Module = "par",
#'                   Err = 0.001)
#' head(MR$MaybePar)
#'
#' TenPairs <- MR$MaybePar[1:10, c("ID1", "ID2", "Sex1", "Sex2", "AgeDif")]
#' PairLL <- CalcPairLL(Pairs = rbind( cbind(TenPairs, focal = "PO"),
#'                                     cbind(TenPairs, focal = "HS"),
#'                                     cbind(TenPairs, focal = "GP")),
#'                      GenoM = Geno.griffin,
#'                      Err = 0.005)
#' PairLL[c(1, 11, 21), ]
#' # > LL(FS)==222 : HSHA, HSGP, FAHA more likely than FS
#' # > LL(GP) higher when focal=HS: GP via 'other' parent also considered
#' # > LL(FA) higher when focal=PO: FAHA, or FS of 'other' parent
#'
#' @useDynLib sequoia, .registration = TRUE
#
#' @export

# TODO: SeqList in.
CalcPairLL <- function(Pairs = NULL,
                       GenoM = NULL,
                       Pedigree = NULL,
                       LifeHistData = NULL,
                       dropPar = 0,
                       AgePrior = NULL,
                       Specs = NULL,
                       Complex = "full",
                       Err = 1e-4,
                       ErrFlavour = "version2.0",
                       Tassign = 0.5,
                       Tfilter = -2.0,
                       quiet = FALSE,
                       Plot = TRUE)
{
  on.exit(.Fortran(deallocall), add=TRUE)

  INPUT <- as.list(as.environment(-1))[c(4,7:13)]
  GenoM <- CheckGeno(GenoM, quiet=quiet, Plot=Plot)
  gID <- rownames(GenoM)

  Ped <- PedPolish(Pedigree, gID, DropNonSNPd=FALSE, NullOK=TRUE)
  # Ped=NULL if Pedigree=NULL & gID=NULL

  LHF <- CheckLH(LifeHistData, rownames(GenoM), sorted=TRUE)

  # check/make ageprior ----
  # pedigree not used -- estimate ageprior separately if desired
  nAgeClasses <- ifelse(sum(!is.na(Pairs$AgeDif))>1,
                            max(Pairs$AgeDif, na.rm=TRUE),
                            10)  # doesn't really matter?
  if (is.null(AgePrior)) {
    AgePrior <- MakeAgePrior(Ped, LifeHistData,
    MaxAgeParent = nAgeClasses,
                             quiet = quiet, Plot = Plot)
  } else {
    AgePrior <- CheckAP(AgePrior)
    if (nrow(AgePrior) < nAgeClasses) {
      AgePrior <- rbind(AgePrior,
                        matrix(0, nAgeClasses - nrow(AgePrior), 5,
                               dimnames=list(seq.int(from=901,
                                                     length.out=nAgeClasses-nrow(AgePrior)),
                                             colnames(AgePrior))))
    }
  }

  # Specs / param ----
  if (!is.null(Specs)) {
    PARAM <- SpecsToParam(Specs, dropPar, quiet, Plot)
  } else {
    PARAM <- c(INPUT,
               list(dimGeno = dim(GenoM),
                    nAgeClasses = nrow(AgePrior),
                    MaxSibshipSize = max(table(Ped$dam), table(Ped$sire), 90,
                                         na.rm=TRUE) +10 ))
  }


  # genotyping error matrix ----
  if (!is.null(Specs)) {
    Err <- FacToNum(Specs["GenotypingErrorRate"])
    if ("ErrFlavour" %in% names(Specs))   ErrFlavour <- Specs["ErrFlavour"]  # FALSE if output from version 1.x
  }
  PARAM$ErrM <- ErrToM(Err, flavour = ErrFlavour, Return = "matrix")  # performs checks if Err is already matrix


  # max. mismatches ----
  if ("MaxMismatchOH" %in% names(Specs)) {  # FALSE if output from version 1.x
    PARAM$MaxMismatchV <- FacToNum(Specs[c("MaxMismatchDUP", "MaxMismatchOH",
                                           "MaxMismatchME")])
  } else {
    sts <- SnpStats(GenoM, Plot=FALSE)
    PARAM$MaxMismatchV <- CalcMaxMismatch(Err=PARAM$ErrM, MAF=sts[,"AF"], ErrFlavour=ErrFlavour,
                                    qntl=0.999^(1/nrow(GenoM)))
  }
  names(PARAM$MaxMismatchV) <- c("DUP", "OH", "ME")


  # check parameter values ----
  CheckParams(PARAM)
  utils::flush.console()


  # turn IDs into numbers, & turn non-genotyped parents into temporary dummies ----
  PedN <- PedToNum(Ped, gID, DoDummies = "new",
                   DumPrefix = c("TempF0", "TempM0"))  # list: PedPar - DumPar - Renamed - Nd
  PairL <- FortifyPairs(Pairs, gID, PedN$Renamed, LHF)  # also checks input


	# call Fortran ----
  Np <- nrow(Pairs)
  FortPARAM <- MkFortParams(PARAM, fun="CalcPairs")

  TMP <- .Fortran(getpairll,
                  ng = as.integer(nrow(GenoM)),   # no. genotyped indiv
                  np = as.integer(Np),   # no. pairs
                  specsint = as.integer(FortPARAM$SpecsInt),
                  specsdbl = as.double(FortPARAM$SpecsDbl),
                  errv = as.double(FortPARAM$ErrM),
                  genofr = as.integer(GenoM),

#                  sexrf = as.integer(LHF$Sex),
                  byrf = as.integer(c(LHF$BirthYear, LHF$BY.min, LHF$BY.max)),
                  aprf = as.double(AgePrior),

                  pairids = as.integer(PairL$ID),
                  pairsex = as.integer(PairL$Sex),
                  pairagediff = as.integer(PairL$AgeDif),
                  pairfocal = as.integer(PairL$Focal),
                  pairk = as.integer(PairL$patmat),


                  dropp = as.integer(FortPARAM$dropp),
	                parentsrf = as.integer(PedN$PedPar),
	                dumparrf = as.integer(PedN$DumPar),
                  llrf = double(7*Np),
	                toprf = integer(Np),
	                dlrf = double(Np)
                  )

	# wrap output ----
	RelNames <- c("PO", "FS", "HS", "GP", "FA", "HA", "U", "??", "2nd")
	Pairs.OUT <- cbind(Pairs,
	                   setNames(as.data.frame(round(VtoM(TMP$llrf, nc=7), 2)),
	                            RelNames[1:7]),
	                   TopRel = RelNames[TMP$toprf],
	                   LLR = round(TMP$dlrf, 2))
	Pairs.OUT <- as.data.frame(Pairs.OUT, stringsAsFactors = FALSE)
  Pairs.OUT$focal <- as.character(Pairs.OUT$focal)
	Pairs.OUT$TopRel <- as.character(Pairs.OUT$TopRel)
	Pairs.OUT$LLR[Pairs.OUT$LLR == -777] <- NA

	# plot ----
	if (Plot)   PlotPairLL(Pairs.OUT)

	return( Pairs.OUT )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' @title Make Pairs Fortran compatible
#'
#' @description convert dataframe \code{Pairs} into a list of integer vectors.
#'   Called only by \code{\link{CalcPairLL}}.
#'
#' @param Pairs  dataframe with columns ID1 - ID2 - Sex1 - Sex2 - AgeDif - focal - k
#' @param gID  character vector with IDs of genotyped individuals
#' @param Renamed  length-2 list (dams, sires) each with a 2-column dataframe
#'   matching character IDs to negative numbers, for dummified individuals. Element
#'   of the list returned by \code{\link{PedToNum}}.
#' @param LH  lifehistory dataframe, ID - Sex - BirthYear
#'
#' @return a named list, with elements ID - Sex - AgeDif - Focal. The first two
#'   are per individual and thus each have length 2*nrow(Pairs), while the last
#'   two have length 1*nrow(Pairs)
#'
#' @keywords internal

FortifyPairs <- function(Pairs,   # pairs with character IDs etc
                         gID,
                         Renamed,
                         LH)
{

  Pairs <- as.data.frame(Pairs)   # in case it's a matrix
  for (x in c("Sex1", "Sex2", "AgeDif", "focal", "patmat")) {
    if (!x %in% colnames(Pairs))  Pairs[,x] <- NA
  }
  if (!all(c("ID1", "ID2") %in% colnames(Pairs)))
    stop("Pairs must  have at least columns 'ID1' and 'ID2'")

  # add LH data ----
  Pairs$zz <- seq_along(Pairs$ID1)   # to fix merge() row order mess
  if (any(is.na(Pairs$AgeDif)) | any(is.na(Pairs$Sex1)) | any(is.na(Pairs$Sex2))) {
    Pairs <- merge(Pairs, setNames(LH[, 1:3], c("ID1", "Sex1.LH", "BY1")), all.x=TRUE)
    Pairs <- merge(Pairs, setNames(LH[, 1:3], c("ID2", "Sex2.LH", "BY2")), all.x=TRUE)
  }
  Pairs <- Pairs[order(Pairs$zz), ]

  # age difference ----
  if (any(!is.wholenumber(Pairs$AgeDif) & !is.na(Pairs$AgeDiff)))
    stop("'AgeDif' in 'Pairs' must be whole numbers", call.=FALSE)
  if (any(is.na(Pairs$AgeDif))) {
    Pairs$AgeDif <- with(Pairs, ifelse(!is.na(AgeDif),
                                       AgeDif,
                                       BY2 - BY1))
  }

  # sex ----
  for (x in c("Sex1", "Sex2")) {
    if (!all(Pairs[,x] %in% c(1:3, NA))) {
      stop("'Sex1' and 'Sex2' in 'Pairs must be 1=female, 2=male, 3/NA= unknown", call.=FALSE)  }
    if (any(is.na(Pairs[,x]))) {
      Pairs[,x] <- ifelse(!is.na(Pairs[,x]),
                          Pairs[,x],
                          Pairs[,paste0(x, ".LH")])
    }
    Pairs[is.na(Pairs[,x]), x] <- 3
  }

  # focal ----
  RelNames <- c("PO", "FS", "HS", "GP", "FA", "HA", "U")
  if (!all(Pairs$focal %in% RelNames)) {
    stop("Some 'focal' values in 'Pairs' are invalid. ",
         "Valid values are: PO, FS, HS, GP, FA, HA, U", call.=FALSE)
  }

  # paternal/maternal ----
  if (!all(Pairs$patmat %in% c(1,2,NA)))
    stop("'patmat' in 'Pairs' must be 1, 2, or NA")
  Pairs$patmat <- with(Pairs, ifelse(!is.na(patmat), patmat,
                                 ifelse(focal == "PO" & Sex2 != 3, Sex2,
                                    ifelse(Sex1 != 3, Sex1, 1))))


  # character IDs to numbers ----
  ID <- c("ID1", "ID2")
  SEX <- c("Sex1", "Sex2")
  GenoNums <- setNames(seq_along(gID), gID)

  for (x in 1:2) {
    if (!all(Pairs[,ID[x]] %in% c(gID, unlist(Renamed))))
      stop("All individuals must be genotyped or dummifiable", call.=FALSE)
    Pairs[, paste0(ID[x], ".num")] <- ifelse(Pairs[, ID[x]] %in% gID,
                                             GenoNums[Pairs[, ID[x]]],
                                             0)
    if (all(Pairs[, paste0(ID[x], ".num")] > 0))  next   # no dummies
    for (k in 1:2) {
      dum.k <- Pairs[,ID[x]] %in% Renamed[[k]]
      if (any(Pairs[dum.k, SEX[x]] == 3-k))
        stop("Some ", c("dams", "sires")[k], " in Pedigree have Sex = ",
             3-k, " in Pairs or LifeHistData", call.=FALSE)
      Pairs[dum.k, SEX[x]] <- k   # fixes any with unknown sex
    }
    Pairs[dum.k, paste0(ID[x], ".num")] <- Renamed[[k]][match(Pairs[dum.k,x],
                                                              Renamed[[k]]$name),
                                                        "num"]
  }
  if (any(Pairs$ID1.num == 0 | Pairs$ID2.num == 0))  stop("Something went wrong")


  # output list, for Fortran ----
  PairL <- with(Pairs, list(ID = c(ID1.num, ID2.num),
                            Sex = c(Sex1, Sex2),
                            AgeDif = AgeDif,
                            Focal = as.numeric(factor(as.character(focal),
                                                      levels = RelNames)),
                            patmat = patmat))
  PairL$AgeDif[is.na(PairL$AgeDif)] <- 999
  PairL$Focal[is.na(PairL$Focal)] <- 7

  return( PairL )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#' @title Plot pair likelihoods
#'
#' @description histograms & scatterplots of ratios between various likelihoods
#'
#' @param PairLL  dataframe output from \code{\link{CalcPairLL}}
#'
#' @keywords internal

# @importFrom graphics par barplot hist text axis mtext

PlotPairLL <- function(PairLL) {
  oldpar <- par(no.readonly = TRUE)
  oldpar <- oldpar[names(oldpar)!="pin"]   # current plot dimensions, not setable. bug?

	ac <- function(x, a=0.5)  grDevices::adjustcolor(x, alpha.f=a)
	RelCol <- c(PO = "#a6611a", FS = "#018571", HS = "#80cdc1",
	            GP = "#d35fbc", FA = "#7f2aff", HA = "#b380ff",
	            U = grDevices::grey(.4),
	            '2nd' = "darkorange2", '??' = 'orange1')

	Np <- nrow(PairLL)
	RelNames <- c("PO", "FS", "HS", "GP", "FA", "HA", "U")
	PairLL.tmp <- PairLL[, RelNames]
	PairLL.tmp[PairLL.tmp > 0] <- NA
	PairLL[PairLL$U > 0, "U"] <- NA
	PairLL$focal <- factor(as.character(PairLL$focal), levels = RelNames)

	#~~~~~~~~
	# multi-plot: all possible ratios
	LR <- array(NA, dim=c(Np, 6, 7),
	             dimnames = list(seq_len(Np),
	                             numerator = RelNames[1:6],
	                             denominator = RelNames))
	for (r in RelNames[1:6]) {
	  for (x in RelNames) {
  	  LR[, r, x] <- PairLL.tmp[, r] - PairLL.tmp[, x]
	  }
	}

	XLIM <- suppressWarnings(apply(LR, 3, function(x) range(pretty(x))))

	par(mfcol=c(6, 7), mai=c(.3, .5, .2,.05))
	for (x in RelNames) {
  	for (r in RelNames[1:6]) {
  	  if (any(!is.na(LR[,r,x]))) {
  	    graphics::hist(LR[, r, x], breaks=round(Np/4), xlim=XLIM[,x], col="grey",
  	         main = paste(r, "/", x),
  	         xlab="", ylab="", las=1)
  	  } else {
  	    plot(1,1, type="n", axes=FALSE, xlab="", ylab="",
  	         main = paste(r, "/", x))
  	    graphics::text(1,1, labels="all N/A", cex=1.5)
  	  }
  	  # mtext(paste(r, "/ U"), side=2, line=3)    # srt not supported by mtext
  	  # text()  - how to determine x? y = mean(par("usr")[3:4])
  	}
	}


	#~~~~~~~~
	# scatterplot: LLR(top/2nd best) vs LLR (focal/U)
	LL.fcl <- as.numeric(PairLL.tmp[cbind(seq_len(Np), PairLL$focal)])
	RelNames <- c(RelNames, "2nd", "??")

	if (any(!is.na(LL.fcl))) {

	  if (interactive()) {
	    inp <- readline(prompt = "Press <Enter> to continue to next plot ...") }

	  ly <- layout(matrix(c(1,2), nrow=1), widths=c(.8, .2))
	  par(mai=c(.9,.9,.2,.1))
	  with(PairLL,
	       plot(LL.fcl - U, LLR, pch=21, lwd=2, cex=1.5,
	            col = ac(RelCol[focal]), bg = ac(RelCol[TopRel]),
	            xlab = "LLR (focal / U)", las=1,
	            ylab = "LLR (toprel / 2nd best)"))

	  # legend
	  par(mai=c(1.1,.3,0.5,.7))
	  plot(1,1,type="n", axes=FALSE, xlab="", ylab="")
	  graphics::legend("left",legend=RelNames, fill=RelCol,
	                   title = "Relationship\nFill: TopRel\nLine: Focal",
	                   title.adj=0, bty = "n", xpd=NA)
	}

  #~~~~~~~~
  par(oldpar)  # restore old settings
}
