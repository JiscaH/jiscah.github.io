{
    "collab_server" : "",
    "contents" : "#' @title Pedigree Reconstruction\n#'\n#' @description Perform pedigree reconstruction based on SNP data, including\n#'   parentage assignment and sibship clustering.\n#'\n#' @details Dummy parents of sibships are denoted by F0001, F0002, ... (mothers)\n#'   and M0001, M0002, ... (fathers), are appended to the bottom of the\n#'   pedigree, and may have been assigned real or dummy parents themselves (i.e.\n#'   sibship-grandparents). A dummy parent is not assigned to singletons.\n#'\n#'   For each pair of candidate relatives, the likelihoods are calculated\n#'   of them being parent-offspring (PO), full siblings (FS), half siblings\n#'   (HS), grandparent-grandoffspring (GG), full avuncular (niece/nephew -\n#'   aunt/uncle; FA), half avuncular/great-grandparental/cousins (HA), or\n#'   unrelated (U). Assignments are made if the likelihood ratio (LLR) between\n#'   the focal relationship and the most likely alternative exceed the threshold\n#'   Tassign.\n#'\n#'   Further explanation of the various options and interpretation of the output\n#'   is provided in the vignette.\n#'\n#' @param GenoM  numeric matrix with genotype data: One row per individual, and\n#'   one column per SNP, coded as 0, 1, 2 or -9 (missing). Use\n#'   \\code{\\link{GenoConvert}} to convert genotype files created in PLINK using\n#'   --recodeA or in Colony's 2-column format to this format.\n#' @param LifeHistData Dataframe with 3 columns (optionally 5):\n#'  \\describe{\n#'  \\item{ID}{max. 30 characters long,}\n#'  \\item{Sex}{1 = females, 2 = males, other = unknown, except 4 =\n#'    hermaphrodite,}\n#' \\item{BirthYear }{birth or hatching year, integer, with missing values as NA\n#'   or any negative value.}\n#' \\item{BY.min}{minimum birth year, only used if BirthYear is missing}\n#' \\item{BY.max}{maximum birth year, only used if BirthYear is missing} }\n#' If the species has multiple generations per year, use an integer coding such\n#' that the candidate parents' `Birth year' is at least one smaller than their\n#' putative offspring's. Column names are ignored, so ensure column order is ID\n#' - sex - birth year (- BY.min - BY.max).\n#' @param SeqList list with output from a previous run, containing the elements\n#'   `Specs', `AgePriors' and/or `PedigreePar', as described below, to be used\n#'   in the current run. If \\code{SeqList$Specs} is provided, all other input\n#'   parameter values except \\code{MaxSibIter} are ignored.\n#' @param MaxSibIter number of iterations of sibship clustering, including\n#'   assignment of grandparents to sibships and avuncular relationships between\n#'   sibships. Set to 0 to not (yet) perform this step, which is by far the most\n#'   time consuming and may take several hours for large datasets. Clustering\n#'   continues until convergence or until MaxSibIter is reached.\n#' @param Err estimated genotyping error rate, as a single number or 3x3 matrix.\n#'   If a matrix, this should be the probability of observed genotype (columns)\n#'   conditional on actual genotype (rows). Each row must therefore sum to 1.\n#' @param ErrFlavour function that takes \\code{Err} as input, and returns a 3x3\n#'   matrix of observed (columns) conditional on actual (rows) genotypes, or\n#'   choose from inbuilt ones as used in sequoia 'version2.0', 'version1.3', or\n#'   'version1.1'. Ignored if \\code{Err} is a matrix. See \\code{\\link{ErrToM}}.\n#' @param MaxMismatch DEPRECATED AND IGNORED. Now calculated using\n#'   \\code{\\link{CalcMaxMismatch}}.\n#' @param Tfilter threshold log10-likelihood ratio (LLR) between a proposed\n#'   relationship versus unrelated, to select candidate relatives. Typically a\n#'   negative value, related to the fact that unconditional likelihoods are\n#'   calculated during the filtering steps. More negative values may decrease\n#'   non-assignment, but will increase computational time.\n#' @param Tassign minimum LLR required for acceptance of proposed relationship,\n#'   relative to next most likely relationship. Higher values result in more\n#'   conservative assignments. Must be zero or positive.\n#' @param MaxSibshipSize  maximum number of offspring for a single individual (a\n#'   generous safety margin is advised).\n#' @param DummyPrefix character vector of length 2 with prefixes for dummy dams\n#'   (mothers) and sires (fathers); maximum 20 characters each.\n#' @param Complex  either \"full\" (default), \"simp\" (simplified, no explicit\n#'   consideration of inbred relationships), \"mono\" (monogamous) or \"herm\"\n#'   (hermaphrodites, otherwise like \"full\").\n#' @param UseAge  either \"yes\" (default), \"no\", or \"extra\" (additional rounds\n#'   with extra reliance on ageprior, may boost assignments but increased risk\n#'   of erroneous assignments); used during full reconstruction only.\n#' @param args.AP list with arguments to be passed on to\n#'   \\code{\\link{MakeAgePrior}}.\n#' @param FindMaybeRel DEPRECATED, advised to run \\code{\\link{GetMaybeRel}}\n#'   separately. TRUE/FALSE to identify pairs of non-assigned likely relatives\n#'   after pedigree reconstruction. Can be time-consuming in large datasets.\n#' @param CalcLLR  calculate log-likelihood ratios for all assigned parents\n#'   (genotyped + dummy; parent vs. otherwise related). Time-consuming in large\n#'   datasets. Can be done separately with \\code{\\link{CalcOHLLR}}.\n#' @param quiet suppress messages: TRUE/FALSE/\"verbose\".\n#' @param Plot display plots from \\code{\\link{SnpStats}, \\link{MakeAgePrior}},\n#'   and \\code{\\link{SummarySeq}}. Defaults (NULL) to TRUE when quiet=FALSE or\n#'   \"verbose\", and FALSE when quiet=TRUE. If you get errors an error 'figure\n#'   margins too large', enlarge the plotting area (drag with mouse). 'invalid\n#'   graphics state' error can be dealt with by clearing the plotting area with\n#'   dev.off().\n#'\n#' @return A list with some or all of the following components:\n#' \\item{AgePriors}{Matrix with age-difference based probability ratios for\n#'   each relationship, used for full pedigree reconstruction; see\n#'   \\code{\\link{MakeAgePrior}} for details. When running only parentage\n#'   assignment (MaxSibIter=0) the returned AgePriors has been updated to\n#'   incorporate the information of the assigned parents, and is ready for use\n#'   during full pedigree reconstruction.}\n#' \\item{DummyIDs}{Dataframe with pedigree for dummy individuals, as well as\n#' their sex, estimated birth year (point estimate, upper and lower bound of\n#' 95\\% confidence interval), number of offspring, and offspring IDs (genotyped\n#' offspring only).}\n#' \\item{DupGenotype}{Dataframe, duplicated genotypes (with different IDs,\n#'  duplicate IDs are not allowed). The specified number of maximum mismatches\n#'   is used here too. Note that this dataframe may include pairs of closely\n#'   related individuals, and monozygotic twins.}\n#' \\item{DupLifeHistID}{Dataframe, row numbers of duplicated IDs in life\n#'   history dataframe. For convenience only, but may signal a problem. The\n#'   first entry is used.}\n#' \\item{ErrM}{Error matrix; probability of observed genotype (columns)\n#'   conditional on actual genotype (rows)}\n#' \\item{ExcludedInd}{Individuals in GenoM which were excluded because of a\n#'   too low genotyping success rate (<50\\%).}\n#' \\item{ExcludedSNPs}{Column numbers of SNPs in GenoM which were excluded\n#'   because of a too low genotyping success rate (<10\\%).}\n#' \\item{LifeHist}{Provided dataframe with sex and birth year data.}\n#' \\item{LifeHistPar}{LifeHist with additional columns 'Sexx' (inferred Sex when\n#' assigned as part of parent-pair), 'BY.est' (mode of birth year probability\n#' distribution), 'BY.lo' (lower limit of 95\\% highest density region), 'BY.hi'\n#' (higher limit), inferred after parentage assignment. 'BY.est' is NA when the\n#' probability distribution is flat between 'BY.lo' and 'BY.hi'.}\n#' \\item{LifeHistSib}{as LifeHistPar, but estimated after full pedigree\n#' reconstruction}\n#' \\item{MaybeParent}{Dataframe with pairs of individuals who are more likely\n#'   parent-offspring than unrelated, but which could not be phased due to\n#'   unknown age difference or sex, or for whom LLR did not pass Tassign.}\n#' \\item{MaybeRel}{Dataframe with pairs of individuals who are more likely\n#'   to be first or second degree relatives than unrelated, but which could not\n#'   be assigned.}\n#' \\item{MaybeTrio}{Dataframe with non-assigned parent-parent-offspring trios\n#' (both parents are of unknown sex), with similar columns as the pedigree}\n#' \\item{NoLH}{Vector, IDs in genotype data for which no life history data is\n#'  provided.}\n#' \\item{Pedigree}{Dataframe with assigned genotyped and dummy parents from\n#'   Sibship step; entries for dummy individuals are added at the bottom.}\n#' \\item{PedigreePar}{Dataframe with assigned parents from Parentage step.}\n#' \\item{Specs}{Named vector with parameter values.}\n#' \\item{TotLikParents}{Numeric vector, Total likelihood of the genotype data\n#'   at initiation and after each iteration during Parentage.}\n#' \\item{TotLikSib}{Numeric vector, Total likelihood of the genotype data\n#'   at initiation and after each iteration during Sibship clustering.}\n#' \\item{AgePriorExtra}{As AgePriors, but including columns for grandparents\n#'  and avuncular pairs. NOT updated after parentage assignment, but returned\n#'  as used during the run.}\n#'\n#' List elements PedigreePar and Pedigree both have the following columns:\n#'  \\item{id}{Individual ID}\n#'  \\item{dam}{Assigned mother, or NA}\n#'  \\item{sire}{Assigned father, or NA}\n#'  \\item{LLRdam}{Log10-Likelihood Ratio (LLR) of this female being the mother,\n#'  versus the next most likely relationship between the focal individual and\n#'  this female (see Details for relationships considered)}\n#'  \\item{LLRsire}{idem, for male parent}\n#'  \\item{LLRpair}{LLR for the parental pair, versus the next most likely\n#'   configuration between the three individuals (with one or neither parent\n#'   assigned)}\n#'  \\item{OHdam}{Number of loci at which the offspring and mother are\n#'    opposite homozygotes}\n#'  \\item{OHsire}{idem, for father}\n#'  \\item{MEpair}{Number of Mendelian errors between the offspring and the\n#'    parent pair, includes OH as well as e.g. parents being opposing\n#'    homozygotes, but the offspring not being a heterozygote. The offspring\n#'    being OH with both parents is counted as 2 errors.}\n#'\n#' @author Jisca Huisman, \\email{jisca.huisman@gmail.com}\n#'\n#' @references Huisman, J. (2017) Pedigree reconstruction from SNP data:\n#'   Parentage assignment, sibship clustering, and beyond. Molecular Ecology\n#'   Resources 17:1009--1024.\n#'\n#' @section Disclaimer:\n#' While every effort has been made to ensure that sequoia provides what it\n#' claims to do, there is absolutely no guarantee that the results provided are\n#' correct. Use of sequoia is entirely at your own risk.\n#'\n#' @seealso \\code{\\link{GenoConvert}} to read in various data formats,\n#'   \\code{\\link{CheckGeno}}, \\code{\\link{SnpStats}} to calculate missingness\n#'   and allele frequencies, \\code{\\link{MakeAgePrior}} to estimate effect of\n#'   age on relationships, \\code{\\link{GetMaybeRel}} to find pairs of potential\n#'   relatives, \\code{\\link{SummarySeq}} and \\code{\\link{PlotAgePrior}} to\n#'   visualise results, \\code{\\link{GetRelCat}} to turn a pedigree into pairwise\n#'   relationships, \\code{\\link{CalcOHLLR}} to calculate OH and LLR,\n#'   \\code{\\link{PedCompare}} and \\code{\\link{ComparePairs}} to compare to a\n#'   previous pedigree, \\code{\\link{EstConf}} and \\code{\\link{SimGeno}} to\n#'   estimate assignment errors, \\code{\\link{writeSeq}} to save results,\n#'   vignette(\"sequoia\") for further details & FAQ.\n#'\n#' @examples\n#' # ===  EXAMPLE 1: simulate data  ===\n#' data(SimGeno_example, LH_HSg5, package=\"sequoia\")\n#' head(SimGeno_example[,1:10])\n#' head(LH_HSg5)\n#' SeqOUT <- sequoia(GenoM = SimGeno_example, Err = 0.005,\n#'                   LifeHistData = LH_HSg5, MaxSibIter = 0)\n#' names(SeqOUT)\n#' SeqOUT$PedigreePar[34:42, ]\n#'\n#' # compare to true (or old) pedigree:\n#' PC <- PedCompare(Ped_HSg5, SeqOUT$PedigreePar)\n#' PC$Counts[\"GG\",,]\n#'\n#' \\dontrun{\n#' SeqOUT2 <- sequoia(GenoM = SimGeno_example, Err = 0.005,\n#'                   LifeHistData = LH_HSg5, MaxSibIter = 10)\n#' SeqOUT2$Pedigree[34:42, ]\n#'\n#' PC2 <- PedCompare(Ped_HSg5, SeqOUT2$Pedigree)\n#' PC2$Counts[\"GT\",,]\n#'\n#' # important to run with (approx.) correct genotyping error rate:\n#' SeqOUT2.b <- sequoia(GenoM = SimGeno_example, #  Err = 1e-4 by default\n#'                   LifeHistData = LH_HSg5, MaxSibIter = 10)\n#' PC2.b <- PedCompare(Ped_HSg5, SeqOUT2.b$Pedigree)\n#' PC2.b$Counts[\"GT\",,]\n#'\n#'\n#' # ===  EXAMPLE 2: real data  ===\n#' # ideally, select 400-700 SNPs: high MAF & low LD\n#' # save in 0/1/2/NA format (PLINK's --recodeA)\n#' GenoM <- GenoConvert(InFile = \"inputfile_for_sequoia.raw\",\n#'                      InFormat = \"raw\")  # can also do Colony format\n#' SNPSTATS <- SnpStats(GenoM)\n#' # perhaps after some data-cleaning:\n#' write.table(GenoM, file=\"MyGenoData.txt\", row.names=T, col.names=F)\n#'\n#' # later:\n#' GenoM <- as.matrix(read.table(\"MyGenoData.txt\", row.names=1, header=F))\n#' LHdata <- read.table(\"LifeHistoryData.txt\", header=T) # ID-Sex-birthyear\n#' SeqOUT <- sequoia(GenoM, LHdata, Err=0.005)\n#' SummarySeq(SeqOUT)\n#'\n#' writeSeq(SeqOUT, folder=\"sequoia_output\")  # several text files\n#'\n#' # runtime:\n#' SeqOUT$Specs$TimeEnd - SeqOUT$Specs$TimeStart\n#' }\n#'\n#' @export\n\nsequoia <- function(GenoM = NULL,\n                    LifeHistData = NULL,\n                    SeqList = NULL,\n                    MaxSibIter = 10,\n                    Err = 0.0001,\n                    ErrFlavour = \"version2.0\",\n                    MaxMismatch = NA,  # DEPRECATED\n                    Tfilter = -2.0,\n                    Tassign = 0.5,\n                    MaxSibshipSize = 100,\n                    DummyPrefix = c(\"F\", \"M\"),\n                    Complex = \"full\",\n                    UseAge = \"yes\",\n                    args.AP = list(Flatten=NULL, Smooth=TRUE),\n                    FindMaybeRel = FALSE,\n                    CalcLLR = TRUE,\n                    quiet = FALSE,\n                    Plot = NULL)\n{\n  if (!is.logical(quiet)) {\n    if (quiet == \"verbose\") {\n      quietF = -1\n      quiet = FALSE\n    } else {\n      stop(\"`quiet' must be TRUE/FALSE or 'verbose'\")\n    }\n  } else {\n    quietF <- as.numeric(quiet)\n  }\n  if (!is.null(Plot) && !is.logical(Plot))  stop(\"'Plot' must be TRUE/FALSE\")\n  if (is.null(Plot)) {\n    Plot <- ifelse(quiet, FALSE, TRUE)\n  }\n\n  Excl <- CheckGeno(GenoM, quietF, Plot)\n  if (\"ExcludedSnps\" %in% names(Excl))  GenoM <- GenoM[, -Excl[[\"ExcludedSnps\"]]]\n  if (\"ExcludedSnps-mono\" %in% names(Excl))  GenoM <- GenoM[, -Excl[[\"ExcludedSnps-mono\"]]]\n  if (\"ExcludedIndiv\" %in% names(Excl))  GenoM <- GenoM[!rownames(GenoM) %in% Excl[[\"ExcludedIndiv\"]], ]\n\n  if (!\"Specs\" %in% names(SeqList)) {\n    if (is.null(LifeHistData)) {\n      warning(\"no LifeHistData provided, expect lower assignment rate\",\n              immediate.=TRUE)\n    } else if (all(is.na(LifeHistData))) {\n      stop(\"invalid value for LifeHistData, provide NULL or dataframe\")\n    } else if (length(intersect(LifeHistData[,1], rownames(GenoM)))==0) {\n      warning(\"none of the genotyped individuals included in lifehistory data\",\n              immediate.=TRUE)\n    }\n  }\n  if (!is.na(MaxMismatch)) {\n    warning(\"NOTE: 'MaxMismatch' is deprecated & ignored; now calculated internally by 'CalcMaxMismatch'\",\n            immediate.=TRUE)\n  }\n  if (FindMaybeRel)  message(\"NOTE: 'FindMaybeRel' will be deprecated, please run GetMaybeRel() separately\")\n\n  if (\"LifeHist\" %in% names(SeqList)) {\n    if(!quiet)  message(\"using LifeHistData in SeqList\")\n    LifeHistData <- SeqList$LifeHist\n  }\n  if (!is.null(LifeHistData)) {\n    LifeHistData <- CheckLH(LifeHistData)\n    if (!quiet & (any(LifeHistData$BY.min>0 | LifeHistData$BY.max > 0))) {\n      message(\"reading minimum/maximum birth years in LifeHistData\")\n    }\n  } else {\n    LifeHistData <- data.frame(ID = rownames(GenoM),\n                               Sex = 3,\n                               BirthYear = -999,\n                               BY.min = -999,\n                               BY.max = -999,\n                               stringsAsFactors = FALSE)\n  }\n  utils::flush.console()\n\n  if (\"Specs\" %in% names(SeqList)) {\n    if(!quiet)  message(\"settings in SeqList will overrule other settings\")\n\n    if (!\"MaxMismatchOH\" %in% names(SeqList$Specs)) {  # backwards compatability, version 1.x\n      ErrM <- ErrToM(FacToNum(SeqList$Specs[\"GenotypingErrorRate\"]),\n                     flavour = ErrFlavour, Return = \"matrix\")\n\t\t\tsts <- SnpStats(GenoM, Plot=FALSE)\n      MaxMismatchV <- CalcMaxMismatch(Err=ErrM, MAF=sts[,\"AF\"], ErrFlavour=ErrFlavour,\n                                      qntl=0.999^(1/nrow(GenoM)))  # length 3 vector\n    } else {\n      MaxMismatchV <- setNames(FacToNum(SeqList$Specs[c(\"MaxMismatchDUP\", \"MaxMismatchOH\",\n                                                        \"MaxMismatchME\")]),\n                               c(\"DUP\", \"OH\", \"ME\"))\n    }\n    Specs <- SeqPrep(GenoM = GenoM,\n                     LifeHistData = LifeHistData,\n                     nAgeClasses = FacToNum(SeqList$Specs[\"nAgeClasses\"]),\n                     MaxSibIter = MaxSibIter,   # take new value\n                     Err = FacToNum(SeqList$Specs[\"GenotypingErrorRate\"]),\n                     MaxMismatchV = MaxMismatchV,\n                     Tfilter = FacToNum(SeqList$Specs[\"Tfilter\"]),\n                     Tassign = FacToNum(SeqList$Specs[\"Tassign\"]),\n                     MaxSibshipSize = FacToNum(SeqList$Specs[\"MaxSibshipSize\"]),\n                     DummyPrefix = as.character(SeqList$Specs[c(\"DummyPrefixFemale\",\n                                                   \"DummyPrefixMale\")]),\n                     Complexity = as.character(SeqList$Specs[\"Complexity\"]),\n                     UseAge = as.character(SeqList$Specs[\"UseAge\"]),\n                     FindMaybeRel = as.logical(SeqList$Specs[\"FindMaybeRel\"]),\n                     CalcLLR = as.logical(SeqList$Specs[\"CalcLLR\"]))\n  } else {\n    ErrM <- ErrToM(Err, flavour = ErrFlavour, Return = \"matrix\")  # performs checks if Err is already matrix\n\t\tsts <- SnpStats(GenoM, Plot=FALSE)\n\t\tMaxMismatchV <- CalcMaxMismatch(Err=ErrM, MAF=sts[,\"AF\"], ErrFlavour=ErrFlavour,\n\t\t                                qntl=0.999^(1/nrow(GenoM)))  # length 3 vector\n\n    Specs <- SeqPrep(GenoM = GenoM,\n                     LifeHistData = LifeHistData,\n                     nAgeClasses = 1,\n                     MaxSibIter = as.numeric(MaxSibIter),\n                     Err = ifelse(length(Err)==1,\n                                  Err,\n                                  signif(1 - mean(diag(ErrM)), 3)),  # 1 - mean prob. correct (unweighed)\n                     MaxMismatchV = MaxMismatchV,\n                     Tfilter = Tfilter,\n                     Tassign = Tassign,\n            \t\t\t\t MaxSibshipSize = MaxSibshipSize,\n            \t\t\t\t DummyPrefix = DummyPrefix,\n            \t\t\t\t Complexity = Complex,\n            \t\t\t\t UseAge = UseAge,\n            \t\t\t\t FindMaybeRel = FindMaybeRel,\n            \t\t\t\t CalcLLR = CalcLLR)\n  }\n  Specs$TimeStart <- Sys.time()\n  utils::flush.console()\n\n  if (\"AgePriors\" %in% names(SeqList)) {\n    if(!quiet)  message(\"using ageprior in SeqList\")\n    AgePriors <- SeqList$AgePriors\n  } else {\n    AgePriors <- do.call(MakeAgePrior, c(list(Pedigree = NULL,\n                                              LifeHistData = LifeHistData,\n                                              Plot = Plot,\n                                              quiet = quiet),\n                                         args.AP))\n  }\n  Specs[,\"nAgeClasses\"] <- nrow(AgePriors)\n\tif (!all(apply(AgePriors, 2, function(x) any(x > 0)))) {\n\t\tstop(\"AgePriors error: some relationships are impossible for all age differences\")\n\t}\n\n  if (MaxSibIter>-9) {\n\t\tDupList <- DuplicateCheck(GenoM = GenoM, Specs = Specs, ErrM = ErrM,\n\t\t                          LhIN = LifeHistData[,1:5], quiet=quietF)\n    utils::flush.console()\n    if (\"DupGenoID\" %in% names(DupList)) {\n      return(DupList)\n    }\n  } else DupList <- NULL\n  utils::flush.console()\n\n  if (\"PedigreePar\" %in% names(SeqList)) {\n    PedParents <- SeqList$PedigreePar\n    n.shared.ids <- length(intersect(PedParents[,1], rownames(GenoM)))\n    if (n.shared.ids==0) {\n      stop(\"GenoM and SeqList$PedigreePar do not share any common individuals\")\n    } else if (n.shared.ids < nrow(GenoM)/10 && n.shared.ids < nrow(PedParents)) {\n      warning(\"GenoM and SeqList$PedigreePar share few common individuals\")\n    }\n    PedParents <- PedPolish(PedParents, GenoNames = rownames(GenoM), ZeroToNA = TRUE)\n  }\n\n  if (any(LifeHistData$Sex==4)) {  # hermaphrodites - pretend 2 clones of opposite sex\n    if (!quietF) message(\"detected hermaphrodites (sex=4), changing Complex to 'herm'\")\n    GenoM <- herm_clone_Geno(GenoM, LifeHistData, herm.suf=c(\"f\", \"m\"))\n    LifeHistData <- herm_clone_LH(LifeHistData, herm.suf=c(\"f\", \"m\"))\n    Specs[1, \"NumberIndivGenotyped\"] <- nrow(GenoM)\n    Specs[1, \"Complexity\"] <- \"herm\"\n\n    if (\"PedigreePar\" %in% names(SeqList)) {\n      PedParents <- herm_clone_Ped(Ped = PedParents, LH = LifeHistData[,1:3], herm.suf=c(\"f\", \"m\"))\n      PedParents <- PedParents[match(rownames(GenoM),PedParents[,1]), ]\n    }\n  }\n\n  if (\"PedigreePar\" %in% names(SeqList)) {\n    if (MaxSibIter>0) {\n      if(!quiet) message(\"using parents in SeqList\")\n      if (!\"AgePriors\" %in% names(SeqList) && !is.null(LifeHistData)) {\n        AgePriors <- do.call(MakeAgePrior, c(list(Pedigree = PedParents[, 1:3],\n                                                  LifeHistData = LifeHistData,\n                                                  Plot = Plot,\n                                                  quiet = quiet),\n                                             args.AP))\n        if (nrow(AgePriors) != Specs[,\"nAgeClasses\"]) {\n          Specs[,\"nAgeClasses\"] <- nrow(AgePriors)\n        }\n      }\n      ParList <- list(PedigreePar = PedParents)\n      if (\"TotLikParents\" %in% names(SeqList)) {\n        ParList <- c(ParList, SeqList[\"TotLikParents\"])\n      }\n      if (\"MaybeParent\" %in% names(SeqList)) {\n        ParList <- c(ParList, SeqList[\"MaybeParent\"])\n      }\n    } else if (MaxSibIter==0) {  # re-run parentage with pedigree-prior\n      ParList <- SeqParSib(ParSib = \"par\", Specs = Specs, ErrM = ErrM, GenoM = GenoM,\n                           LhIN = LifeHistData[,1:5], AgePriors = AgePriors,\n                           Parents=PedParents, quiet=quietF)\n\t\t\tif (Plot)  SummarySeq(ParList$PedigreePar, Panels=\"G.parents\")\n    } # else keep old parents\n\n  } else if (MaxSibIter>=0){\n    ParList <- SeqParSib(ParSib=\"par\", Specs=Specs,  ErrM = ErrM, GenoM=GenoM,\n                         LhIN=LifeHistData[,1:5],\n                         AgePriors=AgePriors, Parents=NULL, quiet=quietF)\n    if (Plot)  SummarySeq(ParList$PedigreePar, Panels=\"G.parents\")\n    if (!\"AgePriors\" %in% names(SeqList) && !is.null(LifeHistData)) {\n      if (Plot)  Sys.sleep(1)  # else no time to notice previous plot\n      AgePriors <- do.call(MakeAgePrior, c(list(Pedigree = ParList$PedigreePar[, 1:3],\n                                                LifeHistData = LifeHistData,\n                                                Plot = Plot,\n                                                quiet = quiet),\n                                           args.AP))\n      if (nrow(AgePriors) != Specs[,\"nAgeClasses\"]) {\n        Specs[,\"nAgeClasses\"] <- nrow(AgePriors)\n      }\n    } else if (\"AgePriors\" %in% names(SeqList)) {\n      if(!quiet)  message(\"using ageprior in SeqList\")\n    }\n  } else if (MaxSibIter <0) ParList <- NULL\n  utils::flush.console()\n\tif (!all(apply(AgePriors, 2, function(x) any(x > 0)))) {\n\t\tstop(\"AgePriors error: some relationships are impossible for all age differences\")\n\t}\n\n  if (MaxSibIter>0) {\n    SibList <- SeqParSib(ParSib = \"sib\", Specs = Specs, ErrM = ErrM, GenoM = GenoM,\n                         LhIN = LifeHistData[,1:5], AgePriors = AgePriors,\n                         Parents = ParList$PedigreePar, quiet = quietF)\n    ParList <- ParList[names(ParList) != \"AgePriorExtra\"]  # else included 2x w same name\n    if (Plot) {\n      PlotAgePrior(SibList$AgePriorExtra)\n      SummarySeq(SibList$Pedigree, Panels=\"G.parents\")\n    }\n  } else SibList <- NULL\n\n\t# non-assigned putative relatives\n  if (Specs[,\"FindMaybeRel\"]) {\n\t\tif (MaxSibIter > 0) {\n\t\t\tPed <- SibList$Pedigree\n\t\t\tParSib = \"sib\"\n\t\t} else if (MaxSibIter == 0) {\n\t\t\tPed <- ParList$PedigreePar\n\t\t\tParSib = \"par\"\n\t\t} else {\n\t\t\tPed <- NULL\n\t\t\tParSib = \"par\"\n\t\t}\n    MaybeRelPairTrio <- GetMaybeRel(Pedigree = Ped,\n                                    GenoM = GenoM,\n                                    SeqList = list(Specs = Specs,\n                                                   LifeHist = LifeHistData[,1:5],\n                                                   AgePriors = AgePriors),\n                                    ParSib = ParSib,\n                                    quiet = quiet)\n  } else   MaybeRelPairTrio <- NULL\n\n  if (MaxSibIter>=0 & any(LifeHistData$Sex==4)) {\n    ParList$PedigreePar <- herm_unclone_Ped(Ped = ParList$PedigreePar, LH = LifeHistData, herm.suf=c(\"f\", \"m\"))\n    if (MaxSibIter>0) {\n      SibList$Pedigree <- herm_unclone_Ped(Ped = SibList$Pedigree, LH = LifeHistData, herm.suf=c(\"f\", \"m\"))\n    }\n  }\n\n  #=====================\n  Specs$TimeEnd <- Sys.time()\n  OUT <- list()\n  OUT[[\"Specs\"]] <- Specs\n  OUT[[\"ErrM\"]] <- ErrM\n  if (length(Excl)>0)  OUT <- c(OUT, Excl)\n  OUT[[\"AgePriors\"]] <- AgePriors\n  OUT[[\"LifeHist\"]] <- LifeHistData\n  OUT <- c(OUT, DupList, ParList)\n  if (MaxSibIter>0)  OUT <- c(OUT, SibList)\n  if (Specs[,\"FindMaybeRel\"])  OUT <- c(OUT, MaybeRelPairTrio)\n  return(OUT)\n}\n",
    "created" : 1588926721028.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2401482853",
    "id" : "429B50D7",
    "lastKnownWriteTime" : 1588926808,
    "last_content_update" : 1588926808010,
    "path" : "E:/Sequoia/Rversion/sequoia/R/Sequoia_Main.R",
    "project_path" : "R/Sequoia_Main.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}