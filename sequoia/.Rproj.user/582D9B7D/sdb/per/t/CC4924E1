{
    "collab_server" : "",
    "contents" : "#============================================================================\n#============================================================================\n#' @title Estimate confidence probability\n#'\n#' @description Estimate confidence and assignment error rate by repeatedly\n#'   simulating genotype data from a reference pedigree using\n#'   \\code{\\link{SimGeno}}, reconstruction a pedigree from this using\n#'   \\code{\\link{sequoia}}, and counting the number of mismatches using\n#'   \\code{\\link{PedCompare}}.\n#'\n#' @details The confidence probability is taken as the number of correct\n#'   (matching) assignments, divided by all assignments made in the\n#'   \\emph{observed} (inferred-from-simulated) pedigree. In contrast, the false\n#'   negative & false positive assignment rates are proportions of the number of\n#'   parents in the \\emph{true} (reference) pedigree. Each rate is calculated\n#'   separatedly for dams & sires, and separately for each category\n#'   (\\strong{G}enotyped/\\strong{D}ummy(fiable)/\\strong{X} (none)) of\n#'   individual, parent and co-parent.\n#'\n#'  This function does not know which individuals in \\code{Pedigree} are\n#'  genotyped, so the confidence probabilities need to be added to the Pedigree\n#'  by the user as shown in the example at the bottom.\n#'\n#'  A confidence of `1' assignments on simulated data were correct for that\n#'  category-combination. It should be interpreted as (and perhaps modified to)\n#'  \\eqn{> 1 - 1/N}, where sample size \\code{N} is given in the last column of\n#'  the \\code{ConfProb} and \\code{PedErrors} dataframes in the output. The same\n#'  applies for a false negative/positive rate of `0'.\n#'\n#' @section Assumptions: Because the actual true pedigree is (typically)\n#'   unknown, the provided reference pedigree is used as a stand-in and assumed\n#'   to be the true pedigree, with unrelated founders. It is also assumed that\n#'   the probability to be genotyped is equal for all parents; in each\n#'   iteration, a new random set of parents (proportion set by \\code{ParMis}) is\n#'   mimicked to be non-genotyped. In addition, SNPs are assumed to segregate\n#'   independently.\n#'\n#' @param Pedigree Reference pedigree from which to simulate, dataframe with\n#'   columns id-dam-sire. Additional columns are ignored\n#' @param LifeHistData Dataframe with id, sex (1=female, 2=male, 3=unknown), and\n#'   birth year.\n#' @param args.sim  list of arguments to pass to \\code{\\link{SimGeno}}, such as\n#'   \\code{nSnp} (number of SNPs), \\code{SnpError} (genotyping error rate) and\n#'   \\code{ParMis} (proportion of non-genotyped parents). Set to NULL to use all\n#'   default values.\n#' @param args.seq  list of arguments to pass to \\code{\\link{sequoia}}, such as\n#'   \\code{MaxSibIter} (max no. sibship clustering iterations, '0' for parentage\n#'   assignment only) and \\code{Err} (assumed genotyping error rate). May\n#'   include (part of) SeqList, the list of sequoia output (i.e. as a\n#'   list-within-a-list). Set to NULL to use all default values.\n#' @param nSim number of rounds of simulations to perform.\n#' @param quiet suppress messages. `very' also suppresses simulation counter,\n#'   TRUE just runs SimGeno and sequoia quietly.\n#'\n#' @return a list, with the main results in dataframe \\code{ConfProb} and array\n#'   \\code{PedErrors}. \\code{ConfProb} has 7 columns:\n#' \\item{id.cat, dam.cat, sire.cat}{Category of the focal individual, dam, and\n#' sire, in the pedigree inferred based on the simulated data. Coded as\n#' G=genotyped, D=dummy, X=none}\n#' \\item{dam.conf}{Probability that the dam is correct, given the categories of\n#' the assigned dam and sire (ignoring whether or not the sire is correct).\n#' Rounded to \\code{nchar(N)} significant digits}\n#' \\item{sire.conf}{as dam.conf, for the sire}\n#' \\item{pair.conf}{Probability that both dam and sire are correct, given their\n#' categories}\n#' \\item{N}{Number of individuals per category-combination, across all\n#' \\code{nSim} simulations}\n#'\n#' array \\code{PedErrors} has three dimensions:\n#' \\item{class}{\\itemize{\n#'   \\item FalseNeg(atives): could have been assigned but was not\n#' (individual + parent both genotyped or dummyfiable; P1only in\n#' \\code{PedCompare}).\n#'   \\item FalsePos(itives): no parent in reference pedigree, but\n#' one was assigned based on the simulated data (P2only)\n#'   \\item Mismatch: different parents between the pedigrees}}\n#' \\item{cat}{Category of individual + parent, as a two-letter code where the first letter\n#' indicates the focal individual and the second the parent; G=Genotyped, D=Dummy, T=Total}\n#' \\item{parent}{dam or sire}\n#'\n#' The other list elements are:\n#'   \\item{Pedigree.reference}{the pedigree from which data was simulated}\n#'   \\item{Pedigree.inferred}{a list with for each iteration the inferred\n#'     pedigree based on the simulated data}\n#'   \\item{SimSNPd}{a list with for each iteration the IDs of the individuals\n#'     simulated to have been genotyped}\n#'   \\item{RunParams}{a list with the current call to EstConf, as well as the\n#'   default parameter values for \\code{EstConf, SimGeno}, and \\code{sequoia}.}\n#'   \\item{RunTime}{\\code{sequoia} runtime per simulation in seconds, as\n#'     measured by \\code{\\link{system.time}()['elapsed']}.}\n#'\n#' @seealso \\code{\\link{SimGeno}, \\link{sequoia}, \\link{PedCompare}}\n#'\n#' @examples\n#' \\dontrun{\n#' data(Ped_HSg5, LH_HSg5, package=\"sequoia\")\n#'\n#' ## Example A: parentage assignment only\n#' conf.A <- EstConf(Pedigree = Ped_HSg5, LifeHistData = LH_HSg5,\n#'    args.sim = list(nSnp = 100, SnpError = 5e-3, ParMis=c(0.2, 0.5)),\n#'    args.seq = list(MaxSibIter = 0, Err=1e-3, Tassign=0.5),\n#'    nSim = 2)\n#'\n#' # parent-pair confidence, per category:\n#' conf.A$ConfProb\n#'\n#' # calculate (correct) assignment rates (ignores co-parent)\n#' 1 - apply(conf.A$PedErrors, c(1,3), sum, na.rm=TRUE)\n#'\n#' ## Example B: with sibship clustering, based on sequoia inferred pedigree\n#' RealGenotypes <- SimGeno(Ped = Ped_HSg5, nSnp = 100,\n#'                          ParMis=c(0.19,0.53), SnpError = 6e-3)\n#' SeqOUT <- sequoia(GenoM = RealGenotypes,\n#'                   LifeHistData = LH_HSg5,\n#'                   Err=5e-3, MaxSibIter=10)\n#'\n#' conf.B <- EstConf(Pedigree = SeqOUT$Pedigree,\n#'               LifeHistData = LH_HSg5,\n#'                args.sim = list(nSnp = 100, SnpError = 5e-3,\n#'                                ParMis=c(0.2, 0.5)),\n#'               args.seq = list(Err=5e-3, MaxSibIter = 10),\n#'               nSim = 3)\n#' Ped.withConf <- getAssignCat(Pedigree = SeqOUT$Pedigree,\n#'                              Genotyped = rownames(RealGenotypes))\n#' Ped.withConf <- merge(Ped.withConf, conf.B$ConfProb, all.x=TRUE)\n#' Ped.withConf <- Ped.withConf[, c(\"id\",\"dam\",\"sire\", \"dam.conf\", \"sire.conf\",\n#'                                  \"id.cat\", \"dam.cat\", \"sire.cat\")]\n#' }\n#'\n#' @export\n#'\n\nEstConf <- function(Pedigree = NULL,\n                    LifeHistData = NULL,\n                    args.sim = list(nSnp = 400, SnpError = 1e-3, ParMis=c(0.4, 0.4)),\n                    args.seq = list(MaxSibIter = 10, Err=1e-3, Tassign=0.5),\n                    nSim = 10,\n                    quiet=TRUE)\n{\n  if (is.null(Pedigree))  stop(\"Please provide Pedigree\")\n  if (is.null(LifeHistData))  stop(\"Please provide LifeHistData\")\n  if (!is.null(args.sim) & !is.list(args.sim))  stop(\"args.sim should be a list or NULL\")\n  if (!is.null(args.seq) & !is.list(args.seq))  stop(\"args.seq should be a list or NULL\")\n  if (!is.wholenumber(nSim) || nSim<1)  stop(\"nSim must be a positive number\")\n\n  if (\"Err\" %in% names(args.sim)) {\n    args.sim[[\"SnpError\"]] <- args.sim[[\"Err\"]]\n    args.sim[[\"Err\"]] <- NULL    # common confusion, otherwise fuzy matching with 'ErrorFM'.\n  }\n\n  Ped.ref <- Pedigree[,1:3]\n  if (any(substr(unlist(Ped.ref),1,6) %in% c(\"sim_F0\", \"sim_M0\"))) {\n    stop(\"Please don't use 'sim_F' or 'sim_M' in reference pedigree\")\n  }\n\n  if (\"MaxSibIter\" %in% names(args.seq)) {\n    ParSib <- ifelse(args.seq$MaxSibIter > 0, \"sib\", \"par\")\n  } else {\n    ParSib <- \"sib\"   # default MaxSibIter=10\n  }\n\n  if (quiet != \"very\") {\n    if (ParSib == \"par\") {\n      message(\"MaxSibIter=0: Simulating parentage assignment only ...\")\n    } else {\n      message(\"MaxSibIter>0: Simulating full pedigree reconstruction ...\")\n    }\n  }\n  utils::flush.console()\n  seq.quiet <- ifelse(is.logical(quiet), quiet,\n                    ifelse(quiet == \"very\", TRUE, FALSE))\n\n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  # simulate genotypes & infer pedigree\n  RunTime <- rep(NA, nSim)\n  Pedigree.inferred <- list()\n  SimSNPd <- list()\n  for (i in 1:nSim) {\n    if (quiet != \"very\")  cat(\"i=\", i, \"\\t\", format(Sys.time(), \"%H:%M:%S\"), \"\\n\")\n\n    GM <- do.call(SimGeno, c(list(Pedigree=Pedigree), args.sim))\n    SimSNPd[[i]] <- rownames(GM)\n    RunTime[i] <- system.time(Seq.i <- do.call(sequoia, c(list(GenoM = GM,\n                                                               LifeHistData = LifeHistData,\n                                                               DummyPrefix = c(\"sim_F\", \"sim_M\"),\n                                                               quiet = seq.quiet,\n                                                               CalcLLR = FALSE,\n                                                               FindMaybeRel = FALSE,\n                                                               Plot = FALSE),\n                                                          args.seq) ))[\"elapsed\"]\n    if (ParSib == \"par\") {\n      Pedigree.inferred[[i]] <- Seq.i$PedigreePar\n    } else {\n      Pedigree.inferred[[i]] <- Seq.i$Pedigree\n    }\n  }\n\n\n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  # confidence probabilities\n  nSimz <- ifelse(nSim>1, nSim,2)  # else problems w R auto-dropping dimension\n  CatNames <- c(\"G\", \"D\", \"X\")\n  CPP <- array(dim=c(nSimz, 3,3,3,3),\n               dimnames = list(1:nSimz, id.cat=CatNames,\n                               dam.cat=CatNames, sire.cat=CatNames,\n                               Conf=c(\"dam.conf\", \"sire.conf\", \"pair.conf\")))\n  Ni <- array(0, dim=c(nSimz, 3,3,3),\n              dimnames = dimnames(CPP)[1:4])\n\n  for (i in 1:nSim) {\n    PC.rev <- PedCompare(Ped1 = Pedigree.inferred[[i]], Ped2 = Ped.ref,\n                         SNPd = SimSNPd[[i]], Symmetrical=FALSE)\n    CPP[i,c(\"G\",\"D\"),,,] <- CalcPairConf(PC.rev$Counts.detail, ParSib)\n    Ni[i,,,] <- apply(PC.rev$Counts.detail, 1:3, sum)\n  }\n  if (ParSib == \"par\") {\n    Ni[,,\"X\",] <- Ni[,,\"X\",] + Ni[,,\"D\",]\n    Ni[,,\"D\",] <- 0\n    Ni[,,,\"X\"] <- Ni[,,,\"X\"] + Ni[,,,\"D\"]\n    Ni[,,,\"D\"] <- 0\n  }\n\n  # weighed mean across iterations (or not?)\n  Conf.A <- array(dim=c(3,3,3,3), dimnames = c(dimnames(CPP)[2:5]))\n  for (x in 1:3) {\n    Conf.A[,,,x] <- apply(CPP[,,,,x] * Ni, 2:4, sum, na.rm=TRUE) / apply(Ni, 2:4, sum, na.rm=TRUE)\n  }\n  Conf.A[,\"X\",,c(\"dam.conf\", \"pair.conf\")] <- NA\n  Conf.A[,,\"X\",c(\"sire.conf\", \"pair.conf\")] <- NA\n\n  Conf.df <- ArrToDF(Conf.A, Ni, ParSib)\n\n\n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  # assignment errors (ignores co-parent)\n  PedErrors.r <- array(dim=c(nSim, 7,3,2),\n                       dimnames = list(1:nSim,\n                                       cat = c(\"GG\", \"GD\", \"GT\", \"DG\", \"DD\", \"DT\", \"TT\"),\n                                       class = c(\"FalseNeg\", \"FalsePos\", \"Mismatch\"),\n                                       parent = c(\"dam\", \"sire\")))\n  Nr <- array(dim=c(nSim, 7,2),\n              dimnames = dimnames(PedErrors.r)[c(1,2,4)])\n  for (i in 1:nSim) {\n    PC.fwd <- PedCompare(Ped1 = Ped.ref, Ped2 = Pedigree.inferred[[i]],\n                         SNPd = SimSNPd[[i]], Symmetrical=FALSE)\n    PedErrors.r[i,,,] <- sweep(PC.fwd$Counts[,c(\"P1only\", \"P2only\",\"Mismatch\"),], c(1,3),\n                               PC.fwd$Counts[,\"Total\",], \"/\")\n    Nr[i,,] <- PC.fwd$Counts[,\"Total\",]\n  }\n\n  # average across iterations:\n  PedErrors <- apply(PedErrors.r, 2:4, mean, na.rm=TRUE)\n  Ntot <- apply(Nr, 2:3, sum)\n  for (x in 1:3) {\n    PedErrors[,x,] <- signif(PedErrors[,x,], digits=nchar(Ntot))\n  }\n  PedErrors[c(\"GG\", \"GD\", \"DG\", \"DD\"), \"FalsePos\", ] <- NA\n\n\n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  # out\n  RunParams <- list(SimGeno_default = formals(SimGeno),\n                    sequoia_default = formals(sequoia),\n                    EstConf_default = formals(EstConf),\n                    EstConf_specified = match.call())\n\n  return( list(ConfProb = Conf.df,\n               PedErrors = PedErrors,\n               Pedigree.reference = Ped.ref,\n               Pedigree.inferred = Pedigree.inferred,\n               SimSNPd = SimSNPd,\n               RunParams = RunParams,\n               RunTime = RunTime) )\n}\n\n\n\n#============================================================================\nCalcPairConf <- function(PedCompDetails, ParSib=\"sib\") {   # per-iteration\n  CP <- array(NA, dim=c(2,3,3,3),\n              dimnames=c(list(\"id.cat\"=c(\"G\",\"D\")), dimnames(PedCompDetails)[2:3],\n                               list(Conf=c(\"dam\", \"sire\", \"pair\"))))\n  tots1 <- c(\"Match\", \"Mismatch\", \"P2only\")   # total assigned in pedigree 2\n  not1 <- c(\"P1only\", \"_\")\n  m <- ifelse(ParSib==\"par\", 1, 2)\n  CD <- PedCompDetails\n  for (i in 1:m) {\n    # parent-pairs\n    for (j in 1:m) {\n      for (k in 1:m) {\n        CP[i,j,k, \"dam\"] <- sum(CD[i,j,k,\"Match\", tots1]) / sum(CD[i,j,k,tots1, tots1])\n        CP[i,j,k, \"sire\"] <- sum(CD[i,j,k,tots1,\"Match\"]) / sum(CD[i,j,k,tots1,tots1])\n        CP[i,j,k, \"pair\"] <- CD[i,j,k,\"Match\", \"Match\"] / sum(CD[i,j,k,tots1, tots1])\n      }\n    }\n    # single dams\n    for (j in 1:m) {\n      CP[i,j,\"X\",\"dam\"] <- sum(CD[i,j,,\"Match\", not1]) / sum(CD[i,j,, tots1, not1])\n    }\n    # single sires\n    for (k in 1:m) {\n      CP[i,\"X\",k,\"sire\"] <- sum(CD[i,,k,not1,\"Match\"]) / sum(CD[i,,k, not1,tots1])\n    }\n  }\n  return( CP )\n}\n\n\n\n#============================================================================\n\nArrToDF <- function(A.P, A.N, PS) {\n  if (PS == \"par\") {\n    DF <- plyr::adply(A.P[\"G\",c(\"G\",\"X\"),c(\"G\",\"X\"),,drop=\"FALSE\"], 1:3)\n  } else {\n    DF <- plyr::adply(A.P[c(\"G\",\"D\"),,,], 1:3)\n  }\n  N.df <- plyr::adply(A.N, 2:4, sum)\n  names(N.df)[4] <- \"N\"\n  DF <- merge(DF, N.df, all.x=TRUE)\n  for (x in 1:3) {\n    DF[,x] <- factor(DF[,x], levels=c(\"G\", \"D\", \"X\"))\n  }\n  for (x in 4:6) {\n    DF[,x] <- signif(DF[,x], digits = nchar(DF$N))\n  }\n  DF <- DF[order(DF[,1], DF[,2], DF[,3]), ]\n  rownames(DF) <- 1:nrow(DF)\n  return( DF )\n}\n\n#============================================================================\n",
    "created" : 1588349183209.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2369216690",
    "id" : "CC4924E1",
    "lastKnownWriteTime" : 1588916603,
    "last_content_update" : 1588916603,
    "path" : "E:/Sequoia/Rversion/sequoia/R/ConfProb.R",
    "project_path" : "R/ConfProb.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}