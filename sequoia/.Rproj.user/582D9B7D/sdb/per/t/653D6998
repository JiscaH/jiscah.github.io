{
    "collab_server" : "",
    "contents" : "#' @title Pairwise relationship\n#'\n#' @description Determine the relationship between individual X and all other\n#'   individuals in the pedigree, going up to 1 or 2 generations back.\n#'\n#' @param x The focal individual, either its rownumber in the pedigree or ID.\n#' @param Pedigree  dataframe columns id - dam - sire.\n#' @param GenBack  Number of generations back to consider; 1 returns\n#'   parent-offspring and sibling relationships, 2 also returns grandparental,\n#'   avuncular and first cousins.\n#' @param patmat  logical, distinguish between paternal versus maternal relative\n#'   pairs?\n#'\n#' @return A named vector of length equal to the number of rows in Ped, with for\n#'   each ID its relationship to the focal individual:\n#'    \\item{S}{Self}\n#'    \\item{M}{Mother}\n#'    \\item{P}{Father}\n#'    \\item{O}{Offspring}\n#'    \\item{FS}{Full sibling}\n#'    \\item{MHS}{Maternal half-sibling}\n#'    \\item{PHS}{Paternal half-sibling}\n#'    \\item{MGM}{Maternal grandmother}\n#'    \\item{MGF}{Maternal grandfather}\n#'    \\item{PGM}{Paternal grandmother}\n#'    \\item{PGF}{Paternal grandfather}\n#'    \\item{GO}{Grand-offspring}\n#'    \\item{FA}{Full avuncular; maternal or paternal aunt or uncle}\n#'    \\item{HA}{Half avuncular}\n#'    \\item{FN}{Full nephew/niece}\n#'    \\item{HN}{Half nephew/niece}\n#'    \\item{FC1}{Full first cousin}\n#'    \\item{DFC1}{Double full first cousin}\n#'    \\item{U}{Unrelated (or otherwise related)}\n#'\n#' @seealso \\code{\\link{ComparePairs}} to compare pairwise relationships\n#'   between 2 pedigrees.\n#'\n#' @examples\n#' data(Ped_griffin)\n#' # find all relatives of a specific individual\n#' Rel42 <- GetRelCat(\"i042_2003_F\", Ped_griffin)\n#' Rel42[Rel42 != \"U\"]\n#'\n#' # make NxN matrix with relationship categories:\n#' Ped_griffin_sub <- Ped_griffin[Ped_griffin$birthyear<2003,]  # quicker\n#' RCM <- sapply(seq_along(Ped_griffin_sub$id), GetRelCat, Ped_griffin_sub)\n#' table(RCM)\n#' #   M  MHS    O    P    S    U\n#' #  10    6   16    6   40 1522\n#' # note that sibling & cousin pairs are counted twice!\n#' # Parent-offspring pairs are counted directionally:\n#' # once as offspring (O), once as mother (M) or father (P)\n#'\n#' # for large pedigrees, table(factor()) is much faster:\n#' table(factor(RCM, levels=c(\"M\",\"P\",\"FS\",\"MHS\",\"PHS\",\"U\")))\n#'\n#' # list the maternal half-siblings:\n#' these <- which(RCM==\"MHS\", arr.ind=TRUE)\n#' data.frame(id1 = Ped_griffin_sub$id[these[,1]],\n#'            id2 = Ped_griffin_sub$id[these[,2]])\n#'\n#'\n#' # Get Colony-style lists of full sibs & half sibs dyads:\n#' \\dontrun{\n#' RCM <- sapply(seq_along(MyPedigree$id), GetRelCat, Pedigree = MyPedigree,\n#'               GenBack = 1, patmat = FALSE)\n#' # rownumbers of pairs of FS & HS\n#' FullSibDyads <- which(RCM == \"FS\", arr.ind=TRUE)\n#' HalfSibDyads <- which(RCM == \"HS\", arr.ind=TRUE)\n#'\n#' # each pair is listed 2x - fix:\n#' FullSibDyads <- FullSibDyads[FullSibDyads[,1] < FullSibDyads[,2], ]\n#' HalfSibDyads <- HalfSibDyads[HalfSibDyads[,1] < HalfSibDyads[,2], ]\n#'\n#' # translate rownumbers into IDs\n#' MyPedigree$id <- as.character(MyPedigree$id)\n#' FullSibDyads <- cbind(MyPedigree$id[FullSibDyads[,1]],\n#'                       MyPedigree$id[FullSibDyads[,2]])\n#' HalfSibDyads <- cbind(MyPedigree$id[HalfSibDyads[,1]],\n#'                       MyPedigree$id[HalfSibDyads[,2]])\n#' }\n#'\n#' @importFrom stats setNames\n#'\n#' @export\n\nGetRelCat <- function(x, Pedigree, GenBack=2, patmat=TRUE) {\n  Ped <- Pedigree\n  if (is.character(x))   x <- which(Ped$id == x)\n  if (length(intersect(c(\"id\",\"dam\",\"sire\"), tolower(names(Ped)))) < 3) {\n    stop(\"Expect Pedigree column names to contain 'id', 'dam' and 'sire'\")\n  } else {\n    for (i in 1:ncol(Ped)) {\n      if (tolower(names(Ped)[i]) %in% c(\"id\",\"dam\",\"sire\")) {\n        names(Ped)[i] <- tolower(names(Ped)[i])\n      }\n    }\n  }\n  if (!GenBack %in% c(1,2)) {\n    stop(paste(\"Expecting value '1' or '2' for GenBack (no. generations back), got \", GenBack))\n  }\n  if (!patmat %in% c(TRUE,FALSE))  stop(\"'patmat' must be TRUE or FALSE\")\n\n  for (i in 1:ncol(Ped))  Ped[,i] <- as.character(Ped[,i])\n  if (GenBack==2) {\n    nGPcols <- length(intersect(c(\"MGM\",\"MGF\",\"PGM\",\"PGF\"), names(Ped)))\n    if (nGPcols > 0 & nGPcols < 4) {\n      stop(\"Pedigree must either have none of the columns 'MGM', 'MGF', 'PGM', 'PGF', or all 4\")\n    } else if (nGPcols == 0) {\n      IDorder <- Ped$id   # merge() ignores sort=FALSE\n      Ped <- merge(Ped, setNames(Ped[Ped$id %in% Ped$dam,], c(\"dam\", \"MGM\", \"MGF\")), all.x=TRUE)\n      Ped <- merge(Ped, setNames(Ped[,c(\"id\",\"dam\",\"sire\")], c(\"sire\", \"PGM\", \"PGF\")), all.x=TRUE)\n      rownames(Ped) <- Ped$id\n      Ped <- Ped[IDorder, ]\n    }\n  }\n\n  if (patmat) {\n    RCV <- with(Ped,\n            ifelse(id == id[x], \"S\",\n             ifelse(eqv(dam[x],id,FALSE), \"M\",\n              ifelse(eqv(sire[x], id,FALSE), \"P\",\n               ifelse(eqv(id[x], dam, FALSE) | eqv(id[x], sire, FALSE), \"O\",\n                ifelse(eqv(dam[x],dam,FALSE) & eqv(sire[x], sire,FALSE), \"FS\",\n                 ifelse(eqv(dam[x],dam,FALSE), \"MHS\",\n                  ifelse(eqv(sire[x], sire,FALSE), \"PHS\",\n                    \"U\"))))))))\n  } else {\n    RCV <- with(Ped,\n            ifelse(id == id[x], \"S\",\n             ifelse(eqv(dam[x],id,FALSE) | eqv(sire[x], id,FALSE), \"MP\",\n               ifelse(eqv(id[x], dam, FALSE) | eqv(id[x], sire, FALSE), \"O\",\n                ifelse(eqv(dam[x],dam,FALSE) & eqv(sire[x], sire,FALSE), \"FS\",\n                 ifelse(eqv(dam[x],dam,FALSE) | eqv(sire[x], sire,FALSE), \"HS\",\n                        \"U\"))))))\n  }\n\n  if (GenBack==2) {\n    RCV <- with(Ped,\n         ifelse(RCV != \"U\", RCV,\n            ifelse(eqv(MGM[x],id,FALSE), \"MGM\",\n             ifelse(eqv(MGF[x],id,FALSE), \"MGF\",\n              ifelse(eqv(PGM[x],id,FALSE), \"PGM\",\n               ifelse(eqv(PGF[x],id,FALSE), \"PGF\",\n                ifelse(eqv(id[x], MGM, FALSE) | eqv(id[x], MGF, FALSE) |\n                         eqv(id[x], PGM, FALSE) | eqv(id[x], PGF, FALSE), \"GO\",\n                ifelse((eqv(MGM[x],dam,FALSE) & eqv(MGF[x], sire, FALSE)) |\n                          (eqv(PGM[x],dam,FALSE) & eqv(PGF[x], sire, FALSE)), \"FA\", # full avuncular\n                ifelse((eqv(dam[x], MGM,FALSE) & eqv(sire[x], MGF, FALSE)) |\n                          (eqv(dam[x], PGM,FALSE) & eqv(sire[x], PGF, FALSE)), \"FN\", # full niece/nephew\n                 ifelse(eqv(MGM[x],dam,FALSE) | eqv(MGF[x], sire, FALSE) |\n                           eqv(PGM[x],dam,FALSE) | eqv(PGF[x], sire, FALSE), \"HA\",  # half avuncular\n                 ifelse((eqv(dam[x], MGM,FALSE) | eqv(sire[x], MGF, FALSE)) |\n                          (eqv(dam[x], PGM,FALSE) | eqv(sire[x], PGF, FALSE)), \"HN\",\n                  ifelse((eqv(MGM[x],MGM,FALSE) & eqv(MGF[x], MGF, FALSE) &\n                        eqv(PGM[x],PGM,FALSE) & eqv(PGF[x], PGF, FALSE)) |\n                         (eqv(MGM[x],PGM,FALSE) & eqv(MGF[x], PGF, FALSE) &\n                          eqv(PGM[x],MGM,FALSE) & eqv(PGF[x], MGF, FALSE)), \"DFC1\",  # double full 1st cousins\n                   ifelse((eqv(MGM[x],MGM,FALSE) & eqv(MGF[x], MGF, FALSE)) |\n                        (eqv(PGM[x],PGM,FALSE) & eqv(PGF[x], PGF, FALSE)) |\n                         (eqv(MGM[x],PGM,FALSE) & eqv(MGF[x], PGF, FALSE)) |\n                          (eqv(PGM[x],MGM,FALSE) & eqv(PGF[x], MGF, FALSE)), \"FC1\",  # full 1st cousins\n                          \"U\")))))))))))))\n    if (!patmat) {\n      RCV[RCV %in% c(\"MGM\", \"MGF\", \"PGM\", \"PGF\")] <- \"GP\"\n    }\n  }\n\n  names(RCV) <- Ped$id\n\treturn( RCV )\n}\n",
    "created" : 1588918397627.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1764983440",
    "id" : "653D6998",
    "lastKnownWriteTime" : 1589736218,
    "last_content_update" : 1589736218633,
    "path" : "E:/Sequoia/Rversion/sequoia/R/PairRelation.R",
    "project_path" : "R/PairRelation.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}