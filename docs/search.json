[{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"error-patterns","dir":"Articles","previous_headings":"","what":"Error patterns","title":"Genotyping errors","text":"pattern genotyping errors depend genotyping method software used call SNPs. SNP arrays, clustering based intensity vs probe results chance true homozygote AA erroneously scored heterozygote Aa likely reverse. contrast, sequencing-based methods scoring true heterozygote erroneously homozygote much likely reverse, especially low coverage. one-size-fits-error model SNP genotypes, sequoia offers full flexibility specifying error pattern. done via 3x3 matrix (heterozygotes Aa aA interchangeable) probabilities observing genotype \\(y\\) given true genotype \\(x\\).","code":""},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"default-model","dir":"Articles","previous_headings":"","what":"Default model","title":"Genotyping errors","text":"default error model based SNP array genotyping, version 2.0 onwards defined : Probability observed genotype (columns) conditional actual genotype (rows) per-locus error rate E error rate 1% translates : 0, 1 2 refers number copies reference allele . true genotype homozygote aa (top row), probabilities derived follows: aa: probability neither allele observed incorrectly, .e. \\((1-E/2) \\times (1-E/2)\\) Aa: probability first allele mis-observed (\\(E/2\\)) second allele (\\(1-E/2\\)), plus vice versa. Thus, \\(P=2 \\times (E/2) \\times (1-E/2) = E (1-E/2)\\). AA: probability alleles observed incorrectly","code":"sequoia::ErrToM(Err=0.01) ##       obs-0|act obs-1|act obs-2|act ## act-0   9.9e-01  0.009975   2.5e-05 ## act-1   5.0e-03  0.990000   5.0e-03 ## act-2   2.5e-05  0.009975   9.9e-01"},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"error-model-in-previous-versions","dir":"Articles","previous_headings":"Default model","what":"Error model in previous versions","title":"Genotyping errors","text":"\\((E/2)^2 \\approx 0\\) \\((1-E/2)^2 \\approx 1-E\\), illustrated example Err=0.01. implies current default error model differ much simpler error model version 0.9 may seem first glance: previous table, sequoia 0.9 Using value \\(0\\) error matrix advised, puts infinite amount weight locus happen (see also Cromwell’s rule.","code":""},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"per-locus-vs-per-allele-error-rate","dir":"Articles","previous_headings":"","what":"Per-locus vs per-allele error rate","title":"Genotyping errors","text":"error rate \\(E\\) (Err) previous part represents per-locus error rate; per-allele error rate \\(E/2\\). appears consistency literature whether per-locus per-allele error rate used, worth making sure defined consistently throughout analysis pipeline. pedigree reconstruction sequoia, factor 2 generally large consequences. prefer, easily re-define error matrix terms per-allele error rate (say \\(\\epsilon\\)): Error matrix redefined per-allele error rate \\(\\epsilon\\) can done via sequoia() argument Err ErrFlavour, described next.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"via-err","dir":"Articles","previous_headings":"Changing the error model","what":"via Err","title":"Genotyping errors","text":"can pass 3x3 matrix Err, requirement rows must sum 1. homozygote reference allele may likely mis-typed homozygote alternative allele, heterozygote may mis-typed different probabilities two homozygotes, whatever else appropriate dataset. example, following counts genotyping samples several times: problem cell \\(0\\): leaving , imply true can never observed aa, even genotype thousands samples. seems unlikely, quick fix let’s pretend genotyped twice many, found 1 error: divide rowsums, e.g. using sweep(): use input sequoia() analysis: reality probably want something bit sophisticated, e.g. relying known error pattern genotyping platform.","code":"ErrCount <- matrix(c(14, 3, 5,                      4, 28, 9,                      0, 4, 72),                    nrow=3, byrow=TRUE) ErrCount ##      [,1] [,2] [,3] ## [1,]   14    3    5 ## [2,]    4   28    9 ## [3,]    0    4   72 ErrCount[3,1] <- 0.5 ErrProbs <- sweep(ErrCount, MARGIN=1, STATS=rowSums(ErrCount), FUN=\"/\") round(ErrProbs, 3) ##       [,1]  [,2]  [,3] ## [1,] 0.636 0.136 0.227 ## [2,] 0.098 0.683 0.220 ## [3,] 0.007 0.052 0.941 SeqOUT <- sequoia(GenoData, LifeHistData,                   Err = ErrProbs)"},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"via-errflavour","dir":"Articles","previous_headings":"Changing the error model","what":"via ErrFlavour","title":"Genotyping errors","text":"want run sequoia() several presumed error rates, need re-calculate 3x3 error matrix several times. can , can provide argument ErrFlavour function turns single number 3x3 matrix. example, re-define error matrix terms per-allele error rate:","code":"ErFunc_allele <- function(Ea) {       matrix(c((1-Ea)^2, 2*Ea*(1-Ea), (Ea)^2,               Ea, 1-2*Ea, Ea,               (Ea)^2, 2*Ea*(1-Ea), (1-Ea)^2),              3,3, byrow=TRUE) }  ErFunc_allele(0.01) ##        [,1]   [,2]   [,3] ## [1,] 0.9801 0.0198 0.0001 ## [2,] 0.0100 0.9800 0.0100 ## [3,] 0.0001 0.0198 0.9801 ErFunc_allele(0.005) ##          [,1]    [,2]     [,3] ## [1,] 0.990025 0.00995 0.000025 ## [2,] 0.005000 0.99000 0.005000 ## [3,] 0.000025 0.00995 0.990025 SeqOUT <- sequoia(GenoData, LifeHistData,                   Err = 0.005,                   ErrFlavour = ErFunc_allele)"},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"variation-between-snps","dir":"Articles","previous_headings":"","what":"Variation between SNPs","title":"Genotyping errors","text":"Currently constant error rate across SNPs assumed. unclear whether setting presumed rate arithmetic mean rate (regular average) across SNPs gives best performance real world data. Anecdotal evidence suggests using somewhat higher presumed error rate increases performance (correct assignments /fewer incorrect assignments), thoroughly explored. may partly due confusion per-locus per-allele error rate, also due skewed nature distributions (many alleles low error rate, high error rate), resulting arithmetic mean lower median. rates, harmonic mean may appropriate.","code":""},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Genotyping errors","text":"calculation likelihoods incorporating genotyping errors described Huisman (2017), can explored using CalcPairLL. Noteworthy probabilistic estimate individual’s true genotype depends observed genotype parents’ estimated true genotypes, genotypes offspring. potentially create unstable seesaw situation, assignment parent affected affect parent’s estimated true genotype. dummy individuals, observed genotype, offspring genotypes necessarily affect estimated true genotype. prevent algorithm seesawing marginal probabilities calculated, excluding grandparents /one, two offspring calculation, appropriate particular relationship likelihood (importantly avoiding implicitly conditioning oneself). main reason marginal probabilities implemented genotyped individuals, relatively large computational cost, negligible effect pedigree outcome moderately high quality SNP data (error rate < 1% low missingness).1","code":""},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"try-out-different-values","dir":"Articles","previous_headings":"","what":"Try out different values","title":"Genotyping errors","text":"Due variation error rate SNPs genotyping errors implemented, usually good idea run sequoia() different presumed genotyping error rates. allows make sure results robust slight mis-specifications parameter, /optimise false negative false positive assignment rates.","code":""},{"path":"https://jiscah.github.io/articles/genotyping_errors.html","id":"err-0","dir":"Articles","previous_headings":"Try out different values","what":"Err = 0","title":"Genotyping errors","text":"sequoia() guaranteed work assumed error rate \\(0\\), especially complex pedigrees. problem new assignment considers direct vicinity putative parent-offspring pair, full pedigree. assignment cascading effects probabilities true, underlying genotypes dummy partially genotyped individuals downstream pedigree, may result impossibilities Err=0 genotyping errors present.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/help.html","id":"questions","dir":"Articles","previous_headings":"","what":"Questions","title":"Need help?","text":"repeated tries, checking help files, examples vignettes, can’t figure sequoia isn’t working way think working: please feel free email <jisca.huisman gmail.com>. Usually ’ll get back within 1–2 days (European daytime). example: really sure aren’t weird symbols datafile? really sure genotyping error rate low claim ? really sure sequoia() able distinguish different kind relatives dataset? Please see main vignette really sure genotypes belong relatives? try CalcPairLL() ? Please email ; something may slipped input check. can check changelog bugs patched development version","code":""},{"path":"https://jiscah.github.io/articles/help.html","id":"consultancy-work","dir":"Articles","previous_headings":"","what":"Consultancy work","title":"Need help?","text":"time manpower perform pedigree reconstruction (get familiar yet another piece software / R package), may able assist freelance consultant.","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"general","dir":"Articles","previous_headings":"","what":"General","title":"Mendelian Inheritance","text":"Genetic pedigree reconstruction relies critically pattern Mendelian inheritance: probability offspring inherits specific genotype locus, given genotypes parents. locus two alleles (biallelic SNPs allowed sequoia), inheritance probabilities take values \\(0\\), \\(1/4\\), \\(1/2\\), \\(1\\). can depicted many different ways, mostly matter personal preference, tend think kind table: Table 1: Possible offspring genotypes conditional two parental genotypes  shows possible offspring genotypes may result possible combination parental genotypes. example, mother Aa father AA, 50% chance offspring AA, 50% chance offspring Aa. table allele inherited mother one inherited father considered interchangeable, Aa = aA. Note also true genotypes, may differ observed genotypes due genotyping errors. 1","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"single-parent","dir":"Articles","previous_headings":"General","what":"Single parent","title":"Mendelian Inheritance","text":"similar table can also constructed conditional one instead two parental genotypes. allele assumed drawn population allele pool random, contains allele frequency \\(q\\) allele frequency \\(1-q\\). equivalent assumption genotype parent random draw genotypes population Hardy-Weinberg equilibrium (genotype frequencies \\(q^2\\), \\(2q(1-q)\\) \\((1-q)^2\\) AA, Aa aa, respectively). Table 2: Possible offspring genotypes conditional one parental genotype allele inherited parent  Table 3: Probability offspring genotype (columns) conditional one parental genotype population allele frequency q ‘’ allele","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"no-genotyping-errors","dir":"Articles","previous_headings":"Parentage assignment based on Mendelian incompatibilities","what":"No genotyping errors","title":"Mendelian Inheritance","text":"individual AA locus, true parent aa locus (bottom-left Table 3), thus aa individuals can discarded potential parents. example allele frequency \\(q=0.4\\), discard 36% individuals (\\((1-0.4)^2=0.36\\)), just considering single SNP. increasing number SNPs considered, increasing proportion population can discarded potential parent based opposing homozygosity test alone.","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"with-genotyping-errors","dir":"Articles","previous_headings":"Parentage assignment based on Mendelian incompatibilities","what":"With genotyping errors","title":"Mendelian Inheritance","text":"real data, small chance individual scored AA truly parent scored aa, either one might mis-genotyped actually heterozygous 2 (see also background info genotyping errors. allow possibility, non-zero maximum threshold set number loci individual candidate parent may opposing homozygotes (OH), number loci individual candidate parent-pair may Mendelian errors. latter includes besides OH also cases offspring heterozygous Aa parents identical homozygotes (AA aa; see Table 1). genotyping error low number SNPs large (high hundreds/thousands), counting Mendelian errors usually sufficient reduce number candidate parents single pair individual. widely used reliable method parentage assignment, since abundance high-quality SNP data distinction parent -parent typically clear (Hayes (2011), Calus, Mulder, Bastiaansen (2011), Strucken et al. (2016)).","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"limitations","dir":"Articles","previous_headings":"Parentage assignment based on Mendelian incompatibilities","what":"Limitations","title":"Mendelian Inheritance","text":"Even high quality data, close relatives true parents also opposing homozygotes low number SNPs. especially true full siblings focal individual full siblings true parent. settings straight forward exclude full siblings potential parents (e.g. animal husbandry discrete generations), full aunts uncles can rarely excluded priori. Moreover, many datasets SNPs /high genotyping error rate method work reliably – see example","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"expected-number-of-mendelian-errors","dir":"Articles","previous_headings":"","what":"Expected number of Mendelian errors","title":"Mendelian Inheritance","text":"theoretical distribution number Mendelian errors true parent-offspring pairs true parent-parent-offspring trios can calculated number SNPs, genotyping error rate, allele frequencies. implemented R package function CalcMaxMismatch(). parent-offspring pairs calculations R code worked detail, calculations parent-parent-offspring trios similar.","code":""},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"mismatch-probability","dir":"Articles","previous_headings":"Expected number of Mendelian errors","what":"Mismatch probability","title":"Mendelian Inheritance","text":"probability offspring observed aa parent AA, parent unknown, function : probability parent’s true genotype \\(g_{par}\\), given population allele frequency \\(q\\) assuming Hardy-Weinberg equilibrium; probability parent observed AA true genotype \\(g_{par}\\); depends genotyping error rate \\(E\\) error structure; probability offspring inherits true genotype \\(g_O\\), given parents true genotype \\(g_{par}\\) parent’s genotype random; probability offspring observed aa true genotype \\(g_{}\\); probabilities fairly straight forward, multiplying summing across \\(3\\times3\\) possible true genotypes parent offspring. example, case \\(g_{par}=Aa\\) \\(g_{}=aa\\): \\(P(g_{par}=Aa) = 2q(1-q)\\) \\(P(obs\\ AA | act\\ Aa) = E/2\\) (default error matrix) \\(P_{inherit} = (1-q)/2\\) (Table 3) \\(P(obs\\ aa | act\\ aa) = (1-E/2)^2\\) write simplify expression summing nine genotype combinations, let R hard work: probability single parent-offspring pair single locus opposing homozygotes (OH). expected number loci parent-offspring pair OH follows binomial distribution. simplicity assume example SNPs allele frequency genotyping error rate (assumption made CalcMaxMismatch().","code":"# example values q <- 0.4   # allele frequency E <- 0.01  # genotyping error rate  # 1. probabilities of actual genotypes under HWE (0, 1 or 2 copies of reference allele) AHWE <- c((1-q)^2, 2*q*(1-q), q^2)  # 2 + 4. probability of observed genotype (columns) conditional on actual genotype (rows)  ErrM <- ErrToM(Err = E, flavour=\"version2.0\", Return=\"matrix\") ErrM ##       obs-0|act obs-1|act obs-2|act ## act-0  0.990025   0.00995  0.000025 ## act-1  0.005000   0.99000  0.005000 ## act-2  0.000025   0.00995  0.990025 # 3. probability that offspring actual genotype is 0/1/2 (rows) given  #    parent actual genotype is 0/1/2 (columns).  # (Transposed relative to Table 3) AKAP <- matrix(c(1-q, (1-q)/2, 0,                  q,   1/2,     1-q,                  0,   q/2,     q),                   nrow=3, byrow=TRUE)                   # joined probability actual genotypes: (1. x 3.) P.AA <- sweep(AKAP, 2, AHWE, \"*\") dimnames(P.AA) <- list(0:2, 0:2) P.AA ##       0     1     2 ## 0 0.216 0.144 0.000 ## 1 0.144 0.240 0.096 ## 2 0.000 0.096 0.064 # joined probability observed genotypes: (2. x (1. x 3.) x 4.) P.OO <- t(ErrM) %*% P.AA %*% ErrM dimnames(P.OO) <- list(0:2, 0:2) round(P.OO, 4) ##        0      1      2 ## 0 0.2131 0.1445 0.0012 ## 1 0.1445 0.2400 0.0959 ## 2 0.0012 0.0959 0.0637 P.Mismatch <- P.OO[1,3] + P.OO[3,1] P.Mismatch ## [1] 0.00240198 # using same no. SNPs as in low quality example data below nSnp <- 100     curve(dbinom(x, size = nSnp, prob = P.Mismatch),       from=0, to=10, n=11, type=\"b\",       xlab=\"No. opposing homozygous loci\", ylab=\"Probability\") cbind(OHcount = 0:5,       prob = round(dbinom(0:5, size = nSnp, prob = P.Mismatch),4)) ##      OHcount   prob ## [1,]       0 0.7862 ## [2,]       1 0.1893 ## [3,]       2 0.0226 ## [4,]       3 0.0018 ## [5,]       4 0.0001 ## [6,]       5 0.0000"},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"threshold","dir":"Articles","previous_headings":"Expected number of Mendelian errors","what":"Threshold","title":"Mendelian Inheritance","text":"parentage assignment, threshold OH count used filter candidate parents. threshold set highly unlikely true parent-offspring pairs discarded. Assignments made based likelihoods calculated filtering step, thus -parents pass filter necessarily result false positive assignments 3. threshold must expected OH count true parent-offspring pairs value, just random pair. example, probability random parent-offspring pair OH count 3 lower makes 3 seem like good value threshold. However, probability say 3000 parent-offspring pairs value (pretending independent) great. set threshold maxOH certain probability (say \\(x=0.999\\)) exclude \\(Z\\) true parent-offspring pairs, must solve pbinom(maxOH, size=nSnp, prob=P.Mismatch)^Z \\(= x\\): \\[ \\begin{aligned} y^Z = x \\\\ y = x^{1/Z} \\end{aligned} \\] words, set desired probability \\(0.999^{1/Z}\\). course know number parent-offspring pairs \\(Z\\) prior parentage assignment, datasets reasonable assume roughly equal number individuals \\(N\\) (least order magnitude). double check:","code":"pbinom(3, size=nSnp, prob=P.Mismatch) ## [1] 0.9998914 pbinom(3, size=nSnp, prob=P.Mismatch)^3000 ## [1] 0.7219437 N <- 3000 stats::qbinom(0.999^(1/N), size = nSnp, prob = P.Mismatch) ## [1] 5 pbinom(5, size=nSnp, prob=P.Mismatch)^N ## [1] 0.9994341"},{"path":[]},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"data","dir":"Articles","previous_headings":"Example","what":"Data","title":"Mendelian Inheritance","text":"R package includes griffin example pedigree 200 individuals, 167 known dam 163 known sire. two sets genotype data simulated pedigree: one high quality, one low quality.","code":"# simulate genotype data Geno.highQ <- SimGeno(Ped_griffin, nSnp=500, ParMis=0, SnpError=1e-4) Geno.lowQ  <- SimGeno(Ped_griffin, nSnp=100, ParMis=0, SnpError=0.01) # default parameter values: 1% of SNPs missing, MAF uniform between 0.3 and 0.5. # ParMis=0 : no non-genotyped parents"},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"distribution-of-opposing-homozygous-loci-count","dir":"Articles","previous_headings":"Example","what":"Distribution of opposing homozygous loci count","title":"Mendelian Inheritance","text":"number opposing homozygous loci possible pairs individuals counted SNP datasets:  high quality SNP set clear separation first peak (parent-offspring pairs, OH=0) second peak (pairs). low quality SNP set, area two peaks overlap. Zooming shows clearly:  high quality SNP set, shaded area representing 2-7 opposing homozygous loci includes one two pairs individuals (variable simulated datasets), matter much exactly threshold placed. low quality SNP set, hundreds pairs 1-4 opposing homozygous loci, slightly changing threshold considerably change number assignments (unknown proportion false positives).","code":"# define function to count no. opposing homozygous loci in two vectors x and y CountOH <- function(x, y)  sum((x==2 & y==0) | (x==0 & y==2), na.rm=TRUE)  # apply this function all possible pairs  N <- nrow(Geno.highQ)  # no. individuals OH.highQ <- matrix(NA, N, N)  # matrix for output OH.lowQ <- matrix(NA, N, N) # do upper triangle of matrix only, excluding diagonal (self) for (i in seq(1, N-1)) {   for (j in seq(i+1, N)) {     OH.highQ[i,j] <- CountOH(Geno.highQ[i,], Geno.highQ[j,])     OH.lowQ[i,j] <- CountOH(Geno.lowQ[i,], Geno.lowQ[j,])   } }  # plot histograms par(mfcol=c(1,2), mai=c(.9,.9,.5,.6)) hist(OH.highQ, breaks=50, xlab=\"No. SNPs opposing homozygous\",      main=\"High quality:\\n 500 SNPs, error rate 0.01%\") hist(OH.lowQ, breaks=25, xlab=\"No. SNPs opposing homozygous\",      main=\"Low quality:\\n 100 SNPs, error rate 1%\") par(mfcol=c(1,2), mai=c(.9,.9,.5,.6)) hist(OH.highQ, breaks=seq(-1,max(OH.highQ,na.rm=TRUE))+.5, xlim=c(-1,20), ylim=c(0,100),      xlab=\"No. SNPs opposing homozygous\", main=\"500 SNPs, error rate 0.01%\") abline(v=2, lwd=3, lty=2, col=\"forestgreen\") rect(xleft=1.5, ybottom=-20, xright=7.5, ytop=200,      col=adjustcolor(\"forestgreen\", alpha.f=0.4), border=NA)  hist(OH.lowQ, breaks=seq(-1,max(OH.lowQ,na.rm=TRUE))+.5, xlim=c(-1,10), ylim=c(0,1000),       xlab=\"No. SNPs opposing homozygous\", main=\"100 SNPs, error rate 1%\") abline(v=2, lwd=3, lty=2, col=\"forestgreen\") rect(xleft=0.5, ybottom=-50, xright=4.5, ytop=1200,      col=adjustcolor(\"black\", alpha.f=0.4), border=NA)"},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"assignment-with-sequoia","dir":"Articles","previous_headings":"Example","what":"Assignment with sequoia()","title":"Mendelian Inheritance","text":"Likelihood-based parentage assignment sequoia intended situations SNP data overwhelmingly strong, like low quality genotype data example. checks whether parent-offspring genotype combination possible , also likely . example, mating aa aa parent pair always results aa offspring, aa X Aa mating 50% time, Aa X Aa mating 25% time. Thus, aa offspring, aa parent likely Aa parent. single parents also considers likely ‘’ allele (one inherited candidate parent consideration) inherited random individual. depends allele frequency (Table 3): putative parent shares rare allele individual, affects likelihood strongly (individual unlikely inherited individual), allele share common inherited anyone. 4 details, please see Huisman (2017).","code":"# parentage assignment using sequoia data(LH_griffin, package=\"sequoia\")  # sex + birth year information  SeqPAR.lowQ <- sequoia(Geno.lowQ, LifeHistData=LH_griffin,                                 Err=0.01, Module=\"par\",                                 quiet=TRUE, Plot=FALSE)  SeqPAR.lowQ$Specs[c(\"MaxMismatchOH\", \"MaxMismatchME\")] ##       MaxMismatchOH MaxMismatchME ## Specs             5             8 # check reconstructed pedigree PC.lowQ <- PedCompare(Ped_griffin, SeqPAR.lowQ$PedigreePar, Plot=FALSE) PC.lowQ$Counts[\"GT\",,] ##           parent ## class      dam sire ##   Total    167  163 ##   Match    165  161 ##   Mismatch   0    0 ##   P1only     2    2 ##   P2only     0    0 # P1only: false negative (assignment in pedigree 1 (= original) only) # P2only: false positive (assignment in pedigree 2 (= reconstructed) only)"},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"count-mendelian-errors","dir":"Articles","previous_headings":"Example","what":"Count Mendelian errors","title":"Mendelian Inheritance","text":"can count OH true parent-offspring pairs, check whether non-assigned parents particular outliers:  reason parents remained unassigned pass filtering step, subsequent likelihood calculations. Probably likelihood parent offspring similar likelihood full siblings, thus assignment made. likelihoods can calculated retrieved function CalcPairLL(). details, see vignette info pairwise likelihoods.","code":"Ped.true.OH <- CalcOHLLR(Pedigree = Ped_griffin,                                   GenoM = Geno.lowQ,                                   CalcLLR = FALSE) ## Counting Mendelian errors ... # distribution of OH & trio Mendelian errors: SummarySeq(Ped.true.OH, Panels=\"OH\")"},{"path":"https://jiscah.github.io/articles/mendelian_inheritance.html","id":"notes","dir":"Articles","previous_headings":"Example","what":"Notes","title":"Mendelian Inheritance","text":"Please note also sequoia limitations, parentage assignment real-world data 100 SNPs estimated average genotyping error rate 1% probably performs worse, due higher missingness, lower allele frequencies, LD SNPs, non-random distribution genotyping errors, etc. Moreover, please note sibship clustering grandparent assignment require /higher quality SNPs parentage assignment.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/mtDNA.html","id":"why-use-mitochondrial-data","dir":"Articles","previous_headings":"","what":"Why use mitochondrial data","title":"Using mitochondrial haplotypes","text":"Using data sharing mitochondrial (mt) haplotypes makes possible distinguish maternal/matrilineal paternal/patrilineal relatives. example, half-siblings sharing mother always mitochondrial haplotype, half-siblings sharing father may different haplotypes. Similarly, individual always mitochondrial haplotype maternal grandmother, (necessarily) paternal grandmother. Example pedigree colour coded mitochondrial haplotype inheritance","code":""},{"path":"https://jiscah.github.io/articles/mtDNA.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Using mitochondrial haplotypes","text":"paternal relatives may share mitochondrial haplotype, especially small populations population founded limited number females; Mitochondrial haplotype sharing help distinguish maternal half-siblings, full avuncular, grand-parental pairs, generations overlap assignment rate may still 100%; can challenging set threshold ‘’ versus ‘different’ haplotypes, especially non-negligible genotyping error rate, limited number polymorphic mitochondrial markers, /low call rate. conservative approach input sequoia set uncertain pairs ‘’ (see next section).","code":""},{"path":"https://jiscah.github.io/articles/mtDNA.html","id":"input","dir":"Articles","previous_headings":"","what":"Input","title":"Using mitochondrial haplotypes","text":"package version 2.7 onwards, function sequoia() input parameter mtSame. matrix pair individuals indicating whether share mitochondrial haplotype (1) different haplotypes (0). algorithm focusses differences: two individuals \\(\\) \\(j\\) close relatives according autosomal SNPs, different mitochondrial haplotypes (mtsame[,j]==0), maternal/matrilineal relatives, thus must paternal/patrilineal relatives. contrast, two individuals share mitochondrial haplotype (mtsame[,j]==1), may maternal relatives, excluded paternal relatives. Therefore, unclear unknown whether two individuals share mitochondrial haplotype, coded 1 NA, interpreted ‘may may ’, 0 interpreted ‘definitely different’ (= definitely maternal relatives).","code":""},{"path":"https://jiscah.github.io/articles/mtDNA.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Using mitochondrial haplotypes","text":"example uses single cohort pedigree Ped_HSg5, included package. females males multiple mates, resulting maternal paternal half-siblings well full siblings. pretend none parents genotyped, breeding female unique mitochondrial haplotype. First, let us create dataset example: function infer_mt_haplotype() included package, available . can also used real data, mother-offspring relationships reliably known, e.g. behavioural observations, subset individuals genotyped mitochondrial markers. infers haplotypes ancestors descendants individuals known haplotypes, iterates times infer haplotypes matrilineal relatives. , create matrix pair individuals whether (1) different (0) haplotype: Simulate autosomal SNP data, none parents genotyped: Run sequoia & without mtSame (note can take couple minutes run): Count number half-siblings assigned run: Thus, without mtSame single half-sibling relationship assigned, determined whether maternal paternal half-siblings. contrast, mtSame hundreds half-siblings assigned. example, effect mtSame number individuals dummy parent assigned negligible, every individual several full-siblings, dummy mother father assigned full-sibling cluster. additional full siblings assigned: default option Complex = 'full' distinction full siblings versus e.g. ‘half siblings well cousins’ (r=3/8) always clear, assignment additional maternal /paternal half-siblings may clarify full sibling relationships. graphical representation results can run:","code":"library(sequoia) # pedigree subset id_subset <- as.character( LH_HSg5[LH_HSg5$BirthYear == 2001, 'ID'] ) Ped_sub <- Ped_HSg5[Ped_HSg5$id %in% id_subset,]  # assign a mitochondrial haplotype code to each founding female founder_females <- as.character( LH_HSg5[LH_HSg5$BirthYear == 2000 & LH_HSg5$Sex==1, 'ID'] ) mtHaps_founders <- setNames( LETTERS[1:length(founder_females)], founder_females) head(mtHaps_founders) ## a00001 a00002 a00003 a00004 a00005 a00006  ##    \"A\"    \"B\"    \"C\"    \"D\"    \"E\"    \"F\" # infer mitochondrial haplotypes for all matrilineal descendants of individuals  # with known haplotypes source('https://raw.githubusercontent.com/JiscaH/sequoiaExtra/main/infer_mt_haplo.R')  mtHaps_all <- infer_mt_haplotype(Ped_sub, mtHaps_founders) mtHaps_all[41:50] ## a01036 a01039 a01042 a01043 a01046 a01047 a01048 a01050 a01051 a01053  ##    \"F\"    \"D\"    \"R\"    \"R\"    \"F\"    \"F\"    \"F\"    \"E\"    \"E\"    \"H\" # add mitochondrial haplotype code to pedigree Ped_sub$mt <- mtHaps_all[as.character(Ped_sub$id)] head(Ped_sub) ##        id    dam   sire mt ## 41 a01001 a00014 b00011  N ## 42 a01002 a00014 b00011  N ## 43 b01003 a00014 b00011  N ## 44 b01004 a00014 b00011  N ## 45 a01005 a00013 b00001  M ## 46 b01006 a00013 b00001  M mt_same <- outer(mtHaps_all, mtHaps_all, FUN = function(x,y) as.numeric(x==y)) mt_same[41:48, 41:48] ##        a01036 a01039 a01042 a01043 a01046 a01047 a01048 a01050 ## a01036      1      0      0      0      1      1      1      0 ## a01039      0      1      0      0      0      0      0      0 ## a01042      0      0      1      1      0      0      0      0 ## a01043      0      0      1      1      0      0      0      0 ## a01046      1      0      0      0      1      1      1      0 ## a01047      1      0      0      0      1      1      1      0 ## a01048      1      0      0      0      1      1      1      0 ## a01050      0      0      0      0      0      0      0      1 Geno_A <- SimGeno(Ped_sub, nSnp=500, ParMis=1, SnpError=1e-3) SeqOUT_regular <- sequoia(Geno_A, LH_HSg5, quiet=TRUE) SeqOUT_mt <- sequoia(Geno_A, LH_HSg5, mtSame = mt_same, quiet=TRUE) RelM_regular <- GetRelM(SeqOUT_regular$Pedigree, patmat=TRUE) table(c(RelM_regular)) ##  ##    FS     M     O     P     S     U  ##   620   188   376   188   284 79000 RelM_mt <- GetRelM(SeqOUT_mt$Pedigree, patmat=TRUE) table(c(RelM_mt)) ##  ##    FS     M   MHS     O     P   PHS     S     U  ##   640   192   704   384   192  1472   232 50008 PlotRelPairs(RelM_regular) PlotRelPairs(RelM_mt)"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Classification of pairs using likelihoods","text":"Pedigree reconstruction sequoia() sometimes suffers high rates non-assignment true relatives (false negatives). often tell whether pair maternal paternal relatives, tell type second degree relatives . information can found user guide). fairly common situation full sibling (FS), half sibling (HS), unrelated (U) three plausible relationships among genotyped individuals, e.g. nestlings sampled parents . Typically none half sibling pairs assigned sequoia(), tell whether maternal paternal half-siblings. generations overlap, possibility full avuncular grandparental also remains open genetically, even biologically highly unlikely clutch mates (species). situation, likelihoods FS, HS, U three relevant, good way pedigree reconstruction set prior relationships zero (including e.g. full cousins) abandon distinction maternal paternal relatives (implemented hermaphrodites).","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"likelihood-ratios","dir":"Articles","previous_headings":"Introduction","what":"Likelihood ratios","title":"Classification of pairs using likelihoods","text":"function CalcPairLL() lets get ‘back basics’ returns log10-likelihoods various different relationships specified pairs individuals. log10-likelihood values output directly compared pair: differ genotypes differ. likelihood ratios however comparable scale individuals, e.g. ratio likely full siblings versus half sibling, half sibling versus unrelated.","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"caution","dir":"Articles","previous_headings":"Introduction","what":"CAUTION","title":"Classification of pairs using likelihoods","text":"Comparisons pairs done caution: pair + B higher LLR(PO/U) pair + C, necessarily make B likely parent C. pairs may parent-offspring (e.g. C parent , parent B), B may actually full sibling (LLR(PO/U) > 0, LLR(PO/FS) < 0).","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"applicable-to-other-relationships","dir":"Articles","previous_headings":"Introduction","what":"Applicable to other relationships","title":"Classification of pairs using likelihoods","text":"example full siblings, half siblings unrelated used, one also situation parent full avuncular alternatives, combination. Just keep mind 3rd degree relationships piled together ‘HA’ category, Complx='full' kinds double relationships considered .","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"with-or-without-pedigree","dir":"Articles","previous_headings":"","what":"With or without pedigree","title":"Classification of pairs using likelihoods","text":"likelihood ratio full sibling vs unrelated (LR(FS/U)) two individuals can calculated ignorant pedigree, conditional . latter increases power individual already siblings, calculated LR B full (half) sibling ’s siblings, versus unrelated ’s sibling cluster. similar happens sibship clustering, except instead gradually building sibship clusters, sibling clusters provided initiation. caveat CalcPairLL() check whether provided pedigree correct even plausible pedigree. supposed siblings fact unrelated, LR B conditional incorrect pedigree becomes ambiguous virtually useless. therefore prudent check necessary trim pedigree conditioning (e.g. using CalcOHLLR(), removing inconsistencies genetic field pedigree). approach first illustrated without conditioning pedigree, conditional pedigree.","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example data","title":"Classification of pairs using likelihoods","text":"illustrate use single birth year cohort Ped_HSg5 example pedigree package. pedigree discrete generations, generation 24 females mates 2 males , 16 males 3 females ; mating produces exactly 4 offspring. founders born 2000, parents 2001 cohort considered thus simulated unrelated. example egg-laying species females two broods per year, 4 eggs/hatchlings per brood sampled genotyping. egg dumping occur [^], half-siblings within brood always maternal half-siblings, half-siblings across different broods laid time paternal half-siblings. egg dumping, puzzle becomes bit complicated necessarily impossible solve","code":"# looking at 2001 'hatchlings' only.  Ped.2001 <- Ped_HSg5[Ped_HSg5$id %in% LH_HSg5$ID[LH_HSg5$BirthYear <= 2001], ] # total 192 individuals, across 24 dams x 16 sires  # simulate genetic data: Geno.2001 <- SimGeno(Pedigree = Ped.2001,                       ParMis = 1.0,     # all parents non-genotyped                      nSnp = 400, SnpError = 0.005)"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"find-pairs-of-likely-relatives","dir":"Articles","previous_headings":"Example data","what":"Find pairs of likely relatives","title":"Classification of pairs using likelihoods","text":"reduce computational time (memory size output object), often good idea calculate likelihoods pairs somewhat likely related. moderately sized example 192 genotyped individuals, \\((192 \\times 191)/2= 18336\\) unique pairs. Even every individual belongs sibship, pairs individuals unrelated: thus, 33856 pairs unrelated (U), 92%. Subsetting pairs can done based field data (e.g. check within-nest, among neighbouring nests), based genetic data. latter, use GetMaybeRel(), optionally much liberal threshold normally use. output GetMaybeRel shows likely relationship (6 full sibling (TopRel = FS), much likely next--likely relationship (column LLR). show next--likely relationship , much likely pairs full siblings versus unrelated. pairs may equally likely full siblings half-siblings, resulting low LLR, show much likely sibling categories versus unrelated.","code":"# matrix with type of relationship between each pair of individuals in a pedigree: RelM <- GetRelM(Ped.2001)  # Note: GetRelM() adds entries for all parents, using PedPolish() # removing those again...: SampleIDs <- rownames(Geno.2001) RelM <- RelM[match(SampleIDs, rownames(RelM)), match(SampleIDs, rownames(RelM))]   # each pair is included twice in the matrix: above & below the diagonal table(RelM)/2 ## RelM ##    FS    HS     S     U  ##   320  1088    96 16928 # make mock lifehistory data for this example: # all individuals same birth year + specifying non-overlapping generations # ensures that parent-offspring, aunt/uncle, etc. are not considered as  # relationship alternatives.  LHX <- data.frame(id = rownames(Geno.2001),                   Sex = 3,                   BirthYear = 1)  AP <- MakeAgePrior(Discrete=TRUE, Plot=FALSE) ## Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1 MR <- GetMaybeRel(Geno.2001,                   LifeHistData = LHX,                   AgePrior = AP,                   Module = \"ped\",   # search for all kinds of relatives, not just parent-offspring                   Complex = \"simp\",  # don't consider double relationships etc                   Err = 0.005,                   Tassign = 0.1,                   Tfilter = -5,                   MaxPairs = 20 * nrow(Geno.2001)) ## Searching for non-assigned relative pairs ... (Module = ped) ## Genotype matrix looks OK! There are  192  individuals and  400  SNPs. ## Counting opposing homozygous loci between all individuals ... ## Checking for non-assigned relatives ... ## Found 0 likely parent-offspring pairs, and 883 other non-assigned pairs of possible relatives head(MR$MaybeRel) ##      ID1    ID2 TopRel   LLR OH BirthYear1 BirthYear2 AgeDif Sex1 Sex2 SNPdBoth ## 1 b01009 a01010     FS 15.13  7          1          1      0    3    3      394 ## 2 a01113 a01116     FS 14.73  7          1          1      0    3    3      394 ## 3 b01089 b01091     FS 14.64  7          1          1      0    3    3      393 ## 4 a01071 b01072     FS 14.33  4          1          1      0    3    3      392 ## 5 a01123 b01124     FS 13.62  7          1          1      0    3    3      397 ## 6 b01038 a01039     FS 13.60  7          1          1      0    3    3      392"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"calculate-likelihoods","dir":"Articles","previous_headings":"Example data","what":"Calculate likelihoods","title":"Classification of pairs using likelihoods","text":"upper-right panel (LLR(FS/U) vs LLR(HS/U)) shows large number pairs dataset clearly full siblings (diagonal), number likely half-siblings (blue dots), also substantial number seem kind second third degree relative unclear exactly related (yellow dots). difference likely half-siblings ‘unclear’ obvious plot, comes via likelihood ratio half-siblings versus third degree relative (see ). contrast, let’s also calculate likelihoods random set pairs:  random pairs, (usually) clear divide full siblings (diagonal), half-siblings (diagonal & LLR(HS/U)\\(>0\\)), unrelated (LLR(HS/U)\\(<0\\)).","code":"PairLL <- CalcPairLL(data.frame(MR$MaybeRel[, c(\"ID1\", \"ID2\")],                                 focal = \"U\"),  # see help file for details                      Geno.2001,                      LifeHistData = LHX,                      AgePrior = AP,                      Complex = \"simp\",                      Err = 0.005) Pairs.random <- data.frame(ID1 = sample(SampleIDs, size=500, replace=TRUE),                            ID2 = sample(SampleIDs, size=500, replace=TRUE),                            focal = \"U\") # exclude if by chance ID1 == ID2 Pairs.random <- Pairs.random[Pairs.random$ID1 != Pairs.random$ID2, ]    Pairs.random.LL <- CalcPairLL(Pairs.random,                       Geno.2001,                      LifeHistData = LHX,                      AgePrior = AP,                      Complex = \"simp\",                      Err = 0.005, Plot=FALSE)  # plot only one panel, change assignment threshold  PlotPairLL(Pairs.random.LL, combo = list(c(\"HS\", \"FS\")), Tassign=1.0)"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"likelihood-ratios-1","dir":"Articles","previous_headings":"Example data","what":"Likelihood ratios","title":"Classification of pairs using likelihoods","text":"Remember \\[ \\log(/ B) = \\log() - \\log(B) \\] CalcPairLL() returns log10-likelihood values. Log-likelihood values always negative, likelihoods always 0 1; positive values output various types NA (see help file).  scatterplots similar ones , left panel LLR(FS/HS) y-axis: pairs likely full sibling half sibling positive values, remaining pairs negative values; analogous LLR(HS/HA) right panel. panels show three distinct blobs: full sibling, half sibling, unrelated pairs. (usually) however also number points -blobs: pairs unclear related. pairs -full- half-sib blob, clear kind sibling, definitely unrelated; pedigree reconstruction sequoia() way convert information leaves pair unassigned. Comparing two panels also shows different likelihood ratios strongly correlated, convey slightly different information: separation full siblings half siblings clearer LLR(FS/HS) (left panel y-axis), separation half siblings -siblings clearer LLR(HS/HA) (right panel y-axis). distributions likelihood ratios can also visualised set histograms:  distribution LLR(FS/U) shows fairly clear separation full siblings (LLR(FS/U) > 10), half siblings (-15 < LLR(FS/U) < 10) unrelated (LLR(FS/U) < -15), strongly correlated LLR(FS/HS) (see scatterplot ). main advantage using LLR(FS/HS) classify full vs half siblings practical one: point separation blobs (one) always 0. LLR(HS/U), LLR(FS/U) similar metrics point separation vary datasets number SNPs, (assumed) genotyping error rate, allele frequencies, missingness, …, threshold need estimated every time. heatmap may also helpful identify pairs relatives likely full half siblings. several ways make heatmap R (none find quite satisfactory), example:","code":"PList <- list(maybesibs = PairLL,               random = Pairs.random.LL)  for (x in c(\"maybesibs\", \"random\")) {   PList[[x]]$LLR.FS.U <- with(PList[[x]], ifelse(FS < 0, FS - U, NA))   PList[[x]]$LLR.HS.U <- with(PList[[x]], ifelse(HS < 0, HS - U, NA))   PList[[x]]$LLR.FS.HS <- with(PList[[x]], ifelse(FS < 0 & HS < 0, FS - HS, NA))    PList[[x]]$LLR.HS.HA <- with(PList[[x]], ifelse(HS < 0 & HA < 0, HS - HA, NA))  } par(mfcol=c(1,2), mai=c(.8,.8,.2,.2))  with(PList[[\"random\"]], plot(LLR.FS.U, LLR.FS.HS, pch=16,                              xlim = c(-45, 40), ylim=c(-35, 20),                              col=adjustcolor(\"black\", alpha.f=0.5)))  # semi-transparant with(PList[[\"maybesibs\"]], points(LLR.FS.U, LLR.FS.HS, pch=16,                                    col=adjustcolor(\"blue\", alpha.f=0.5))) abline(h=0, v=0, col=2)  # horizontal & vertical axis  with(PList[[\"random\"]], plot(LLR.FS.U, LLR.HS.HA, pch=16,                               xlim=c(-45,40), ylim=c(-10,5),                               col=adjustcolor(\"black\", alpha.f=0.5))) with(PList[[\"maybesibs\"]], points(LLR.FS.U, LLR.HS.HA, pch=16,                                    col=adjustcolor(\"blue\", alpha.f=0.5))) abline(h=0, v=0, col=2)  # horizontal & vertical axis # to draw multiple histograms in the same plot: calculate first, plot later HistL_FSU <- list() for (x in c(\"maybesibs\", \"random\")) {   HistL_FSU[[x]] <- list()   for (y in c(\"LLR.HS.U\", \"LLR.FS.U\", \"LLR.FS.HS\")) {     HistL_FSU[[x]][[y]] <- hist(PList[[x]][, y],                                 breaks=seq(-60, 60, by=0.5),                                    plot=FALSE)     } }  # pick some colours COL <- c(maybesibs = adjustcolor(\"blue\",alpha.f=0.4),          random = adjustcolor(\"black\",alpha.f=0.4))  par(mfcol=c(1,3), mai=c(.9,.4,.4,.1)) for (y in c(\"LLR.HS.U\", \"LLR.FS.U\", \"LLR.FS.HS\")) {    plot(1,1, type=\"n\", main=\"\", xlab=y, ylab=\"Count\", las=1,        xlim = c(-25, 25), ylim=c(0,50))   abline(v=0, col=2)   for (x in c(\"maybesibs\", \"random\")) {     plot(HistL_FSU[[x]][[y]], col=COL[x], border=NA, add=TRUE)   } } # using the first 20 individuals for this example # make a dataframe with all pairwise combinations: Pairs20 <- data.frame(ID1 = rep(SampleIDs[1:20], each=20),                       ID2 = rep(SampleIDs[1:20], times=20)) Pairs20 <- Pairs20[Pairs20$ID1 != Pairs20$ID2, ]   Pairs20.LL <- CalcPairLL(Pairs20,                           Geno.2001,                          LifeHistData = LHX,                          AgePrior = AP,                          Complex = \"simp\",                          Err = 0.005, Plot=FALSE)  Pairs20.LL$FS.HS <- with(Pairs20.LL, ifelse(FS < 0 & HS < 0, FS - HS, NA)) # turn dataframe into a matrix FSHS.M <- plyr::daply(Pairs20.LL, c(\"ID1\", \"ID2\"), function(df) df$FS.HS[1]) # put the individuals back into their original order: FSHS.M <- FSHS.M[SampleIDs[1:20], SampleIDs[1:20]]  brks <- c(-30, seq(-15, 15, by=0.5), 30)  # group everything < -15 or >15 together cols <- grDevices::hcl.colors(n = length(brks)-1, palette = \"viridis\")  # image() is simple and flexible, but doesn't do a legend image_legend <- function(x, legend, breaks, col, title = NULL) {   image(y=x, z=t(as.matrix(x)),         axes=FALSE, frame.plot=TRUE, breaks = breaks, col = col)   axis(side=4, at=legend, las=1, cex.axis=0.8)   axis(side=4, at=legend, labels=FALSE, tck=0.2)   axis(side=2, at=legend, labels=FALSE, tck=0.2)   mtext(title, side=3, line=0.5, cex=1.2)   }  layout(matrix(c(1,2), nrow=1), widths=c(.8, .2)) par(mai=c(.8,.8,.5,.1))  image(x=t(FSHS.M), breaks=brks, col = cols,       axes = FALSE, frame.plot=TRUE,       xlab = \"\", ylab = \"\", cex.lab=1.2) axis(side=1, labels=rownames(FSHS.M), at=seq(0,1,along.with=rownames(FSHS.M)), las=2) axis(side=2, labels=colnames(FSHS.M), at=seq(0,1,along.with=colnames(FSHS.M)), las=2)  par(mai=c(1.5,.2,.5,1.2)) image_legend(x = seq(-20, 19.5, .5) +.25,  # range of values               legend = seq(-16, 16, 2),     # positions of legend labels              breaks = brks, col = cols, title = \"LLR(FS/U)\")"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"buffer-zone","dir":"Articles","previous_headings":"Example data","what":"Buffer zone","title":"Classification of pairs using likelihoods","text":"expectation LLR(FS/HS) positive full sibling pairs negative pairs, mean imperfect real-world data pairs comply expectation. solution sequoia() implements make assignment likelihood ratio ‘close’ zero, ‘close’ defined threshold Tassign. may ideal situations, apply different tactic classifying individuals based CalcPairLL() output (see next section). example, sure based data pairs either full siblings maternal half-siblings never paternal half-siblings (e.g. litter mates), assign maternal sibship leave paternity open (perhaps note). interested extra-pair paternity, conservative assign full siblings rest brood (see also next section, section conditioning pedigree).","code":"Tassign <- 1.0  plot(HistL_FSU[[\"maybesibs\"]][[\"LLR.FS.HS\"]], col=\"darkblue\", border=NA,      xlim = c(-15, 15), ylim = c(0, 30), main=paste(\"Tassign =\", Tassign),       xlab=\"LLR(FS/HS)\") abline(v=0, lwd=2, col=2) rect(xleft=-Tassign, xright=+Tassign, ybottom=-5, ytop=40,       col=adjustcolor(\"red\", alpha.f=0.5), border=NA)"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"classify","dir":"Articles","previous_headings":"Example data","what":"Classify","title":"Classification of pairs using likelihoods","text":"Classifying pairs individuals given assignment threshold Tassign straightforward: Classifying sibling clusters less straightforward, pairwise classifications necessarily consistent. example, figure individuals B highly likely full siblings, C (\\(T_{assign}=0.5\\)), B C likely half-siblings. Example LLR(FS/HS) putative full sibling trio problem arises likelihoods three pairs calculated independently . pedigree reconstruction, problem resolved first assigning B full siblings (unambiguous), calculating likelihoods C full sibling vs half sibling B: Conditional B full siblings, C full sibling one valid pedigree configuration.","code":"Tassign <- 0.5 for (x in c(\"maybesibs\", \"random\")) {   PList[[x]]$class <- with(PList[[x]],                            ifelse(LLR.FS.HS > Tassign, \"FS\",                                   ifelse(LLR.HS.U > Tassign, \"HS\",                                          \"U\"))) }  lapply(PList, function(df) table(df$class)) ## $maybesibs ##  ##  FS  HS  ## 320 563  ##  ## $random ##  ##  FS  HS   U  ##   8  29 462"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"sec:withPedigree","dir":"Articles","previous_headings":"","what":"Conditioning on a pedigree","title":"Classification of pairs using likelihoods","text":"datasets like example, mixture full- half-siblings genotyped parents, usually clustering full siblings performed OK via sequoia(), none half-siblings assigned tell whether maternal paternal half-siblings. , first run sibship clustering. condition pedigree subsequent steps, extra cautious increase assignment threshold:","code":"SeqOUT <- sequoia(Geno.2001, LifeHistData = LHX,                   Err = 0.005, Tassign = 1.0,                     Complex = \"simp\", Module=\"ped\",                    Plot=FALSE, quiet=TRUE)"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"relationship-between-individual-cluster","dir":"Articles","previous_headings":"Conditioning on a pedigree","what":"Relationship between individual & cluster","title":"Classification of pairs using likelihoods","text":"provide pedigree CalcPairLL(), calculations conditional pedigree. means matter calculate likelihoods –C B–C trio example; calculate likelihoods relationships C –B sibling duo. illustrate: reiterate: maternal sibship divided two sets full siblings sequoia() way telling whether share mother father. distinction can made parents known sex genotyped sibships interconnect: e.g. male ‘b00008’ also mated another female, turn also mated genotyped male (see also section low assignment rate main vignette). Let’s calculate likelihoods four members first brood first member second brood. meaningful answer, temporarily drop parents second individual (dropPar2 = ''): two individuals two different sets parents, siblings conditional parents. Now calculate likelihood ‘a01185’ full sibling half sibling first brood; chosen dropPar1='' calculate likelihood member first brood FS, HS, .. second brood. pair, likelihoods half-siblings (HS), grand-parental (GP) full avuncular (FA) identical – another common cause non-assignment Note values >0 output denote different kinds NA, listed help file. ‘PO’ column, ‘777’ denotes ‘impossible’: individuals first column already mother assigned pedigree conditioned upon, parent temporarily dropped calculations (dropPar = 'none'), individual can one mother. (pair also born year can therefore parent offspring, information used: AgeDif=NA.)","code":"# true pedigree, 2 broods from 1 female: Ped.2001[which(Ped.2001$dam == \"a00014\"), ] ##         id    dam   sire ## 41  a01001 a00014 b00011 ## 42  a01002 a00014 b00011 ## 43  b01003 a00014 b00011 ## 44  b01004 a00014 b00011 ## 225 a01185 a00014 b00008 ## 226 a01186 a00014 b00008 ## 227 b01187 a00014 b00008 ## 228 b01188 a00014 b00008 Offspr_a14 <- Ped.2001[which(Ped.2001$dam == \"a00014\"), \"id\"] # inferred pedigree: SeqOUT$Pedigree[SeqOUT$Pedigree$id %in% Offspr_a14, ] ##         id   dam  sire LLRdam LLRsire LLRpair OHdam OHsire MEpair ## 1   a01001 F0025 M0025   9.72    9.72   16.11    NA     NA     NA ## 2   a01002 F0025 M0025  10.38   10.38   18.18    NA     NA     NA ## 3   b01003 F0025 M0025   8.46    8.46   13.03    NA     NA     NA ## 4   b01004 F0025 M0025   8.29    8.29   13.99    NA     NA     NA ## 185 a01185 F0027 M0027  11.85   11.85   22.93    NA     NA     NA ## 186 a01186 F0027 M0027  10.75   10.75   15.00    NA     NA     NA ## 187 b01187 F0027 M0027  10.52   10.52   18.73    NA     NA     NA ## 188 b01188 F0027 M0027  10.57   10.57   19.48    NA     NA     NA somePairs <- data.frame(ID1 = Offspr_a14[1:4],                         ID2 = \"a01185\",                         focal = \"HS\",                         dropPar2 = \"both\")  # drop parents of ID2  somePairs.LL <- CalcPairLL(somePairs, Geno.2001,                            Pedigree = SeqOUT$Pedigree,                            Complex=\"simp\",                            Err = 0.005, Plot=FALSE) somePairs.LL ##      ID1    ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2  PO      FS ## 1 a01001 a01185    3    3     NA    HS      1     none     both 777 -325.10 ## 2 a01002 a01185    3    3     NA    HS      1     none     both 777 -319.70 ## 3 b01003 a01185    3    3     NA    HS      1     none     both 777 -322.90 ## 4 b01004 a01185    3    3     NA    HS      1     none     both 777 -327.48 ##        HS      GP      FA      HA       U TopRel  LLR ## 1 -294.02 -294.02 -294.02 -297.88 -304.80    2nd 3.86 ## 2 -288.62 -288.62 -288.62 -292.47 -299.40    2nd 3.86 ## 3 -291.81 -291.81 -291.81 -295.67 -302.60    2nd 3.86 ## 4 -296.40 -296.40 -296.40 -300.26 -307.18    2nd 3.86"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"likelihood-ratios-2","dir":"Articles","previous_headings":"Conditioning on a pedigree","what":"Likelihood ratios","title":"Classification of pairs using likelihoods","text":"likelihoods differ pairs (different genotypes), likelihood ratios (except due rounding): Compare ratios conditioning pedigree:","code":"somePairs.LL$LLR.FS.HS <- with(somePairs.LL, ifelse(FS < 0 & HS < 0, FS - HS, NA)) somePairs.LL$LLR.HS.U <- with(somePairs.LL, ifelse(HS < 0, HS - U, NA)) somePairs.LL$LLR.HS.HA <- with(somePairs.LL, ifelse(HS < 0 & HA < 0, HS - HA, NA))  somePairs.LL[, c(\"ID1\", \"ID2\", \"FS\", \"HS\", \"HA\", \"U\", \"LLR.FS.HS\", \"LLR.HS.U\", \"LLR.HS.HA\")] ##      ID1    ID2      FS      HS      HA       U LLR.FS.HS LLR.HS.U LLR.HS.HA ## 1 a01001 a01185 -325.10 -294.02 -297.88 -304.80    -31.08    10.78      3.86 ## 2 a01002 a01185 -319.70 -288.62 -292.47 -299.40    -31.08    10.78      3.85 ## 3 b01003 a01185 -322.90 -291.81 -295.67 -302.60    -31.09    10.79      3.86 ## 4 b01004 a01185 -327.48 -296.40 -300.26 -307.18    -31.08    10.78      3.86 somePairs.LL.noped <- CalcPairLL(somePairs, Geno.2001,                            Complex=\"simp\",                            Err = 0.005, Plot=FALSE)  somePairs.LL.noped$LLR.FS.HS <- with(somePairs.LL.noped, ifelse(FS < 0 & HS < 0, FS - HS, NA)) somePairs.LL.noped$LLR.HS.U <- with(somePairs.LL.noped, ifelse(HS < 0, HS - U, NA)) somePairs.LL.noped$LLR.HS.HA <- with(somePairs.LL.noped, ifelse(HS < 0 & HA < 0, HS - HA, NA))  somePairs.LL.noped[, c(\"ID1\", \"ID2\", \"FS\", \"HS\", \"HA\", \"U\", \"LLR.FS.HS\", \"LLR.HS.U\", \"LLR.HS.HA\")] ##      ID1    ID2      FS      HS      HA       U LLR.FS.HS LLR.HS.U LLR.HS.HA ## 1 a01001 a01185 -342.21 -336.25 -336.24 -343.75     -5.96     7.50     -0.01 ## 2 a01002 a01185 -346.51 -336.58 -336.58 -341.57     -9.93     4.99      0.00 ## 3 b01003 a01185 -341.18 -331.91 -331.83 -335.90     -9.27     3.99     -0.08 ## 4 b01004 a01185 -345.27 -335.65 -335.65 -341.39     -9.62     5.74      0.00"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"half-sibling-clusters","dir":"Articles","previous_headings":"Conditioning on a pedigree","what":"Half-sibling clusters","title":"Classification of pairs using likelihoods","text":"pair maternal half-siblings B, third individual C must identically related , ‘side family’: C maternal grandmother , unavoidably also maternal grandmother B. C paternal grandmother , unrelated B. distinction can made via patmat column.","code":""},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"random-pairs-revisited","dir":"Articles","previous_headings":"Conditioning on a pedigree","what":"random pairs revisited","title":"Classification of pairs using likelihoods","text":"Calculating likelihoods subset pairs , now conditional inferred (partial) pedigree: Log10 likelihood ratios full sibling vs half sibling, calculated without pedigree (left) conditional partial inferred pedigree (right). Note difference scale x-axes.","code":"Pairs.random.LL.wPed <- CalcPairLL(Pairs = cbind(Pairs.random,                                             dropPar2 = \"both\"),                               Geno.2001,                               Pedigree = SeqOUT$Pedigree,                               LifeHistData = LHX,                               AgePrior = AP,                               Complex = \"simp\",                               Err = 0.005, Plot=FALSE) Pairs.random.LL$LLR.FS.HS <- with(Pairs.random.LL,                                    ifelse(FS < 0 & HS < 0, FS - HS, NA)) Pairs.random.LL.wPed$LLR.FS.HS <- with(Pairs.random.LL.wPed,                                          ifelse(FS < 0 & HS < 0, FS - HS, NA))  par(mfcol=c(1,2), mai=c(.8,.8,.2,.2)) hist(Pairs.random.LL$LLR.FS.HS, breaks=50, main=\"No pedigree\") hist(Pairs.random.LL.wPed$LLR.FS.HS, breaks=50, main=\"With pedigree\")"},{"path":"https://jiscah.github.io/articles/pairLL_classification.html","id":"pros-cons","dir":"Articles","previous_headings":"Conditioning on a pedigree","what":"Pros & cons","title":"Classification of pairs using likelihoods","text":"main advantage calculating likelihoods conditional pedigree distinction different relationships tends become much clearer condition least one parent either individual. main disadvantage pedigree condition incorrect, meaningful way interpret likelihoods. Another disadvantage can computation considerably slower (order magnitudes), making important filter pairs first using GetMaybeRel().","code":""},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"why-compare-pedigrees","dir":"Articles","previous_headings":"","what":"Why compare pedigrees","title":"PedCompare Example (Griffin Pedigree)","text":"often worthwhile compare newly inferred genetic pedigree older (field-)pedigree, dataset flawless, genetic pedigree reconstruction infallible. Discrepancies pedigrees may bring light mislabeled samples, incorrect birth death years, incorrectly inferred pedigree links. example, individual’s genetically inferred mother differs field-observed mother, may due mislabeled DNA sample, pedigree inference error, error field records, egg dumping/adoption. Eliminating possibilities tracking likely scenario can rather time consuming, increase overall quality dataset pedigree. addition, pedigree comparison may able match dummy parents genetic pedigree real, non-genotyped parents field pedigree. allows pedigree records (offspring number, mates, etc.) combined phenotypic records (age, size, etc.) non-genotyped individuals. , process illustrated comparing genetically assigned field observed mothers fictional population griffins.","code":""},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"study-population","dir":"Articles","previous_headings":"","what":"Study population","title":"PedCompare Example (Griffin Pedigree)","text":"Nests monitored small, closed population griffins, year exactly 20 baby griffins hatch. mother individuals known field observations (example data FieldMums_griffin included package). 2001 2010, hatchlings tagged, sampled SNP genotyping. , genetic pedigree reconstructed (example data SeqOUT_griffin). Breeding females without tags, given two-colour code 1. may including females lost tags.","code":""},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"comparing-pedigrees","dir":"Articles","previous_headings":"","what":"Comparing pedigrees","title":"PedCompare Example (Griffin Pedigree)","text":"essence, PedCompare() lies two pedigrees side--side classifies individual’s parent two pedigrees (Match) (Mismatch), parent one pedigrees (P1only P2only). Match versus Mismatch straightforward individuals genotyped, IDs (thus) consistent two pedigrees, becomes complicated non-genotyped individuals dummy IDs involved. PedCompare() tries match sibship-dummy-parent Pedigree2 (F0001, F0002, etc.) non-genotyped parent Pedigree1 (IDs consisting 2 colours: PinkBlue, BlueRed, etc.).","code":"library(sequoia) data(SeqOUT_griffin, FieldMums_griffin, package=\"sequoia\")  PCG  <- PedCompare(Ped1 = cbind(FieldMums_griffin,                                 sire = NA),                    Ped2 = SeqOUT_griffin$Pedigree,                    SNPd = SeqOUT_griffin$PedigreePar$id,                    Symmetrical = TRUE, Plot=FALSE)"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mergedped","dir":"Articles","previous_headings":"Comparing pedigrees","what":"$MergedPed","title":"PedCompare Example (Griffin Pedigree)","text":"side--side pedigrees given list element $MergedPed output: part-pedigree example shows individuals i165_2009_F i166_2009_F non-genotyped female ‘PinkBlue’ field observed mother (dam.1 = dam Pedigree1). pair also genetically assigned maternal siblings, ‘F0006’ dummy ID mother (dam.2). , ID mother differs two pedigrees, nonetheless considered Match (dam.class, short classification).","code":"PCG$MergedPed[c(127:133), c(\"id\", \"dam.1\", \"dam.2\", \"dam.class\")] ##              id       dam.1       dam.2 dam.class ## 127 i161_2009_M        <NA>        <NA>         _ ## 128 i165_2009_F    PinkBlue       F0006     Match ## 129 i166_2009_F    PinkBlue       F0006     Match ## 130 i169_2009_M i133_2007_F i133_2007_F     Match ## 131 i170_2009_F     BlueRed       F0003     Match ## 132 i171_2009_M        <NA>       F0016    P2only ## 133 i173_2009_F     BlueRed       F0003     Match"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"id-columns","dir":"Articles","previous_headings":"Comparing pedigrees > $MergedPed","what":"id columns","title":"PedCompare Example (Griffin Pedigree)","text":"point clarification id columns: column id ids common pedigrees, plus occurring Pedigree2 (typically dummy IDs F0001, F0002 etc.) column id.r ‘consensus’ ids, plus occurring Pedigree1 example, ‘PinkBlue’ mother Pedigree1 (first row MergedPed : id.r=PinkBlue, dam.1=NA). Pedigree2 tells us ‘F0006’ genetic mother ‘F0007’, hugely informative (MergedPed: id=F0006, dam.2=F0007). PedCompare() tells us means ‘PinkBlue’ (id.r) ‘YellowPink’ mother (dam.r), lot meaning (someone working field). Subsets Pedigree1 (left) Pedigree2 (right)","code":"# subset some individuals: these <- c(\"i177_2009_M\", \"i179_2009_M\", \"i165_2009_F\", \"i166_2009_F\", \"F0006\",            \"F0007\", \"YellowPink\", \"PinkBlue\") knitr::kable(list(Ped1 = FieldMums_griffin[FieldMums_griffin$id %in% these, ],                    Ped2 = SeqOUT_griffin$Pedigree[SeqOUT_griffin$Pedigree$id %in% these, 1:3]),              caption = \"Subsets of Pedigree1 (left) and Pedigree2 (right)\") PCG$MergedPed[PCG$MergedPed$id %in% these,                c(\"id\", \"id.r\", \"dam.1\", \"dam.2\", \"dam.r\")] ##              id        id.r      dam.1 dam.2      dam.r ## 6         F0006    PinkBlue       <NA> F0007 YellowPink ## 7         F0007  YellowPink       <NA>  <NA>       <NA> ## 128 i165_2009_F i165_2009_F   PinkBlue F0006   PinkBlue ## 129 i166_2009_F i166_2009_F   PinkBlue F0006   PinkBlue ## 137 i177_2009_M i177_2009_M YellowPink F0007 YellowPink ## 138 i179_2009_M i179_2009_M YellowPink F0007 YellowPink"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"dummymatch","dir":"Articles","previous_headings":"Comparing pedigrees","what":"$DummyMatch","title":"PedCompare Example (Griffin Pedigree)","text":"output list element $DummyMatch summarises matches: match ‘F0006’ Pedigree2 ‘PinkBlue’ Pedigree1 (bottom row), 3 matching offspring, offspring ‘PinkBlue’ genetically assigned different sibship cluster mother (.Mismatch) genetic mother assigned (.P1only), members genetic sibship F0006 mother Pedigree1 (.P2only). Thus, perfect one--one match. genetic sibship ‘F0003’, however, situation complicated, worked detail . ‘nomatch’ id.1 column indicates either none individuals genetic sibship field-observed mother, field-observed mother matched different genetic sibship, larger overlap.","code":"head(PCG$DummyMatch[, -c(3:5)], n=6) ##    id.2        id.1 off.Match off.Mismatch off.P1only off.P2only ## 1 F0001 GreenYellow         3            2          0          0 ## 2 F0002     nomatch         0            2          0          0 ## 3 F0003     BlueRed         4            4          0          3 ## 4 F0004   RedOrange         3            0          0          0 ## 5 F0005     nomatch         0            0          0          2 ## 6 F0006    PinkBlue         3            0          0          0"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"counts","dir":"Articles","previous_headings":"Comparing pedigrees","what":"$Counts","title":"PedCompare Example (Griffin Pedigree)","text":"total number matches mismatches summarised 3D array $Counts, can visualised PlotPedComp():  Since sires field pedigree, look dam slice : counts classification subdivided various categories (rows), based whether focal individual (first letter) parent (second letter) Genotyped Dummy individual, well Totals. totals counts includes individuals Pedigree1 neither genotyped ‘dummifiable’, non-genotyped parent single offspring, therefore exceeds sum G D. go three classes discrepancies turn – Mismatch, P1only (field mum), P2only (genetic mum).","code":"PlotPedComp(PCG$Counts) PCG$Counts[,,\"dam\"] ##     class ## cat  Total Match Mismatch P1only P2only ##   GG    65    61        4      0      0 ##   GD    41    16        7      0     18 ##   GT   107    77       11      1     18 ##   DG    14     0        0      0     14 ##   DD     5     0        0      0      5 ##   DT    19     0        0      0     19 ##   TT   127    77       11      2     37"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mismatch","dir":"Articles","previous_headings":"","what":"Mismatch","title":"PedCompare Example (Griffin Pedigree)","text":"get detail 11 mismatches, head back $MergedPed. brevity, display columns ’re currently interested: Thus 11 individuals mismatching mothers, 4 unique mothers involved, look turn.","code":"PCG$MergedPed[which(PCG$MergedPed$dam.class == \"Mismatch\"), c(\"id\", \"dam.1\", \"dam.2\", \"id.dam.cat\")] ##              id       dam.1       dam.2 id.dam.cat ## 88  i108_2006_F   GreenBlue i081_2005_F         GG ## 99  i122_2007_M   GreenBlue i081_2005_F         GG ## 100 i123_2007_F OrangeGreen       F0003         GD ## 101 i124_2007_M   GreenBlue i081_2005_F         GG ## 105 i130_2007_F OrangeGreen       F0003         GD ## 106 i131_2007_F OrangeGreen       F0003         GD ## 108 i133_2007_F OrangeGreen       F0003         GD ## 113 i142_2008_M   GreenBlue i081_2005_F         GG ## 117 i147_2008_F  YellowBlue       F0001         GD ## 118 i148_2008_F GreenYellow       F0002         GD ## 125 i159_2008_F  YellowBlue       F0002         GD"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mismatch-issue1-greenblue","dir":"Articles","previous_headings":"Mismatch","what":"Mismatch Issue1: GreenBlue","title":"PedCompare Example (Griffin Pedigree)","text":"seems ‘GreenBlue’ perfect match ‘i081_2005_F’: four GreenBlue’s observed offspring genetically assigned i081_2005_F mother, four i081_2005_F’s genetic offspring GreenBlue observed mother. Perhaps female lost tag, therefore recognised, received new field ID. Field records may able back theory , disprove : GreenBlue look 1 year old first recorded 2007? i081_2005_F ever seen 2006 breeding season? i081_2005_F known death date? , post-mortem, presumed dead seen several months/years? alternative explanation might pedigree inference error, highly unlikely offspring parent genotyped (id.dam.cat = 'GG'), plausible limited number SNPs low call rate high genotyping error rate. four assignments independent done parentage assignment, necessarily full pedigree reconstruction: may first clustered maternal siblings, subsequently dummy mother may replaced i081_2005_F. Dummy individuals Pedigree2 never matched genotyped individuals Pedigree1, even perfect match – almost always something odd going requires user inspection. Resolution: Merge IDs ‘i081_2005_F’ ‘GreenBlue’","code":"PedM <- PCG$MergedPed[, c(\"id\", \"dam.1\", \"dam.2\")]   # short-hand to minimise typing  # does the mismatch affect all of GreenBlue's offspring? PedM[which(PedM$dam.1 == \"GreenBlue\"), ] ##              id     dam.1       dam.2 ## 88  i108_2006_F GreenBlue i081_2005_F ## 99  i122_2007_M GreenBlue i081_2005_F ## 101 i124_2007_M GreenBlue i081_2005_F ## 113 i142_2008_M GreenBlue i081_2005_F # > yes, these 4 are all of her known offspring  # does genetic mother i081_2005_F have any field-observed offspring? PedM[which(PedM$dam.1 == \"i081_2005_F\"), ] ## [1] id    dam.1 dam.2 ## <0 rows> (or 0-length row.names) # no.  # does i081_2005_F have any other genetic offspring? PedM[which(PedM$dam.2 == \"i081_2005_F\"), ] ##              id     dam.1       dam.2 ## 88  i108_2006_F GreenBlue i081_2005_F ## 99  i122_2007_M GreenBlue i081_2005_F ## 101 i124_2007_M GreenBlue i081_2005_F ## 113 i142_2008_M GreenBlue i081_2005_F # no."},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mismatch-issue2-orangegreen","dir":"Articles","previous_headings":"Mismatch","what":"Mismatch Issue2: OrangeGreen","title":"PedCompare Example (Griffin Pedigree)","text":", genetic sibship ‘F0003’ dummy mother includes individuals two different field-observed mothers, ‘OrangeGreen’ ‘BlueRed’. OrangeGreen’s offspring hatched 2007, BlueRed’s 2008 2009. Perhaps female regularly monitored, recognised start 2008 breeding season, got new ID? previous case, field records disprove theory census records BlueRed 2007, OrangeGreen 2008 (seen together!). Records backing theory notes like ‘…’ ‘looks similar …’ BlueRed first described. cautionary approach use new ID advisable, often much easier combine records two IDs later , try tease apart records single ID respective IDs. alternative explanation pedigree inference error, namely sequoia erroneously merged two actual sibships. may sporadically happen two mothers closely related. mothers related \\(>0.5\\) (closer regular full siblings, due inbreeding), erroneous merging can happen even large powerful SNP sets. Resolution: Probably merge IDs OrangeGreen’ ‘BlueRed’","code":"# why is this flagged as a mismatch? PedM[which(PedM$dam.1 == \"OrangeGreen\"), ] ##              id       dam.1 dam.2 ## 100 i123_2007_F OrangeGreen F0003 ## 105 i130_2007_F OrangeGreen F0003 ## 106 i131_2007_F OrangeGreen F0003 ## 108 i133_2007_F OrangeGreen F0003 # all of OrangeGreen's offspring are in sibship F0003  PedM[which(PedM$dam.2 == \"F0003\"), c(\"id\", \"dam.1\", \"dam.2\")] ##              id       dam.1 dam.2 ## 2         F0002        <NA> F0003 ## 16        F0016        <NA> F0003 ## 100 i123_2007_F OrangeGreen F0003 ## 105 i130_2007_F OrangeGreen F0003 ## 106 i131_2007_F OrangeGreen F0003 ## 108 i133_2007_F OrangeGreen F0003 ## 124 i158_2008_M     BlueRed F0003 ## 126 i160_2008_F     BlueRed F0003 ## 131 i170_2009_F     BlueRed F0003 ## 133 i173_2009_F     BlueRed F0003 ## 169       M0011        <NA> F0003 # but sibship F0003 is split across two field mothers"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mismatch-issue3-yellowblue","dir":"Articles","previous_headings":"Mismatch","what":"Mismatch Issue3: YellowBlue","title":"PedCompare Example (Griffin Pedigree)","text":": i147_2008_F field mum YellowBlue, three genetic sibs suggest GreenYellow mum i148_2008_F field mum GreenYellow, genetic sib (i159_2008_F) suggest YellowBlue mum likely explanation samples individuals accidentally swapped around lab DNA extraction, .e. genotype ‘i147_2008_F’ belongs field id ‘i148_2008_F’, v.v.. Lab notes might shed light theory, e.g. DNA extracted batch? samples adjacent 96-well plate? alternative explanation sloppy handwriting typing error. Whether case genotype ‘i147_2008_F’ belongs field id ‘i147_2008_FM’ ‘i148_2008_F’ depends mixup happened, .e. whether field data swapped individuals . pedigree inference error seems unlikely particular case – individuals may occasionally get assigned wrong sibship, due genotyping errors, low call rate sample, uncommon draw Mendelian inheritance lottery, seems highly unlikely result two individuals swapping place. Resolution: Swap IDs ‘i147_2008_F’ ‘i148_2008_F’ genetic data (/field data)","code":"# as before PedM[which(PedM$dam.1 == \"YellowBlue\"), ] ##              id      dam.1 dam.2 ## 117 i147_2008_F YellowBlue F0001 ## 125 i159_2008_F YellowBlue F0002 # something odd going on involving sibships F0001 & F0002  PedM[which(PedM$dam.2 %in% c(\"F0001\", \"F0002\")), ] ##              id       dam.1 dam.2 ## 98  i121_2007_M GreenYellow F0001 ## 109 i135_2007_F GreenYellow F0001 ## 115 i144_2008_M GreenYellow F0001 ## 117 i147_2008_F  YellowBlue F0001 ## 118 i148_2008_F GreenYellow F0002 ## 125 i159_2008_F  YellowBlue F0002"},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"mismatch-issue4-greenyellow","dir":"Articles","previous_headings":"Mismatch","what":"Mismatch Issue4: GreenYellow","title":"PedCompare Example (Griffin Pedigree)","text":"turned Issue3!","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"general","dir":"Articles","previous_headings":"Pedigree1-only","what":"General","title":"PedCompare Example (Griffin Pedigree)","text":"second class discrepancies individuals parent assigned Pedigree1 (field-observation-based pedigree), Pedigree2 (genetically inferred pedigree), .e. genetic confirmation field parent. important distinguish : Parent /siblings Pedigree1 definitely closely genetically related focal individual lacking birth year information (parent offspring?), ambiguity kind second degree relative sibling Pedigree 1 , likelihood ratio falling short assignment threshold. Parent siblings genotyped, low call rate automatically excluded; .e. evidence one way another. range tools available help distinguish three alternatives: CalcOHLLR(): Calculate Mendelian errors parental LLR parents assigned Pedigree1; genetic incompatibilities stand outliers (SNP panel powerful enough) getAssignCat(): get (anti-conservative) indication non-genotyped individuals Pedigree1 get dummy ID stand-ins genetic pedigree reconstruction; non-‘dummyfiable’ parents suggest third alternative reason worry GetMaybeRel(): find pairs individuals likely relatives, assigned (2nd alternative) CalcPairLL(): batch pairs, get likelihoods PO, FS, HS, …; .e. get data underlying parental LLR LLR GetMaybeRel() output. Genomic relatedness: especially many SNPs scored used pedigree reconstruction, genomic relatedness can provide additional clue whether two individuals closely related.","code":""},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"griffins","dir":"Articles","previous_headings":"Pedigree1-only","what":"Griffins","title":"PedCompare Example (Griffin Pedigree)","text":"id.dam.cat = 'XX' indicates neither focal individual dam Pedigree1 genotyped ‘dummifiable’ (minimum one genotyped offspring, see ?getAssignCat). Thus case simply way genetically testing whether two indeed maternal siblings, field data indicates. Genetic data become available future, due DNA sampling i053_2003_M’s offspring, (e.g. post-mortem). one reasons recommended rerun pedigree analysis individuals additional individuals genotyped.","code":"PCG$MergedPed[which(PCG$MergedPed$dam.class == \"P1only\"),                c(\"id\", \"id.r\", \"dam.1\", \"dam.2\", \"id.dam.cat\")] ##              id        id.r    dam.1 dam.2 id.dam.cat ## 53  i057_2003_M i057_2003_M GreenRed  <NA>         GX ## 174        <NA> i053_2003_M GreenRed  <NA>         XX"},{"path":[]},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"general-1","dir":"Articles","previous_headings":"Pedigree2-only (newly assigned mum)","what":"General","title":"PedCompare Example (Griffin Pedigree)","text":"Analogous Pedigree1-classification, useful differentiate assigned parent died birth year putative offspring putative offspring’s parents known great certainty spatial locations assigned parent-pair far apart around time conception mated SNP genotyped different ID, different sex, definite death date breeding age birth year incompatible dummy individual’s offspring assigned mother seen breeding season new offspring born (e.g. bred outside study area) offspring newly assigned mother part social group field data suggest one way field data indicate newly assigned parent highly implausible, various possible explanations, : Sample mislabeling (offspring parent sample) Parent-offspring pair assigned wrong way around (.e. actual offspring assigned parent), due missing/incorrect birth years, low-confidence dummy–dummy pedigree link presumed-dead individual emigrated re-immigrated, mistaken identity post-mortem (.e. incorrect death date).","code":""},{"path":"https://jiscah.github.io/articles/pedcompare_example.html","id":"griffins-1","dir":"Articles","previous_headings":"Pedigree2-only (newly assigned mum)","what":"Griffins","title":"PedCompare Example (Griffin Pedigree)","text":"example, let’s take assignment ‘YellowPink’ (aka F0007) mother ‘PinkBlue’ (aka F0006): Dummy - dummy pedigree links higher error rate genotyped - genotyped pedigree links, especially sibships small, genetic information ‘second hand’. therefore worth checking independent data available. question whether plausible YellowPink non-genotyped daughter 2008 survived breeding age. one genotyped offspring 2008 (‘i141_2008_M’), nest monitored year. Field lab records indicate whether additional hatchlings sampled, successfully genotyped (+ tag loss PinkBlue). YellowPink one female, non-genotyped, potentially-surviving offspring year, hatchling’s data can combined PinkBlue’s breeding records. definitely offspring unaccounted , pedigree likely incorrect parent-offspring link best removed.","code":"SeqOUT_griffin$DummyIDs[c(6,7), c(\"id\", \"dam\", \"BY.est\", \"NumOff\", \"O1\", \"O2\", \"O3\", \"O4\")] ##        id   dam BY.est NumOff          O1          O2          O3    O4 ## 148 F0006 F0007   2008      3 i165_2009_F i166_2009_F i175_2009_M  <NA> ## 149 F0007  <NA>   2007      4 i141_2008_M i177_2009_M i179_2009_M F0006"},{"path":"https://jiscah.github.io/articles/pedigree_consultancy.html","id":"pedigree-reconstruction","dir":"Articles","previous_headings":"","what":"Pedigree reconstruction","title":"Sequoia Pedigree Consultancy","text":"example, time manpower perform pedigree reconstruction (get familiar yet another piece software), may able assist . : transform genetic data format sequoia uses, basic quality control, subset SNPs needed; run pedigree reconstruction + find non-assigned likely relatives, testing different parameter combinations; compare reconstructed pedigree existing pedigree may ; create report summary statistics (tables + plots) pedigree. send annotated R code, can reproduce findings, needed re-run pedigree reconstruction additional individuals different parameter values. time required depends data: nearly individuals genotyped high accuracy many SNPs, known birth year, little inbreeding, existing pedigree compare , can done within 1-2 days. number individuals minor effect , whether dozen tens thousands individuals. However, real world datasets come challenges, requiring time get information available data.","code":""},{"path":"https://jiscah.github.io/articles/pedigree_consultancy.html","id":"general-genetics-work","dir":"Articles","previous_headings":"","what":"General genetics work","title":"Sequoia Pedigree Consultancy","text":"also open jobs broadly related pedigree reconstruction analysis genetic data, example: Setting data cleaning / data analysis pipeline bash /R Estimate minimum proportion individuals genotyped test specific hypothesis Determine minimum number SNPs required reconstruct pedigree 99% accuracy, exploring different plausible pedigrees / mating systems, sampling rates genotyping errors Write R functions extract data summary statistics sequoia output format require","code":""},{"path":"https://jiscah.github.io/articles/pedigree_consultancy.html","id":"other-work","dir":"Articles","previous_headings":"","what":"Other work","title":"Sequoia Pedigree Consultancy","text":"Besides work pedigrees genetic data, can also help among others: Developping R functions packages (base R) Translation R code Fortran, v.v. Translation SPSS syntax R … Please look CV overview skills, feel free contact unsure whether good fit job.","code":""},{"path":"https://jiscah.github.io/articles/pedigree_consultancy.html","id":"about-me","dir":"Articles","previous_headings":"","what":"About me","title":"Sequoia Pedigree Consultancy","text":"MSc Animal Science, specialisation Animal Breeding & Genetics, Wageningen University Netherlands, PhD Biology NTNU Norway. thus familiar breeding systems common livestock species, challenges collecting data wild populations. postdoc Rum Red deer project (https://rumdeer.bio.ed.ac.uk/ ) Edinburgh University, became fascinated intricacies parentage assignment pedigree reconstruction based genetic data. continue assist perform yearly update pedigree new cohort calves, well sister project Soay sheep ( https://soaysheep.bio.ed.ac.uk/ ). last years done freelance work various companies research institutes, addition ‘pro bono’ assistance many dozens sequoia users. Especially latter spans wide variety species, including mammals, reptiles, molluscs, plants. Since May 1st 2023 Sequoia Pedigree Consultancy registered Dutch Chamber Commerce: KVK: 90010132 BTW (tax): NL004783538B32","code":""},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Performance stats","text":"way sequoia implemented, comparing likelihoods many different relationships making assignments sequential fashion, means edits improve performance one particular type dataset may negatively affect performance datasets. Therefore, new version sequoia tested extensively simulated real data release CRAN. includes simulated data three pedigrees described Huisman (2017) wide range parameter combinations, results available .","code":""},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"data-description","dir":"Articles","previous_headings":"","what":"Data description","title":"Performance stats","text":"files .RData format, can opened inside R load('path//ThisFile.RData'). .RData file contains 12-dimensional array named PCcount, contains amalgamated $Counts outputs PedCompare() true pedigree pedigree reconstructed simulated genotype data. identical EstConf() output element $PedComp.fwd (forward: comparison relative first, original pedigree). first dimension length 1, dimname indicates sequoia version. second dimension indicates pedigree: ‘FS’ : single generation 1157 individuals produced 432 monogamous matings variable family size (1-11), 0% parents genotyped. 1014 individuals one full siblings, 143 singletons. ‘HSg5’ : five non-overlapping generations full siblings Half Siblings. generation, 24 females mate 2 males 16 male 3 females , mating results 4 offspring. random 40% parents simulated non-genotyped. ‘deer’ : Seventeen birth year cohorts Rum red deer study population: overlapping generations, close inbreeding, tendency related females mate male. 1998 individuals pedigree, 1642 dam 1202 sire. random 40% parents simulated non-genotyped. Dimensions 3-8 relate sequoia() input parameters, presumed genotyping error rate Err equalling simulated error rate. Dimension 9 replicate, dimensions 10-12 correspond PedCompare() $Counts output dimensions. versions prior 1.3, column names relabelled match current names.","code":"# for dimnames of output: data(Ped_HSg5, package=\"sequoia\") PC <- sequoia::PedCompare(Ped_HSg5, Ped_HSg5, Plot=FALSE)  ScoresToCount <- function(A) {   Cnt <- array(NA, dim=dim(PC$Counts), dimnames = dimnames(PC$Counts))   Cnt[,\"Total\",] <- A[,\"Total\",]   Cnt[,\"Match\",] <- A[,\"OK\",] + A[,\"Part\",]   Cnt[,\"Mismatch\",] <- A[,\"Er\",]   Cnt[,\"P2only\",] <- 0   #included in Er   Cnt[,\"P1only\",] <- A[,\"None\",]    return( Cnt ) }"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"load-the-data","dir":"Articles","previous_headings":"","what":"Load the data","title":"Performance stats","text":"data must first downloaded can work R. Let’s compare oldest, newest, -version. click Code button right see R code combine datasets separate versions single array. can e.g. done abind::abind(), ‘hand’: overview parameter combinations run can example created like :","code":"Version <- c(\"0.7\", \"1.3\", \"2.3.4\")     # make a folder to store the files in dir.create(\"sequoia_files\")  gitfolder <- \"https://raw.githubusercontent.com/JiscaH/sequoia_archives/main/performance_tests/\"  for (v in Version) {   download.file(url = paste0(gitfolder, \"sequoia_PCcount_v\", v, \".RData\"),                 destfile = paste0(\"sequoia_files/PCcount_v\", v, \".RData\")) } load(paste0(\"sequoia_files/PCcount_v\", Version[1], \".RData\")) PCC <- array(dim = c(length(Version), dim(PCcount)[-1]),              dimnames = c(list(version=Version), dimnames(PCcount)[-1])) PCC[1,,,,,,,,,,,] <- PCcount[1,,,,,,,,,,,] if (length(Version) > 1) {   for (v in Version[-1]) {     load(paste0(\"sequoia_files/PCcount_v\", v, \".RData\"))     PCC[v,,,,,,,,,,,] <- PCcount[1,,,,,,,,,,,]   } } rm(PCcount) Done <- plyr::adply(PCC, 2:8, function(A) !is.na(A[,\"1\",\"TT\",\"Total\",\"dam\"]))"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"plot","dir":"Articles","previous_headings":"","what":"Plot","title":"Performance stats","text":"parameter vary x-axis usually explanatory variable interested . use number SNPs, also forms useful proxy general ‘informativeness’ SNP data. y-axis proportion non-assignments (P1only, top row panels) proportion incorrect assignments (Mismatch + P2only, bottom row). Lastly, show different parameter combinations different panel columns. set-parameter combinations just example data can visualised, intended starting point exploration. make code clear, define (1) function get subset large array, (2) function actual plotting, (3) parameter values use, (4) actual plotting. makes easier e.g. change parameter values, can done just single place code, without change anything else.","code":""},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"a-function-to-get-the-desired-slice-of-the-huge-array","dir":"Articles","previous_headings":"Plot","what":"1. A function to get the desired slice of the huge array:","title":"Performance stats","text":"","code":"subset.PCC.specs <- function(PCCIN,   # 12D array                              specs)   # 1-row df, names = (subset of) dimnames of PCC {   dn <- names(dimnames(PCCIN))[1:8]   those <- as.list(specs)[dn]   names(those) <- dn   for (d in dn) {     if (is.null(those[[d]]))  those[[d]] <- dimnames(PCCIN)[[d]]   }   those <- lapply(those, as.character)   OUT <- PCCIN[those[[1]],those[[2]],those[[3]],those[[4]],those[[5]],                those[[6]],those[[7]],those[[8]], , , , ]   # there almost certainly is a more elegant way of doing this.    return( OUT ) }"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"plotting-function","dir":"Articles","previous_headings":"Plot","what":"2. Plotting function :","title":"Performance stats","text":"","code":"# required packages: library(plotrix)   # for axis.break() library(plyr)   # defines aaply(): as apply(), but consistent output format   # minimum detectable error rate: # 1 / (2*1000 * 20)   # 2.5E-5 Yzero <- 1e-5 YAT <- 10^seq(-5, 0, 1)  BRK <- 10^-4.8   # break in y-axis   PlotFun <- function(ARER, COL, All = TRUE, Avg = TRUE) {      if (Avg)  ARER.avg <- plyr::aaply(ARER, 1:2, mean, na.rm=TRUE)  # average over iterations      LL <- as.numeric(dimnames(ARER)$nSnp)   # x-axis   Offset <- setNames(seq(-20, 20, length.out = dim(ARER)[1]), dimnames(ARER)[[1]])      # set up the plot & axes:   plot(1:2, 1:2, type = \"n\",        xlim=c(0, 450), ylim = c(Yzero, 1), log=\"y\",        yaxt=\"n\", ylab=\"\", xlab=\"\", las=1, cex.lab=1.2)   axis(2, at=YAT, labels=c(0, YAT[-1]), las=1, cex.axis=1.1)   plotrix::axis.break(2, breakpos=BRK, style = \"slash\", brw=0.03)   abline(h=YAT, col=\"lightgrey\", lty=3)      # plot points & lines:   if (All) {     for (v in Version) {       Y <- ARER[v,,]       Y[Y==0] <- Yzero   # else not plotted if y-axis logarithmic       x <- rep(LL + Offset[v], each=ncol(Y))       points(jitter(x, factor=0.2), t(Y), pch=16,              col = adjustcolor(COL[v], alpha.f=0.5), cex=0.8)     }   }      if (Avg) {     for (v in Version) {       Y <- ARER.avg[v,]       Y[Y==0] <- Yzero   # else not plotted if y-axis logarithmic       lines(LL + Offset[v], Y, type=\"b\", col=COL[v], lwd=2)     }   } }"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"specify-parameters-colours","dir":"Articles","previous_headings":"Plot","what":"3. Specify parameters & colours:","title":"Performance stats","text":"","code":"PlotSpecs <- data.frame(pedigree = c(\"FS\", \"HSg5\", \"deer\"),                         Err = \"1e-4\",                         Complx = \"full\",  #c(\"mono\", \"full\", \"full\"),                         Tassign = 0.5,                         Discrete = FALSE,                         UseAge = \"yes\")  COL <- setNames( hcl.colors(n=length(Version)+1,                             palette=\"inferno\")[seq_along(Version)],                   rev(Version))   # match each color to a particular version # NOTE: hcl.colors() doesn't work in old R versions"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"calculate-rates-from-counts-plot","dir":"Articles","previous_headings":"Plot","what":"4. Calculate rates from counts & plot","title":"Performance stats","text":"pedigree includes dummy individuals sibship-grandparents, denominator assignment error rate unambiguous. paper vignette, total number individuals dam/sire used calculate assignment rate, total number individuals pedigree error rate (founders can also incorrect parent assigned). seem relevant metrics e.g. comparisons methods. , clearly show difference versions, calculate assignment rates proportion maximum number assigned sequoia.","code":"PedN <- c(FS = 1157, HSg5 = 1000, deer = 1998)   # denominators for error rate  par(mfcol=c(2, nrow(PlotSpecs)), mai=c(.3, .6, 0, 0), omi=c(.5,.6,1.3,.1), xpd=F)  for (n in 1:nrow(PlotSpecs)) {      # subset data, using the function defined above   Data <- subset.PCC.specs(PCC, PlotSpecs[n,])       ccat <- c(\"GG\",\"GD\",\"DG\",\"DD\")         # calculate assignment & error rates   ARER <- list(     AR = plyr::aaply(Data, 1:3, function(A)       mean(A[ccat, \"P1only\", ] / colSums(A[ccat, \"Total\",]))), #      mean(A[\"TT\", \"P1only\", ] / A[\"TT\", \"Total\",])),  # denominator = all      ER = plyr::aaply(Data, 1:3, function(A)       sum(A[\"TT\", c(\"Mismatch\", \"P2only\"), ]) / PedN[PlotSpecs[n,\"pedigree\"]])   )      YLAB <- c(\"AR\" = \"False negatives\",             \"ER\" = \"Mismatch + \\n False positives\")   Title <- paste(colnames(PlotSpecs), PlotSpecs[n,], sep=\" = \", collapse = \"\\n\")      # plot using the function defined above, then add margin text & legend   for (z in c(\"AR\", \"ER\")) {     PlotFun(ARER[[z]], COL = COL, All = TRUE, Avg = TRUE)      if (z == \"AR\")  mtext(Title, side=3, line=1, cex=0.9)     if (z == \"ER\")  mtext(\"No. SNPs\", side=1, line=3, cex=1.0)     if (n==1)  mtext(YLAB[[z]], side=2, line=5, cex=1.1)     if (z == \"AR\" & n==1)        legend(\"bottomleft\", names(COL), lty=1, lwd=2, col=COL, inset=.02,              title=\"Version\")   }   }"},{"path":"https://jiscah.github.io/articles/performance_stats.html","id":"comments","dir":"Articles","previous_headings":"Plot","what":"Comments","title":"Performance stats","text":"first glance, average across iterations seems suggest version 2.3.4 performs worse version 1.3 ‘FS’ ‘HSg5’ pedigrees. However, results individual runs show difference statistically significant /due single poor run (middle column, 400 SNPs). complex ‘deer’ pedigree (right column), version 2.3.4 outperforms version 1.3. ‘FS’ pedigree, assignment rate noticeably higher oldest version, error rate. difference largely due considering ‘full cousin’ (3rd degree relatives) relationship alternative. See also pairwise likelihoods recover non-assigned pairs. variation replicates partly due variation parents simulated genotyped: several parents complicated pedigree loop non-genotyped, assignment errors likely complicated regions pedigree high proportion parents genotyped. See main vignette information difference assignment rate genotyped-genotyped versus genotyped-dummy dummy-dummy pairs.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/quick_start_example1.html","id":"get-started","dir":"Articles","previous_headings":"","what":"Get started","title":"Quick start example 1: Simulated data","text":"succinct version example can copy/paste code one go, see main vignette example genotypes simulated fictional pedigree, together associated life history data provided package. pedigree consists 5 discrete generations interconnected half-sib clusters (Pedigree II paper1).","code":"# Install the package. This is only the required the first time, or if you wish to update install.packages(\"sequoia\")     # Load the package. This is required at the start of every new R session. library(sequoia)   # Load the example pedigree and life history data data(Ped_HSg5, LH_HSg5)  # Take a look at the data structure tail(Ped_HSg5) head(LH_HSg5)  # or, in Rstudio, view the full dataframe: View(Ped_HSg5)"},{"path":"https://jiscah.github.io/articles/quick_start_example1.html","id":"simulate-genotypes","dir":"Articles","previous_headings":"","what":"Simulate genotypes","title":"Quick start example 1: Simulated data","text":"Simulate genotype data use try-. Function SimGeno() can simulate data specific genotyping error rate, call rate proportion non-genotyped parents, see helpfile (?SimGeno) details. use defaults; 40% parents presumed non-genotyped (genotypes removed dataset SimGeno() returns result).","code":"Geno <- SimGeno(Ped = Ped_HSg5, nSnp = 200)"},{"path":"https://jiscah.github.io/articles/quick_start_example1.html","id":"parentage-assignment","dir":"Articles","previous_headings":"","what":"Parentage assignment","title":"Quick start example 1: Simulated data","text":"Run sequoia genotype data, lifehistory data, otherwise default values. often advisable first run parentage assignment, check results sensible /parameters need adjusting. Full pedigree reconstruction, including sibship clustering etc., much time consuming. run data check, duplicate check (always performed first) parentage assignment, specify Module = 'par' (older versions: MaxSibIter=0):   see several plots appearing: Histograms minor allele frequency missingness, produced SnpStats(), called CheckGeno() make sure monomorphic SNPs SNPs extremely high missingness dataset Heatmap ageprior parentage assignment, showing age difference 0 years disallowed (\\(0\\), black) mothers (M) fathers (P), age differences allowed (\\(1\\), pale green) relationships. initial maximum age parents set maximum age difference found lifehistory data. Barplots assignment rate (produced SummarySeq()): nearly 60% individuals genotyped parent assigned, line 40% non-genotyped parents simulated. addition, see several messages, including initial post-parentage total LL (log10-likelihood). probability observing genotype data, given (current) pedigree; initially assumed individuals unrelated. number negative, gets closer zero pedigree explains data better. result list, following elements: explained detail helpfile (?sequoia) main vignette. find assigned parents list element PedigreePar: can compare true parents, original pedigree simulated genotype data:  ‘GG’ stands Genotyped offspring, Genotyped parent.","code":"ParOUT <- sequoia(GenoM = Geno,                   LifeHistData = LH_HSg5,                   Module = 'par') ## Genotype matrix looks OK! There are  920  individuals and  200  SNPs. ## Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 6,6 ##  ## ~~~ Duplicate check ~~~ ##  ## ~~~ Parentage assignment ~~~ ## Parentage ... ## Initial total LL : ## [1] -77993.08 ## Post-parentage total LL : ## [1] -60786.8 ## Estimating birth years ... ## Calculating parental LLR ... ## assigned 544 dams and 542 sires to 920 individuals ## Possibly not all parents were assigned, consider running GetMaybeRel() to check names(ParOUT) ##  [1] \"Specs\"         \"ErrM\"          \"args.AP\"       \"AgePriors\"     ##  [5] \"LifeHist\"      \"DupLifeHistID\" \"NoLH\"          \"PedigreePar\"   ##  [9] \"TotLikPar\"     \"AgePriorExtra\" \"LifeHistPar\" tail(ParOUT$PedigreePar) ##         id  dam   sire LLRdam LLRsire LLRpair OHdam OHsire MEpair ## 915 b05187 <NA> b04098     NA    3.15      NA    NA      0     NA ## 916 a05188 <NA> b04098     NA    3.40      NA    NA      0     NA ## 917 a05189 <NA> b04177     NA    6.25      NA    NA      0     NA ## 918 b05190 <NA> b04177     NA    6.00      NA    NA      0     NA ## 919 b05191 <NA> b04177     NA    7.95      NA    NA      0     NA ## 920 b05192 <NA> b04177     NA    6.68      NA    NA      0     NA chk_par <- PedCompare(Ped1 = Ped_HSg5, Ped2 = ParOUT$PedigreePar) chk_par$Counts[\"GG\",,] ##           parent ## class      dam sire ##   Total    547  544 ##   Match    544  542 ##   Mismatch   0    0 ##   P1only     3    2 ##   P2only     0    0"},{"path":"https://jiscah.github.io/articles/quick_start_example1.html","id":"pedigree-reconstruction","dir":"Articles","previous_headings":"","what":"Pedigree reconstruction","title":"Quick start example 1: Simulated data","text":", can run full pedigree reconstruction. default, re-runs parentage assignment. don’t want re-run parentage assignment (e.g. took quite bit time), specified several non-default parameter values want use , , can provide old output input. Re-used : parameter settings ($Specs) genotyping error structure ($ErrM) Lifehistory data ($LifeHist) Age prior, based age distribution assigned parents ($AgePriors) last generated MakeAgePrior(), detected parent-offspring pairs age difference \\(1\\), siblings age difference \\(0\\), .e. generations overlap. information used full pedigree reconstruction. run sequoia() old output input,   Full pedigree reconstruction take least minutes run fairly simple dataset one thousand individuals. may take hours larger complex datasets, /much ambiguity relationships due low number SNPs, genotyping errors, missing data. get several messages: CheckGeno() inform genotype data OK inform parts SeqList (output old sequoia() run) re-used end iteration, update total log10-likelihood (LL), time took iteration, number dams & sires assigned real, genotyped (non-dummy) individuals. total LL number assigned parents plateau (may ‘wobble’ bit), algorithm finish. see plots: Histograms minor allele frequency missingness Heatmap extended version ageprior, including grandparents avuncular (aunt/uncle) relationships ($AgePriorExtra). derived ageprior parents siblings, hasn’t changed since just parentage assignment update assignment rates plot, now including dummy parents. additional plots tables inspect pedigree, can use SummarySeq():  can also compare results true parents:  See ?PedCompare interesting example mismatches. wish count e.g. number full sibling pairs assigned full siblings, paternal half siblings, maternal halfsiblings, unrelated, similar comparisons, use ComparePairs().","code":"SeqOUT <- sequoia(GenoM = Geno, LifeHistData = LH_HSg5, Module = \"ped\") ParOUT$AgePriors ##   M P FS MS PS ## 0 0 0  1  1  1 ## 1 1 1  0  0  0 ## 2 0 0  0  0  0 SeqOUT <- sequoia(GenoM = Geno,                   SeqList = ParOUT,                   Module = \"ped\") ## Genotype matrix looks OK! There are  920  individuals and  200  SNPs. ## using LifeHistData in SeqList ## using AgePriors in SeqList ## using PedigreePar in SeqList ##  ## ~~~ Duplicate check ~~~ ##  ## ~~~ Full pedigree reconstruction ~~~ ## Sibships - Initial Total LL : ## [1] -60786.8 ## Round 01 end, Total LogLik; time (sec): ## [1] -48324.8908     42.3125 ## No. dams, sires for real indiv.: ## [1] 897 902 ## Round 02 end, Total LogLik; time (sec): ## [1] -47677.03335     18.95312 ## No. dams, sires for real indiv.: ## [1] 902 902 ## Round 03 end, Total LogLik; time (sec): ## [1] -47676.53      2.00 ## No. dams, sires for real indiv.: ## [1] 902 902 ## Estimating birth years ... ## Calculating parental LLR ... ## assigned 960 dams and 960 sires to 920 + 80 individuals (real + dummy) ## Possibly not all relatives were assigned, consider running GetMaybeRel() to check summary_seq1 <- SummarySeq(SeqOUT, Panels=c(\"sibships\", \"D.parents\", \"LLR\")) names(summary_seq1) ## [1] \"PedSummary\"  \"ParentCount\" \"GPCount\"     \"SibSize\" chk <- PedCompare(Ped1 = Ped_HSg5, Ped2 = SeqOUT$Pedigree) chk$Counts ## , , parent = dam ##  ##     class ## cat  Total Match Mismatch P1only P2only ##   GG   547   547        0      0      0 ##   GD   355   355        0      0      0 ##   GT   902   902        0      0      0 ##   DG    29    29        0      0      0 ##   DD    29    29        0      0      0 ##   DT    58    58        0      0      0 ##   TT   960   960        0      0      0 ##  ## , , parent = sire ##  ##     class ## cat  Total Match Mismatch P1only P2only ##   GG   544   544        0      0      0 ##   GD   358   358        0      0      0 ##   GT   902   902        0      0      0 ##   DG    32    32        0      0      0 ##   DD    26    26        0      0      0 ##   DT    58    58        0      0      0 ##   TT   960   960        0      0      0"},{"path":"https://jiscah.github.io/articles/quick_start_example1.html","id":"save-results","dir":"Articles","previous_headings":"","what":"Save results","title":"Quick start example 1: Simulated data","text":"Lastly, often wish save results file. can Rdata file, can contain number R objects. can later retrieve R using load, can later resume left . disadvantage open Rdata files outside R (far aware). Therefore, sequoia also includes function write output set plain text files specified folder.","code":"save(SeqOUT, Geno, file=\"Sequoia_output_date.RData\") writeSeq(SeqList = SeqOUT, GenoM = Geno, folder = \"Sequoia-OUT\")"},{"path":[]},{"path":"https://jiscah.github.io/articles/sequoia.html","id":"what-you-need","dir":"Articles","previous_headings":"","what":"What you need","title":"Introduction to sequoia","text":"high minor allele frequency, low missingness, low genotyping error rate, low LD, real-world data usually works well . data format 1 row per individual, 1 column per SNP, coded 0/1/2 copies reference allele. Conversion formats supported. Sex birth year information many individuals possible (‘birth year’: discrete time unit birth/hatching/germination/…). exact year unknown, minimum /maximum possible years can provided. R: can downloaded CRAN. (optional) Rstudio: user-friendly R experience Note individuals average typed 30% say 200 SNPs, means random pair share \\(0.3*0.3*200 = 18\\) SNPs, far reliable pedigree reconstruction. ballpark figures, least 50-100 SNPs required parentage assignment, 200-400 full pedigree reconstruction. Simple pedigrees discrete generations require fewer SNPs complex pedigrees inbreeding.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/sequoia.html","id":"current-version","dir":"Articles","previous_headings":"Download & installation","what":"Current version","title":"Introduction to sequoia","text":"install recent thoroughly checked version sequoia, simply open R run command install github:","code":"install.packages(\"sequoia\")"},{"path":"https://jiscah.github.io/articles/sequoia.html","id":"other-versions","dir":"Articles","previous_headings":"Download & installation","what":"Other versions","title":"Introduction to sequoia","text":"source files previous versions archived CRAN. install need Fortran compiler, default installed computers. can find binary (already compiled) files Windows MacOS versions github archive. can install downloading hard disk R run: github can also find browsable directory latest development version. can installed requires Fortran compiler (windows think included devtools package).","code":"install.packages(\"C:/path/to/file/sequoia_2.5.6.zip\", repos=NULL) devtools::install_github(\"JiscaH/sequoia\") # or remotes::install_github(\"JiscaH/sequoia\")"},{"path":"https://jiscah.github.io/articles/sequoia.html","id":"reconstruct","dir":"Articles","previous_headings":"","what":"Reconstruct","title":"Introduction to sequoia","text":"function perform pedigree reconstruction also called sequoia(): overview output various functions included package, see flow chart (function names rectangles) mock report.","code":"# load the package library(sequoia)    # run pedigree reconstruction on example data included in the pkg SeqOUT <- sequoia(GenoM = SimGeno_example,                    LifeHistData = LH_HSg5,                    Err = 0.005,   # genotyping error rate                   Module=\"ped\",                    quiet=\"verbose\",                    Plot=TRUE) # the result is a list with the pedigree, run parameters,  # and various other elements.                   # graphical summary of results SummarySeq(SeqOUT)"},{"path":"https://jiscah.github.io/articles/sequoia.html","id":"access-help-files","dir":"Articles","previous_headings":"","what":"Access help files","title":"Introduction to sequoia","text":"R, help function available via ?functionname, e.g. ?sequoia. overview help files documentation package available via help(package=\"sequoia\"). ‘See Also’ section near end sequoia() help file list main functions package, tend forget function names (like ).","code":""},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"comments","dir":"Articles","previous_headings":"","what":"Comments","title":"Sequoia report","text":"overview pedigree reconstruction Griffins born 2001-2010.","code":""},{"path":[]},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"parameter-settings","dir":"Articles","previous_headings":"Input summary","what":"Parameter settings","title":"Sequoia report","text":"Genotyping error: probability actual genotype ‘act’ (rows) observed genotype ‘obs’ (columns). Presumed genotyping error rate","code":"kable(as.data.frame(t(SeqOUT$Specs)), booktabs=TRUE) %>%   kable_styling(full_width = FALSE) kable(SeqOUT$ErrM,       caption = 'Presumed genotyping error rate', booktabs=TRUE) %>%   kable_styling(full_width = FALSE) # Note: this error matrix can be fully customised, see ?ErrToM"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"genetic-data","dir":"Articles","previous_headings":"Input summary","what":"Genetic data","title":"Sequoia report","text":"","code":"if (!all(GenoM %in% c('NA', NA))) {   SnpStats(GenoM) } else {   cat('No genotype matrix provided for this report. \\n') } # Note1: SNPs with missingness >=90% (scored for <10% of individuals) are  #       automatically excluded. # Note2: Higher MAF is better. Monomorphic SNPs are automatically excluded. # Note3: Very strong departure from HWE may affect pedigree reconstruction."},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"life-history-data","dir":"Articles","previous_headings":"Input summary","what":"Life history data","title":"Sequoia report","text":"sequoia, sex coded 1=female, 2=male, 3=unknown, 4=hermaphrodite. Unknown birth years may hinder pedigree reconstruction. Among others, used determine individual parent, offspring genetically identified parent-offspring pairs.","code":"table(Sex = SeqOUT$LifeHist$Sex) ## Sex ##   1   2  ##  95 105 LH <- SeqOUT$LifeHist  table('Birth Year' = factor(LH$BirthYear <0, levels = c(FALSE, TRUE),                              labels = c('known', 'missing')),       'min/max Birth Year' = factor(LH$BY.min <0 & LH$BY.max <0,                                      levels = c(FALSE, TRUE),                                      labels = c('known', 'missing'))) ##           min/max Birth Year ## Birth Year known missing ##    known       0     200 ##    missing     0       0 hist(LH$BirthYear,       breaks = c(min(LH$BirthYear, na.rm=TRUE) : (max(LH$BirthYear, na.rm=TRUE)+1)) -.5,      main = 'Distribution of birth years', xlab='')"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"age-distribution-prior","dir":"Articles","previous_headings":"Input summary","what":"Age distribution prior","title":"Sequoia report","text":"‘age prior’ specifies minimum maximum age parents, age difference distribution siblings. default, parentage assignment flat prior used maximum parental age equal largest age difference genotyped individuals. maximum age dams sires can also specified, can discrete versus overlapping generations. distribution can also fully customised. age difference distribution updated parentage assignment full pedigree reconstruction (see ).","code":"if (!all(GenoM %in% c('NA', NA))) {   LH_a <- LH[LH$ID %in% rownames(GenoM),] } else {   LH_a <- LH } AP_IN <- do.call(MakeAgePrior, c(list(Pedigree = NULL,                                       LifeHistData = LH_a),                                  SeqOUT$args.AP)) ## Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 10,10 # Note: Details about and help on the age prior can be found in  #       vignette(\"Sequoia - Age 'Prior'\") SeqOUT$args.AP ## $Flatten ## NULL ##  ## $Smooth ## [1] TRUE"},{"path":[]},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"pedigree-summary","dir":"Articles","previous_headings":"Output summary","what":"Pedigree summary","title":"Sequoia report","text":"Sibling clusters sharing non-genotyped parent assigned ‘dummy’ parent. Via grandparent assignment sibling clusters, parents assigned dummy individuals. grandparents may genotyped dummy individuals. Identifying real non-genotyped individual corresponding dummy individual may always possible, sequoia website offers suggestions candidates known.  distributions number opposing homozygous loci Mendelian errors parent-offspring pairs parent-parent-offspring trios give rough impression genotyping error rate. always zero absence genotyping errors (absence pedigree errors). distributions log10 likelihood ratios give rough impression power genetic data distinguish different types relationships resolve pedigree. Note likelihood ratio assigned parent parent versus another type close relative, full sibling focal individual true parent. relative candidate parents focal individual. size, depth interconnectedness pedigree affect power pedigree can used subsequent analyses, heritability estimates.","code":"sumry <- SummarySeq(SeqOUT, Plot=FALSE) PlotSeqSum(sumry, SeqOUT$Pedigree, Panels='all', ask=FALSE) kable(sumry$PedSummary, booktabs=TRUE) %>%   kable_styling(full_width = FALSE)"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"age-distribution","dir":"Articles","previous_headings":"Output summary","what":"Age distribution","title":"Sequoia report","text":"assignment genotyped parents genotyped offspring, reconstructed pedigree combined provided birth year information estimate distribution age differences among mother-offspring, father-offspring, sibling pairs. age distribution used pedigree reconstruction.","code":"PlotAgePrior(SeqOUT$AgePriors)"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"estimated-birth-years","dir":"Articles","previous_headings":"Output summary > Age distribution","what":"Estimated birth years","title":"Sequoia report","text":"birth year unknown, estimated combining distribution parental ages known birth years assigned parents offspring.","code":"LH_new <- SeqOUT$LifeHistSib LH_new[LH_new$BirthYear < 0, ] ## [1] id        Sex       BirthYear BY.min    BY.max    Sexx      BY.est    ## [8] BY.lo     BY.hi     ## <0 rows> (or 0-length row.names)"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"inferred-sex","dir":"Articles","previous_headings":"Output summary > Age distribution","what":"Inferred sex","title":"Sequoia report","text":"sex individual missing input, may inferred pedigree reconstruction individual forms complementary parent pair individual known sex (species without hermaphrodites).","code":"LH_new[LH_new$Sex == 3 & LH_new$Sexx != 3, ] ## [1] id        Sex       BirthYear BY.min    BY.max    Sexx      BY.est    ## [8] BY.lo     BY.hi     ## <0 rows> (or 0-length row.names)"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"non-assigned-likely-relatives","dir":"Articles","previous_headings":"Output summary","what":"Non-assigned likely relatives","title":"Sequoia report","text":"sequoia algorithm rather conservative making assignments; sequentially ‘grows’ pedigree, tries avoid snowball effect assignment errors. , parent siblings assigned, necessarily mean present dataset. R package includes separate function identify pairs likely relatives assigned, may due variety reasons.","code":"if (!all(Maybe %in% c('NA', NA))) {   MaybePO <- GetRelM(Pairs=Maybe$MaybePar)   PlotRelPairs(MaybePO)   if ('MaybeRel' %in% names(Maybe)) {     MaybeM <- GetRelM(Pairs=Maybe$MaybeRel)     PlotRelPairs(MaybeM)   } } else if (!all(GenoM %in% c('NA', NA))) {   Maybe <- GetMaybeRel(GenoM, SeqList = SeqOUT, Module = 'ped', quiet=TRUE)   MaybeM <- GetRelM(Pairs=Maybe$MaybeRel)   PlotRelPairs(MaybeM) } else {   cat(\"No 'maybe relatives' provided for this report. \\n\") }"},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"confidence-probabilities","dir":"Articles","previous_headings":"Output summary","what":"Confidence probabilities","title":"Sequoia report","text":"assignment accuracy estimated simulations. simulations make several simplifying assumptions, numbers therefore lower bound confidence probability. probability estimated individual separately. Instead, grouped across categories, based whether parent dam sire, genotyped dummy, whether co-parent . also separated genotyped versus dummy focal individuals. parent-pair confidence, per category (Genotyped/Dummy/None)","code":"if (!all(Conf %in% c('NA', NA))) {   kable(Conf$ConfProb,         caption = 'parent-pair confidence, per category (Genotyped/Dummy/None)') } else {   cat('No confidence probabilities provided for this report. \\n') }"},{"path":[]},{"path":"https://jiscah.github.io/articles/sequoia_report.html","id":"likelihood-curve","dir":"Articles","previous_headings":"Further details","what":"Likelihood curve","title":"Sequoia report","text":"total likelihood probability observing genetic data, given inferred pedigree presumed genotyping error rate. initial likelihood probability genotyped individuals unrelated sampled large population Hardy-Weinberg Equilibrium. likelihood increases pedigree reconstruction, pedigree reconstruction terminated total likelihood asymptotes.","code":"nIt <- c(par = length(SeqOUT$TotLikPar),          ped = length(SeqOUT$TotLikSib)) with(SeqOUT, plot(1:nIt[1], TotLikPar, type=\"b\", lwd=2, col=\"forestgreen\",                   xlim=c(1, sum(nIt)-1), xlab=\"Iteration (ped)\", xaxt='n', cex.lab=1.2,                   ylim=c(min(TotLikPar), max(TotLikSib)), ylab=\"Total log-likelihood\")) with(SeqOUT, lines((nIt[1]-1) + 1:nIt[2], TotLikSib, type=\"b\", lwd=2)) axis(1, at=1, labels = 'HWE', cex.axis=1.2, col.axis='darkgrey') axis(1, at=(nIt[1]+1)/2, labels = 'par', lwd.ticks=0, col.axis='forestgreen',       cex.axis=1.2) axis(1, at=(nIt[1]):(nIt[1]+nIt[2]), labels=0:nIt[2], cex.axis=1.2)"},{"path":"https://jiscah.github.io/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jisca Huisman. Author, maintainer.","code":""},{"path":"https://jiscah.github.io/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huisman J (2017). “Pedigree reconstruction SNP data: parentage assignment, sibship clustering beyond.” Molecular Ecology Resources, 17(5), 1009-1024. doi:10.1111/1755-0998.12665, R package version 2.9.0, https://CRAN.R-project.org/package=sequoia.","code":"@Article{,   title = {Pedigree reconstruction from SNP data: parentage assignment, sibship clustering and beyond},   author = {Jisca Huisman},   journal = {Molecular Ecology Resources},   volume = {17},   number = {5},   pages = {1009-1024},   year = {2017},   note = {R package version 2.9.0},   doi = {10.1111/1755-0998.12665},   url = {https://CRAN.R-project.org/package=sequoia}, }"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jiscah.github.io/index.html","id":"id_-parentage-assignment","dir":"","previous_headings":"What it can do","what":"Parentage assignment","title":"Pedigrees from SNP data","text":"Candidate parent–offspring pairs short-listed among genotyped individuals based number SNPs opposing homozygotes. Parents assigned based likelihood ratio pair parent–offspring versus -likely alternative relationship. pair can oriented relative age known, complementary co-parent.","code":""},{"path":"https://jiscah.github.io/index.html","id":"id_-sibship-clustering","dir":"","previous_headings":"What it can do","what":"Sibship clustering","title":"Pedigrees from SNP data","text":"parents genotyped, clusters half- full-siblings identified, assigned dummy parent. Every dummy individual corresponds real-world, non-genotyped individual.","code":""},{"path":"https://jiscah.github.io/index.html","id":"id_-grandparent-assignment","dir":"","previous_headings":"What it can do","what":"Grandparent assignment","title":"Pedigrees from SNP data","text":"cluster half-siblings, grandparents assigned possible, .e. parents sibship’s dummy-parent. grandparents may dummy individuals , parent-offspring links may established two non-genotyped individuals.","code":""},{"path":"https://jiscah.github.io/index.html","id":"package-overview","dir":"","previous_headings":"","what":"Package overview","title":"Pedigrees from SNP data","text":"Beside main function pedigree reconstruction (sequoia()) R package contains various functions, amongst others check agreement existing pedigree genotype data, newly inferred pedigree. print-friendly version  detailed information, please see vignettes (rendered using bookdown):","code":""},{"path":"https://jiscah.github.io/index.html","id":"rationale","dir":"","previous_headings":"","what":"Rationale","title":"Pedigrees from SNP data","text":"Pedigree reconstruction sequoia() relies likelihood ratios focal relationship (e.g. parent-offspring, PO) myriad alternative relationships pair (full siblings, aunt-niece, …, unrelated U). method inspired work E.. Thompson, excerpt paper ‘Paradox Genealogical Inference’ (1976):  words, comparing likelihood ratios LLR(PO/U) candidate parents, chance full siblings may higher value true parent, even absence genotyping errors. One possible solution consider likelihood assignments jointly MCMC(-like) approach, number possible pedigree configurations explore enormous. Comparing pair putative relatives many different relationships makes assignment rather computationally intensive, offset various filtering steps (based e.g. age difference Mendelian inconsistencies) using ‘hill-climbing algorithm’ rather MCMC. Imagine taking slow, careful steps mountain, carefully inspecting direct surroundings taking new step, compared running around mountainside less random. fairly clear path likelihood top (.e. moderately high quality SNP data), sequoia usually fine. , MCMC-based approach may preferable.","code":""},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":null,"dir":"Reference","previous_headings":"","what":"Birth year probabilities — CalcBYprobs","title":"Birth year probabilities — CalcBYprobs","text":"Estimate probability individual unknown birth   year born year y, based BirthYears .min   /.max parents, offspring, siblings, combined   AgePrior (age distribution parent-offspring pairs),   /Year.last parents.","code":""},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Birth year probabilities — CalcBYprobs","text":"","code":"CalcBYprobs(Pedigree = NULL, LifeHistData = NULL, AgePrior = NULL)"},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Birth year probabilities — CalcBYprobs","text":"Pedigree dataframe columns id-dam-sire. LifeHistData data.frame 6 columns: ID max. 30 characters long Sex 1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,            numbers NA = unknown BirthYear birth hatching year, integer, missing values NA   negative number. .min minimum birth year, used BirthYear missing .max maximum birth year, used BirthYear missing Year.last Last year individual offspring. Can   e.g. mammals year death females, year death   males. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring, integers used. Individuals need order `GenoM', genotyped individuals need included. AgePrior matrix probability ratios individuals age difference relationship R, generated MakeAgePrior. NULL, MakeAgePrior called using default values.","code":""},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Birth year probabilities — CalcBYprobs","text":"matrix individual (rows) pedigree missing   birth year LifeHistData, included  LifeHistData, probability born y (columns).   Probabilities rounded 3 decimal points may therefore sum   exactly 1.","code":""},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Birth year probabilities — CalcBYprobs","text":"function assists estimating birth years individuals   unknown, provided least one parent one   offspring pedigree. substitute field-based estimates   age, method summarise pedigree + birth year based   information.","code":""},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"warning","dir":"Reference","previous_headings":"","what":"WARNING","title":"Birth year probabilities — CalcBYprobs","text":"errors pedigree lifehistory data cause errors  birth year probabilities parents offspring, putatively also  distant ancestors descendants. ageprior based  erroneous pedigree lifehistory data, birth year probabilities  affected.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcBYprobs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Birth year probabilities — CalcBYprobs","text":"","code":"BYprobs <- CalcBYprobs(Pedigree = SeqOUT_griffin$Pedigree,                        LifeHistData = SeqOUT_griffin$LifeHist) if (FALSE) { # heatmap lattice::levelplot(t(BYprobs), aspect=\"fill\", col.regions=hcl.colors) }"},{"path":"https://jiscah.github.io/reference/CalcChi2.html","id":null,"dir":"Reference","previous_headings":"","what":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","title":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","text":"one SNP offspring-parent-parent trios single   parent-offspring pairs, calculate expected genotype frequencies given   allele frequency, genotyping error rate, error flavour, perform   chi-square test.","code":""},{"path":"https://jiscah.github.io/reference/CalcChi2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","text":"","code":"CalcChi2(E, q, A.obs, ErrF)"},{"path":"https://jiscah.github.io/reference/CalcChi2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","text":"E presumed genotyping error rate. q allele frequency. .obs array dim 4x4x4 counts joined offspring-parent-parent SNPs ErrF ErrFlavour; function takes genotyping error rate Err input, returns 3x3 matrix observed (columns) conditional actual (rows) genotypes, choose inbuilt ones used sequoia 'version2.0', 'version1.3', 'version1.1'. See ErrToM.","code":""},{"path":"https://jiscah.github.io/reference/CalcChi2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","text":"chisquare value test.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcChi2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chi-square Test on Observed vs Expected Genotypes — CalcChi2","text":"","code":"if (FALSE) { E.hat <- numeric(ncol(GenoM))  # based on trio where possible for (l in 1:ncol(GenoM)) {     E.hat[l] <- stats::optimise(CalcChi2, interval=c(0,1), q=AF[l],                          A.obs=OO.trio[l,,,], ErrF=ErrF)$minimum } }"},{"path":"https://jiscah.github.io/reference/CalcCorners.html","id":null,"dir":"Reference","previous_headings":"","what":"Corner coordinates — CalcCorners","title":"Corner coordinates — CalcCorners","text":"Calculate corner coordinates four rectangles  square Venn diagram","code":""},{"path":"https://jiscah.github.io/reference/CalcCorners.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corner coordinates — CalcCorners","text":"","code":"CalcCorners(count)"},{"path":"https://jiscah.github.io/reference/CalcCorners.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corner coordinates — CalcCorners","text":"count length 5 named vector: 'Total', 'Match', 'Mismatch', 'P1only', 'P2only'.","code":""},{"path":"https://jiscah.github.io/reference/CalcCorners.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corner coordinates — CalcCorners","text":"4x4 matrix columns \"xleft\", \"xright\", \"ybottom\", \"ytop\" (  used rect) rows \"Ped1\", \"Ped2\", \"Mismatch\", \"Match\".","code":""},{"path":"https://jiscah.github.io/reference/CalcCorners.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Corner coordinates — CalcCorners","text":"bottom-left corner Ped1 square (0,0); offset done   VennSquares. size Ped1 Ped2 squares   proportional count, .e. N1 = count[\"Total\"] -   count[\"P2only\"], length size thus proportional   sqrt . x-location Ped2 square function amount overlap   (Match + Mismatch): 0   coco[\"Ped1\", \"xright\"], 100   coco[\"Ped1\", \"xright\"]; proportional -two extremes. overlap area Ped1 Ped2 split Mismatch (bottom)   Match (top).","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcLL.html","id":null,"dir":"Reference","previous_headings":"","what":"wrapper for Fortran function to calculate total likelihood — CalcLL","title":"wrapper for Fortran function to calculate total likelihood — CalcLL","text":"function optimised","code":""},{"path":"https://jiscah.github.io/reference/CalcLL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"wrapper for Fortran function to calculate total likelihood — CalcLL","text":"","code":"CalcLL(Er_hat, GenoM, Parents, DupsV)"},{"path":"https://jiscah.github.io/reference/CalcLL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"wrapper for Fortran function to calculate total likelihood — CalcLL","text":"Er_hat length 3 vector genotyping error rates GenoM Genotype matrix Parents Pedigree, already converted rownumbers GenoM DupsV vector duplicate samples, already converted rownumbers","code":""},{"path":"https://jiscah.github.io/reference/CalcLL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"wrapper for Fortran function to calculate total likelihood — CalcLL","text":"negative total log10-likelihood","code":""},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum Number of Mismatches — CalcMaxMismatch","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"Calculate maximum expected number mismatches   duplicate samples, parent-offspring pairs, parent-parent-offspring   trios.","code":""},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"","code":"CalcMaxMismatch(Err, MAF, ErrFlavour = \"version2.0\", qntl = 1 - 1e-05)"},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"Err estimated genotyping error rate, single number 3x3 matrix  (averaged value(s) across SNPs), vector length MAF,  nSnp x 3 x 3 array. matrix, probability  observed genotype (columns) conditional actual genotype (rows). row must therefore sum 1. array, 3x3 slice abide rule. MAF vector minor allele frequency SNP. ErrFlavour function takes Err input, returns 3x3 matrix observed (columns) conditional actual (rows) genotypes, choose inbuilt ones used sequoia 'version2.0', 'version1.3', 'version1.1'. Ignored Err matrix. See ErrToM. qntl quantile binomial distribution used maximum, individual-level probability. desired dataset-level probability quantile \\(Q\\), use qntl\\(= Q^{(1/N)}\\), \\(N\\) number individuals.","code":""},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"vector three integers: DUP Maximum number differences 2 samples   individual OH Maximum number Opposing Homozygous SNPs true    parent-offspring pair Maximum number Mendelian Errors among true parent-parent-   offspring trio .","code":""},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"thresholds maximum number mismatches calculated aim   minimise false negatives, .e. minimise chance true   duplicates true parent-offspring pairs already excluded   filtering steps MaxMismatch values used.   Consequently, high probability false positives, .e.   likely sample pairs fewer mismatches   MaxMismatch threshold, fact duplicate samples   parent-offspring pairs. Use MaxMismatch thresholds   therefore first step pedigree reconstruction   sequoia.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcMaxMismatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum Number of Mismatches — CalcMaxMismatch","text":"","code":"CalcMaxMismatch(Err = 0.05, MAF = runif(n=100, min=0.3, max=0.5)) #> DUP  OH  ME  #>  24   8  14  if (FALSE) { CalcMaxMismatch(Err = 0.02, MAF = SnpStats(MyGenoMatrix, Plot=FALSE)[,\"AF\"]) }"},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate OH and LLR for a pedigree — CalcOHLLR","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"Count opposite homozygous (OH) loci parent-offspring   pairs Mendelian errors () parent-parent-offspring trios,   calculate parental log-likelihood ratios (LLR).","code":""},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"","code":"CalcOHLLR(   Pedigree = NULL,   GenoM = NULL,   CalcLLR = TRUE,   LifeHistData = NULL,   AgePrior = FALSE,   SeqList = NULL,   Err = 1e-04,   ErrFlavour = \"version2.0\",   Tassign = 0.5,   Tfilter = -2,   Complex = \"full\",   Herm = \"no\",   quiet = FALSE )"},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"Pedigree dataframe columns id-dam-sire. May include non-genotyped individuals, treated dummy individuals. provided, pedigree SeqList ignored. GenoM numeric matrix genotype data: One row per individual, one column per SNP, coded 0, 1, 2 -9 (missing). See also GenoConvert. CalcLLR calculate log-likelihood ratios assigned parents (genotyped + dummy/non-genotyped; parent vs. otherwise related). FALSE, number mismatching SNPs counted (OH & ), parameters LifeHistData, AgePrior, Err, Tassign, Complex ignored. Note also calculating likelihood ratios much time consuming counting OH & . LifeHistData data.frame 6 columns: ID max. 30 characters long Sex 1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,            numbers NA = unknown BirthYear birth hatching year, integer, missing values NA   negative number. .min minimum birth year, used BirthYear missing .max maximum birth year, used BirthYear missing Year.last Last year individual offspring. Can   e.g. mammals year death females, year death   males. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring, integers used. Individuals need order `GenoM', genotyped individuals need included. AgePrior logical (TRUE/FALSE) whether estimate ageprior Pedigree LifeHistData, matrix generated MakeAgePrior included sequoia output. AgePrior affects relationships considered possible: \\(P(|R) / P() > 0\\).  TRUE, MakeAgePrior called using default values. FALSE, relationships considered possible age differences, except parent-offspring pairs age difference zero, grand-parental pairs age difference least two. SeqList list output sequoia. input parameter Pedigree=NULL, SeqList$Pedigree used present, SeqList$PedigreePar otherwise. SeqList$Specs present, input parameters name items ignored, except 'CalcLLR' 'AgePriors=FALSE'. list elements  `LifeHist', `AgePriors', `ErrM' also used present, override corresponding input parameters. Err estimated genotyping error rate, single number, length 3 vector P(hom|hom), P(het|hom), P(hom|het), 3x3 matrix. See details . error rate presumed constant across SNPs, missingness presumed random respect actual genotype. Using Err >5% recommended, Err >10% strongly discouraged. ErrFlavour function takes Err (single number) input, returns length 3 vector 3x3 matrix, choose inbuilt options 'version2.9', 'version2.0', 'version1.3', 'version1.1', referring sequoia version default. Ignored Err vector matrix. See ErrToM details. Tassign minimum LLR required acceptance proposed relationship, relative next likely relationship. Higher values result conservative assignments. Must zero positive. Tfilter threshold log10-likelihood ratio (LLR) proposed relationship versus unrelated, select candidate relatives. Typically negative value, related fact unconditional likelihoods calculated filtering steps. negative values may decrease non-assignment, increase computational time. Complex Breeding system complexity. Either \"full\" (default), \"simp\" (simplified, explicit consideration inbred relationships), \"mono\" (monogamous). Herm Hermaphrodites, either \"\", \"\" (distinguish dam sire role, default least 1 individual sex=4), \"B\" (distinction dam sire role). latter deal selfing. quiet logical, suppress messages","code":""},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"Pedigree dataframe additional columns: LLRdam Log10-Likelihood Ratio (LLR) female mother,  versus next likely relationship focal individual  female (see Details relationships considered) LLRsire idem, male parent LLRpair LLR parental pair, versus next likely   configuration three individuals (one neither parent   assigned) OHdam Number loci offspring mother    opposite homozygotes OHsire idem, father MEpair Number Mendelian errors offspring    parent pair, includes OH well e.g. parents opposing    homozygotes, offspring heterozygote. offspring    OH parents counted 2 errors. SNPd.id Number SNPs scored (non-missing) focal individual SNPd.id.dam Number SNPs scored (non-missing) individual    dam SNPd.id.sire Number SNPs scored individual sire Sexx Sex LifeHistData, inferred Sex assigned part    parent-pair .est mode birth year probability distribution .lo lower limit 95% highest density region birth year  probability distribution .hi higher limit columns 'LLRdam', 'LLRsire' 'LLRpair' included CalcLLR=TRUE. parent parent-pair incompatible lifehistory data presumed genotyping error rate, error value '777' may given. columns 'Sexx', '.est', '.lo' '.hi' included LifeHistData provided, least one genotyped individual unknown birth year unknown sex.","code":""},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"individual Pedigree occur   GenoM substituted dummy individual; can recognised   value 0' columns 'SNPd.id.dam' `SNPd.id.sire` output.   non-genotyped individuals parental log-likelihood ratio can   calculated least one genotyped offspring (see also   getAssignCat). birth years LifeHistData AgePrior used   calculation affect value likelihoods   various relationships, _are_ used filtering steps,   may therefore affect likelihood _ratio_. default   (AgePrior=FALSE) assumes age-relationship combinations   possible, may mean additional alternatives considered   compared sequoia default, resulting somewhat lower   LLR values. negative LLR 's parent B indicates either B truely   parent , B's parents incorrect. latter may cause B's   presumed true, unobserved genotype divert observed genotype,   downstream consequences offspring. rare cases may also   due 'weird', non-implemented double triple relationships   B.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcOHLLR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate OH and LLR for a pedigree — CalcOHLLR","text":"","code":"# count Mendelian errors in an existing pedigree Ped.OH <- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,                     CalcLLR = FALSE) #> Counting Mendelian errors ... Ped.OH[50:55,] #>        id    dam   sire OHdam OHsire MEpair SNPd.id SNPd.id.dam SNPd.id.sire #> 50 a01010 a00008 b00016     0      0      1     200         199          198 #> 51 b01011 a00008 b00016     0      0      1     200         199          198 #> 52 b01012 a00008 b00016     0      0      1     198         197          196 #> 53 b01013 a00011 b00001     0      0      0     199         199          199 #> 54 b01014 a00011 b00001     0      0      0     198         198          198 #> 55 b01015 a00011 b00001     0      0      1     198         198          198 # view histograms SummarySeq(Ped.OH, Panels=\"OH\")   # Parent likelihood ratios in an existing pedigree, including for # non-genotyped parents Ped.LLR <- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,                     CalcLLR = TRUE, LifeHistData=LH_HSg5, AgePrior=TRUE) #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1 #> Counting Mendelian errors ... #> Counting opposing homozygous loci between all individuals ... #> Calculating parental LLR ... SummarySeq(Ped.LLR, Panels=\"LLR\")   if (FALSE) { # likelihood ratios change with presumed genotyping error rate: Ped.LLR.B <- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,                     CalcLLR = TRUE, LifeHistData=LH_HSg5, AgePrior=TRUE,                     Err = 0.005) SummarySeq(Ped.LLR.B, Panels=\"LLR\")  # run sequoia with CalcLLR=FALSE, and add OH + LLR later: SeqOUT <- sequoia(Geno_griffin, LH_griffin, CalcLLR=FALSE,quiet=TRUE,Plot=FALSE) PedA <- CalcOHLLR(Pedigree = SeqOUT[[\"Pedigree\"]][, 1:3], GenoM = Genotypes,   LifeHistData = LH_griffin, AgePrior = TRUE, Complex = \"full\") SummarySeq(PedA, Panels=c(\"LLR\", \"OH\")) }"},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"specified pair individuals, calculate   log10-likelihoods PO, FS, HS, GP, FA, HA, U (see Details).   Individuals must genotyped least one genotyped offspring. NOTE values \\(>0\\) various NA types, see 'Likelihood   special codes' 'Value' section .","code":""},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"","code":"CalcPairLL(   Pairs = NULL,   GenoM = NULL,   Pedigree = NULL,   LifeHistData = NULL,   AgePrior = TRUE,   SeqList = NULL,   Complex = \"full\",   Herm = \"no\",   Err = 1e-04,   ErrFlavour = \"version2.0\",   Tassign = 0.5,   Tfilter = -2,   quiet = FALSE,   Plot = TRUE )"},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"Pairs dataframe columns ID1 ID2,  optionally Sex1 Sex ID1, 1=female, 2=male, 3=unknown, NA take   LifeHistData. sex individuals occurring parent   Pedigree altered. Sex2 Sex ID2 AgeDif Age difference whole time units, BirthYear1 - BirthYear2   (.e. positive ID2 born ID1). NA, calculated   LifeHistData. Use '999' explicitly specify 'unknown'. focal relationship character abbreviation; PO, FS, HS, GP U. See Details effect explanation abbreviations. Default: U patmat 1=maternal relatives, 2=paternal relatives. relevant   HS & GP, defaults Sex1, 1 Sex1=3, currently   predictably implemented pairs two genotyped individuals.   Always equal Sex2 PO pairs Sex2 known. dropPar1 Drop parents ID1 calculating pair likelihood, rather conditioning ; choose 'none', 'dam', 'sire', ''. See example. e.g. pair shares common mother, 'none' 'sire' condition shared mother calculate likelihood maternal siblings, dropPar1='dam' '' calculate likelihood, likelihoods mother ID1 unknown. dropPar2 dropPar1, ID2 GenoM numeric matrix genotype data: One row per individual, one column per SNP, coded 0, 1, 2 -9 (missing). See also GenoConvert. Pedigree dataframe columns id-dam-sire; likelihoods calculated conditional pedigree. May include non-genotyped individuals, treated dummy individuals. LifeHistData data.frame 6 columns: ID max. 30 characters long Sex 1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,            numbers NA = unknown BirthYear birth hatching year, integer, missing values NA   negative number. .min minimum birth year, used BirthYear missing .max maximum birth year, used BirthYear missing Year.last Last year individual offspring. Can   e.g. mammals year death females, year death   males. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring, integers used. Individuals need order `GenoM', genotyped individuals need included. AgePrior logical (TRUE/FALSE) whether estimate ageprior Pedigree LifeHistData, matrix generated MakeAgePrior included sequoia output. AgePrior affects relationships considered possible: \\(P(|R) / P() > 0\\).  TRUE, MakeAgePrior called using default values. FALSE, relationships considered possible age differences, except parent-offspring pairs age difference zero, grand-parental pairs age difference least two. SeqList list output sequoia. input parameter Pedigree=NULL, SeqList$Pedigree used present, SeqList$PedigreePar otherwise. SeqList$Specs present, input parameters name items ignored. list elements 'LifeHist', 'AgePriors', 'ErrM' also used present, override corresponding input parameters. Complex Breeding system complexity. Either \"full\" (default), \"simp\" (simplified, explicit consideration inbred relationships), \"mono\" (monogamous). Herm Hermaphrodites, either \"\", \"\" (distinguish dam sire role, default least 1 individual sex=4), \"B\" (distinction dam sire role). latter deal selfing. Err estimated genotyping error rate, single number, length 3 vector P(hom|hom), P(het|hom), P(hom|het), 3x3 matrix. See details . error rate presumed constant across SNPs, missingness presumed random respect actual genotype. Using Err >5% recommended, Err >10% strongly discouraged. ErrFlavour function takes Err (single number) input, returns length 3 vector 3x3 matrix, choose inbuilt options 'version2.9', 'version2.0', 'version1.3', 'version1.1', referring sequoia version default. Ignored Err vector matrix. See ErrToM details. Tassign minimum LLR required acceptance proposed relationship, relative next likely relationship. Higher values result conservative assignments. Must zero positive. Tfilter threshold log10-likelihood ratio (LLR) proposed relationship versus unrelated, select candidate relatives. Typically negative value, related fact unconditional likelihoods calculated filtering steps. negative values may decrease non-assignment, increase computational time. quiet logical, suppress messages Plot logical, display scatter plots PlotPairLL.","code":""},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"Pairs dataframe including optional columns listed   , plus additional columns: xx Log10-Likelihood pair relationship xx, xx    relationship abbreviations listed . TopRel Abbreviation likely relationship LLR Log10-Likelihood ratio -likely second likely    relationships. LLRs, e.g. -likely unrelated, can    easily computed. Relationship abbreviations: PO Parent - offspring FS Full siblings HS Half siblings GP Grandparent FA Full avuncular HA Half avuncular 3rd degree relationships U Unrelated 2nd Unclear type 2nd degree relatives     (HS, GP, FA) ?? Unclear type 1st, 2nd 3rd degree     relatives Likelihood special codes: 222 Maybe (via) parent (e.g. focal=\"GP\", likely     maternal paternal grandparent, therefore assignable) 333 Excluded comparison (occur) 444 implemented (e.g. create odd double/triple     relationship combination provided pedigree) 777 Impossible (e.g. full sibling grandparent) 888 Already assigned provided pedigree (see dropPar     arguments) 999 NA","code":""},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"pair may included multiple times, e.g. different   sex, age difference, focal relationship, explore effect   likelihoods. Likelihoods calculated relationships   possible given age difference, e.g. PO (parent-offspring)   calculated pairs age difference 0. Non-genotyped individuals can included least one   genotyped offspring can turned dummy (see   getAssignCat); establish pedigree must provided. Warning 1: check whether input pedigree genetically   sensible, simply conditioned upon. Checking whether pedigree   compatible SNP data can done CalcOHLLR. Warning 2: Conditioning Pedigree can make computation   orders magnitude slower.","code":""},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"why-does-it-say-impossible-","dir":"Reference","previous_headings":"","what":"Why does it say 777 (impossible)?","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"function uses machinery sequoia, save   time calculate likelihood quickly obvious pair   related specified manner. PO (putative parent-offspring pairs) case : sex candidate parent, via Pairs$Sex2     LifeHistData, match Pairs$patmat, defaults     1 (maternal relatives, .e. dam) dam already assigned via Pedigree Pairs$dropPar1     ='none', Pairs$patmat = 1 Pairs$focal 'U' (default), OH count     two individuals exceeds MaxMismatchOH. value can found     SeqList$Specs), calculated CalcMaxMismatch age difference, either calculated LifeHistData     specified via Pairs$AgeDif, impossible parent-offspring     pair according age prior. latter can specified via     AgePrior, taken SeqList, calculated     Pedigree LifeHistData provided. FS (putative full siblings) happens e.g. ID1 dam  assigned dropped (Pairs$dropPar1='none'  'sire'), OH count ID1's dam ID2 exceeds  MaxMismatchOH. easiest way 'fix' increasing presumed  genotyping error rate.","code":""},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"double-relationships-amp-focal-relationship","dir":"Reference","previous_headings":"","what":"Double relationships & focal relationship","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"Especially Complex='full', seven relationship   alternatives listed considered, whole range possible   double even triple relationships. example, mother offspring B   (PO) may also paternal half-siblings (HS, 's mother mated   male), grandmother grand-offspring (GP, B's father 's son),   paternal aunt (B's father full half sib ). likelihood reported 'LL_PO' -likely one possible   alternatives, among impossible due age differences   due pedigree (reconstructed point). Whether e.g.   likelihood PO & HS counted PO HS, depends   situation determined variable 'focal': parentage   assignment, counted PO HS, sibship   clustering, counted HS PO -- omitting   alternative relationship result deadlock.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CalcPairLL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Likelihoods for Alternative Relationships — CalcPairLL","text":"","code":"CalcPairLL(Pairs = data.frame(ID1='i116_2006_M', ID2='i119_2006_M'),            GenoM = Geno_griffin, Err = 1e-04, Plot=FALSE) #>           ID1         ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2 #> 1 i116_2006_M i119_2006_M    3    3     NA     U      1     none     none #>        PO     FS      HS      GP      FA      HA       U TopRel LLR #> 1 -379.69 -336.6 -329.03 -329.03 -329.03 -329.03 -334.64    2nd   0  ## likelihoods underlying parent LLR in pedigree: # Example: dams for bottom 3 individuals tail(SeqOUT_griffin$PedigreePar, n=3) #>              id         dam        sire LLRdam LLRsire LLRpair OHdam OHsire #> 140 i198_2010_M i166_2009_F        <NA>  10.42      NA      NA     0     NA #> 141 i199_2010_F i165_2009_F i141_2008_M   9.55    2.73   17.03     0      0 #> 142 i200_2010_F i166_2009_F i142_2008_M   9.98   10.22   16.97     1      0 #>     MEpair #> 140     NA #> 141      0 #> 142      1 # set up dataframe with these pairs. LLRdam & LLRsire ignore any co-parent Pairs_d <- data.frame(ID1 = SeqOUT_griffin$PedigreePar$id[140:142],                       ID2 = SeqOUT_griffin$PedigreePar$dam[140:142],                       focal = \"PO\",                       dropPar1 = 'both')  # Calculate LL's, conditional on the rest of the pedigree + age differences CalcPairLL(Pairs_d, GenoM = Geno_griffin, Err = 1e-04,            LifeHistData = LH_griffin, Pedigree = SeqOUT_griffin$PedigreePar) #> Ageprior: Pedigree-based, overlapping generations, flattened, MaxAgeParent = 99,99   #>           ID1         ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2 #> 1 i198_2010_M i166_2009_F    2    1      1    PO      1     both     none #> 2 i199_2010_F i165_2009_F    1    1      1    PO      1     both     none #> 3 i200_2010_F i166_2009_F    1    1      1    PO      1     both     none #>        PO  FS      HS  GP      FA      HA       U TopRel   LLR #> 1 -289.23 777 -299.18 777 -297.85 -300.15 -310.28     PO  8.62 #> 2 -279.66 777 -295.41 777 -294.33 -297.09 -310.77     PO 14.67 #> 3 -283.94 777 -298.42 777 -298.35 -299.93 -312.93     PO 14.41  # LLR changes when ignoring age and/or pedigree, as different relationships # become (im)possible CalcPairLL(Pairs_d, GenoM = Geno_griffin, Err = 1e-04)  #>           ID1         ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2 #> 1 i198_2010_M i166_2009_F    3    3     NA    PO      1     both     none #> 2 i199_2010_F i165_2009_F    3    3     NA    PO      1     both     none #> 3 i200_2010_F i166_2009_F    3    3     NA    PO      1     both     none #>        PO      FS      HS      GP      FA      HA       U TopRel  LLR #> 1 -308.78 -314.22 -312.81 -311.20 -313.25 -312.81 -329.70     PO 2.42 #> 2 -304.43 -310.40 -311.86 -309.98 -313.78 -311.86 -335.69     PO 5.54 #> 3 -303.14 -309.52 -310.47 -307.39 -311.26 -310.47 -332.35     PO 4.24  # LLRpair is calculated conditional on co-parent, and min. of dam & sire LLR Pairs_d$dropPar1 <- 'dam' Pairs_s <- data.frame(ID1 = SeqOUT_griffin$PedigreePar$id[141:142],                       ID2 = SeqOUT_griffin$PedigreePar$sire[141:142],                       focal = \"PO\",                       dropPar1 = 'sire') CalcPairLL(rbind(Pairs_d, Pairs_s), GenoM = Geno_griffin, Err = 1e-04,            LifeHistData = LH_griffin, Pedigree = SeqOUT_griffin$PedigreePar) #> Ageprior: Pedigree-based, overlapping generations, flattened, MaxAgeParent = 99,99   #>           ID1         ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2 #> 1 i198_2010_M i166_2009_F    2    1      1    PO      1      dam     none #> 2 i199_2010_F i165_2009_F    1    1      1    PO      1      dam     none #> 3 i200_2010_F i166_2009_F    1    1      1    PO      1      dam     none #> 4 i199_2010_F i141_2008_M    1    2      2    PO      2     sire     none #> 5 i200_2010_F i142_2008_M    1    2      2    PO      2     sire     none #>        PO  FS      HS      GP      FA      HA       U TopRel   LLR #> 1 -289.23 777 -299.18  777.00 -297.85 -300.15 -310.28     PO  8.62 #> 2 -239.97 777 -262.19  777.00 -259.82 -266.02 -282.76     PO 19.85 #> 3 -245.87 777 -265.52  777.00 -266.47 -271.87 -287.07     PO 19.64 #> 4 -235.68 777 -361.87 -251.85 -254.73 -263.57 -275.37     PO 16.17 #> 5 -240.97 777 -263.38 -256.61 -258.66 -263.96 -279.04     PO 15.63   ## likelihoods underlying LLR in getMaybeRel output: MaybeRel_griffin$MaybePar[1:5, ] #>           ID1         ID2 TopRel  LLR OH BirthYear1 BirthYear2 AgeDif Sex1 Sex2 #> 1 i091_2005_F i118_2006_M     PO 8.55  0         NA         NA     NA    3    3 #> 2 i127_2007_M i197_2010_F     PO 7.90  0         NA         NA     NA    3    3 #> 3 i121_2007_M i175_2009_M     PO 7.85  0         NA         NA     NA    3    3 #> 4 i030_2002_F i061_2004_F     PO 7.75  0         NA         NA     NA    3    3 #> 5 i041_2003_F i080_2004_M     PO 7.71  0         NA         NA     NA    3    3 #>   SNPdBoth #> 1      392 #> 2      392 #> 3      392 #> 4      392 #> 5      392 FivePairs <- MaybeRel_griffin$MaybePar[1:5, c(\"ID1\", \"ID2\", \"Sex1\", \"Sex2\")] PairLL <- CalcPairLL(Pairs = rbind( cbind(FivePairs, focal = \"PO\"),                                     cbind(FivePairs, focal = \"HS\"),                                     cbind(FivePairs, focal = \"GP\")),                      GenoM = Geno_griffin, Plot=FALSE) PairLL[PairLL$ID1==\"i121_2007_M\", ] #>            ID1         ID2 Sex1 Sex2 AgeDif focal patmat dropPar1 dropPar2 #> 3  i121_2007_M i175_2009_M    3    3     NA    PO      1     none     none #> 8  i121_2007_M i175_2009_M    3    3     NA    HS      1     none     none #> 13 i121_2007_M i175_2009_M    3    3     NA    GP      1     none     none #>         PO      FS      HS      GP      FA     HA       U TopRel  LLR #> 3  -313.21 -324.46 -321.90 -321.51 -323.01 -321.9 -337.98     PO 8.30 #> 8  -313.21  222.00 -321.09 -321.09 -323.01 -321.9 -337.98     PO 7.88 #> 13 -313.21 -324.46 -321.09 -321.09 -322.83 -321.9 -337.98     PO 7.88 # LL(FS)==222 : HSHA, HSGP, FAHA more likely than FS # LL(GP) higher when focal=HS: GP via 'other' parent also considered # LL(FA) higher when focal=PO: FAHA, or FS of 'other' parent"},{"path":"https://jiscah.github.io/reference/CalcRped.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Pedigree Relatedness — CalcRped","title":"Calculate Pedigree Relatedness — CalcRped","text":"Morph pedigree kinship2 compatible format use   kinship calculate kinship coefficients;   relatedness = 2*kinship.","code":""},{"path":"https://jiscah.github.io/reference/CalcRped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Pedigree Relatedness — CalcRped","text":"","code":"CalcRped(Pedigree, OUT = \"DF\")"},{"path":"https://jiscah.github.io/reference/CalcRped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Pedigree Relatedness — CalcRped","text":"Pedigree dataframe columns id-dam-sire. desired output format, 'M' matrix 'DF' dataframe columns IID1 - IID2 - R.ped.","code":""},{"path":"https://jiscah.github.io/reference/CalcRped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Pedigree Relatedness — CalcRped","text":"matrix dataframe.","code":""},{"path":"https://jiscah.github.io/reference/CheckAP.html","id":null,"dir":"Reference","previous_headings":"","what":"check AgePrior — CheckAP","title":"check AgePrior — CheckAP","text":"Check provided AgePrior correct format","code":""},{"path":"https://jiscah.github.io/reference/CheckAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check AgePrior — CheckAP","text":"","code":"CheckAP(AgePrior)"},{"path":"https://jiscah.github.io/reference/CheckAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check AgePrior — CheckAP","text":"AgePrior matrix 'MaxAgeParent' rows columns M-P-FS-MHS-PHS","code":""},{"path":"https://jiscah.github.io/reference/CheckAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check AgePrior — CheckAP","text":"AgePrior corrected format, necessary","code":""},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Genotype Matrix — CheckGeno","title":"Check Genotype Matrix — CheckGeno","text":"Check provided genotype matrix correct   format, check low call rate samples SNPs.","code":""},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Genotype Matrix — CheckGeno","text":"","code":"CheckGeno(   GenoM,   quiet = FALSE,   Plot = FALSE,   Return = \"GenoM\",   Strict = TRUE,   DumPrefix = c(\"F0\", \"M0\") )"},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Genotype Matrix — CheckGeno","text":"GenoM genotype matrix. quiet suppress messages. Plot display plots SnpStats. Return either 'GenoM' return cleaned-genotype matrix, 'excl' return list excluded SNPs individuals (see Value). Strict Exclude individuals genotyped <5 genotyped <5 version 2.4.1. Otherwise excluded (nearly) monomorphic SNPs, SNPs scored fewer 2 individuals, individuals scored fewer 2 SNPs. DumPrefix length 2 vector, check occur among genotyped individuals.","code":""},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Genotype Matrix — CheckGeno","text":"Return='excl' list , found: ExcludedSNPs SNPs scored <10    excluded running sequoia ExcludedSnps-mono monomorphic (fixed) SNPs; automatically excluded    running sequoia. includes nearly-fixed SNPs    MAF \\(= 1/2N\\). Column numbers ** removal    ExcludedSNPs, . ExcludedIndiv Individuals scored <5    reliably included pedigree reconstruction. Individual call rate    calculated removal 'Excluded SNPs' Snps-LowCallRate SNPs scored 10    recommended filtered Indiv-LowCallRate individuals scored <50    recommended filtered Return='excl' return invisible, .e. check run warnings errors always displayed, nothing may returned.","code":""},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":"thresholds","dir":"Reference","previous_headings":"","what":"Thresholds","title":"Check Genotype Matrix — CheckGeno","text":"Appropriate call rate thresholds SNPs   individuals depend total number SNPs, distribution call rates,   genotyping errors, proportion candidate parents SNPd   (sibship clustering prone false positives). Note filtering   first SNP call rate tends keep individuals .","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/CheckGeno.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Genotype Matrix — CheckGeno","text":"","code":"GenoM <- SimGeno(Ped_HSg5, nSnp=400, CallRate = runif(400, 0.2, 0.8)) # the quick way: GenoM.checked <- CheckGeno(GenoM, Return=\"GenoM\") #> Warning:  There are 178 SNPs scored for <50% of individuals  #> There are  1000  individuals and  400  SNPs.  # the user supervised way: Excl <- CheckGeno(GenoM, Return = \"excl\") #> Warning:  There are 178 SNPs scored for <50% of individuals  #> There are  1000  individuals and  400  SNPs. GenoM.orig <- GenoM   # make a 'backup' copy if (\"ExcludedSnps\" %in% names(Excl))   GenoM <- GenoM[, -Excl[[\"ExcludedSnps\"]]] if (\"ExcludedSnps-mono\" %in% names(Excl))   GenoM <- GenoM[, -Excl[[\"ExcludedSnps-mono\"]]] if (\"ExcludedIndiv\" %in% names(Excl))   GenoM <- GenoM[!rownames(GenoM) %in% Excl[[\"ExcludedIndiv\"]], ]  # warning about  SNPs scored for <50% of individuals ? # note: this is not necessarily a problem, and sometimes unavoidable. SnpCallRate <- apply(GenoM, MARGIN=2,                      FUN = function(x) sum(x!=-9)) / nrow(GenoM) hist(SnpCallRate, breaks=50, col=\"grey\")  GenoM <- GenoM[, SnpCallRate > 0.6]  # to filter out low call rate individuals: (also not necessarily a problem) IndivCallRate <- apply(GenoM, MARGIN=1,                        FUN = function(x) sum(x!=-9)) / ncol(GenoM) hist(IndivCallRate, breaks=50, col=\"grey\")  GoodSamples <- rownames(GenoM)[ IndivCallRate > 0.8]"},{"path":"https://jiscah.github.io/reference/CheckLH.html","id":null,"dir":"Reference","previous_headings":"","what":"Check LifeHistData — CheckLH","title":"Check LifeHistData — CheckLH","text":"Check provided LifeHistData correct format.","code":""},{"path":"https://jiscah.github.io/reference/CheckLH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check LifeHistData — CheckLH","text":"","code":"CheckLH(LifeHistData, gID = NA, sorted = TRUE, returnDups = FALSE)"},{"path":"https://jiscah.github.io/reference/CheckLH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check LifeHistData — CheckLH","text":"LifeHistData dataframe ID - Sex - Birth year, optionally .min - .max - YearLast. gID character vector names genotyped individuals, .e. rownames(GenoM). sorted logical, return lifehistdata genotyped individuals , strictly order. including padding 'empty' rows individual gID input-LH. returnDups logical, instead just (sorted) LifeHistData, return list also includes dataframe duplicate entries /character vector genotyped IDs occuring LifeHistData (formerly returned DuplicateCheck).","code":""},{"path":"https://jiscah.github.io/reference/CheckLH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check LifeHistData — CheckLH","text":"dataframe LifeHistData formatted use Fortran    part program, list duplicate missing entries.","code":""},{"path":"https://jiscah.github.io/reference/CheckParams.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if input parameters are valid — CheckParams","title":"Check if input parameters are valid — CheckParams","text":"Check input parameter value proper kind value.","code":""},{"path":"https://jiscah.github.io/reference/CheckParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if input parameters are valid — CheckParams","text":"","code":"CheckParams(PARAM)"},{"path":"https://jiscah.github.io/reference/CheckParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if input parameters are valid — CheckParams","text":"PARAM list input parameters","code":""},{"path":"https://jiscah.github.io/reference/CheckParams.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if input parameters are valid — CheckParams","text":"Nothing except errors, warnings, messages","code":""},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Pairwise Relationships — ComparePairs","title":"Compare Pairwise Relationships — ComparePairs","text":"Compare, count identify different types relative pairs   two pedigrees, within one pedigree.","code":""},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Pairwise Relationships — ComparePairs","text":"","code":"ComparePairs(   Ped1 = NULL,   Ped2 = NULL,   Pairs2 = NULL,   GenBack = 1,   patmat = FALSE,   ExcludeDummies = TRUE,   DumPrefix = c(\"F0\", \"M0\"),   Return = \"Counts\" )"},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Pairwise Relationships — ComparePairs","text":"Ped1 first (e.g. original/reference) pedigree, dataframe 3 columns: id-dam-sire. Ped2 optional second (e.g. inferred) pedigree. Pairs2 optional dataframe first three columns: ID1-ID2- relationship, e.g. returned GetMaybeRel. Column names additional columns ignored. May provided addition , instead Ped2. GenBack number generations back consider; 1 returns parent-offspring sibling relationships, 2 also returns grandparental, avuncular first cousins. GenBack >2 implemented. patmat logical, distinguish paternal versus maternal relative pairs? ExcludeDummies logical, exclude dummy IDs output? Individuals e.g. dummy father still counted paternal halfsibs. attempt made match dummies one pedigree individuals pedigree; use PedCompare. DumPrefix character vector prefixes identifying dummy individuals. Use 'F0' ('M0') avoid matching regular individuals IDs starting 'F' ('M'), provided Ped2 fewer 999 dummy females (males). Return return matrix Counts Summary number identical relationships mismatches per relationship, detailed results 2xNxN Array Dataframe. returns list four.","code":""},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Pairwise Relationships — ComparePairs","text":"Depending Return, one following, list : Counts (default), matrix counts, classification   Ped1 rows Ped2 columns. Counts   'symmetrical' pairs (\"FS\", \"HS\", \"MHS\", \"PHS\", \"FC1\", \"DFC1\", \"U\",\"X\")   divided two. Summary matrix one row per relationship type four columns     , named Ped1 true pedigree: n total number pairs relationship Ped1,         occurring Ped2 OK Number pairs relationship Ped2        Ped1 hi Number pairs 'higher' relationship Ped2        Ped1 (e.g. FS instead HS; ranking order given        ) lo Number pairs 'lower' relationship Ped2       Ped1, unrelated Ped2 Array 2xNxN array (Ped2 Pairs2 specified)     NxN matrix , N total number individuals occurring     Ped1 /Ped2. Dataframe dataframe \\(N^2\\) rows four columns: id.First individual pair id.B Second individual pair RC1 relationship category Ped1, factor         considered categories levels, including 0 count RC2 relationship category Ped2 pair listed twice, e.g. P O, twice FS.","code":""},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare Pairwise Relationships — ComparePairs","text":"Pairs2 returned GetMaybeRel   (identified additional column names 'LLR' 'OH'),   relationship categories appended '?' output,   distinguish derived Ped2. Pairs2$TopRel contains values ones listed among   return values combination patmat GenBack,   prioritised decreasing order factor levels, decreasing   alphabetical order, default (ped2 derived) levels. matrix returned DyadCompare [Deprecated] subset   matrix returned using default settings.","code":""},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"relationship-abbreviations-and-ranking","dir":"Reference","previous_headings":"","what":"Relationship abbreviations and ranking","title":"Compare Pairwise Relationships — ComparePairs","text":"default (GenBack=1, patmat=FALSE) following 7 relationships distinguished: S: Self (included Counts) MP: Parent O: Offspring (included Counts) FS: Full sibling HS: Half sibling U: Unrelated, otherwise related X: Either individuals occurring      pedigrees array dataframe, 'MP' indicates second (column) individual parent first (row) individual, 'O' indicates reverse. GenBack=1, patmat=TRUE categories (S)-M-P-(O)-FS-MHS-PHS- U-X. GenBack=2, patmat=TRUE, following relationships distinguished: S: Self (included Counts) M: Mother P: Father O: Offspring (included Counts) FS: Full sibling MHS: Maternal half-sibling PHS: Paternal half-sibling MGM: Maternal grandmother MGF: Maternal grandfather PGM: Paternal grandmother PGF: Paternal grandfather GO: Grand-offspring (included Counts) FA: Full avuncular; maternal paternal aunt uncle HA: Half avuncular FN: Full nephew/niece (included Counts) HN: Half nephew/niece (included Counts) FC1: Full first cousin DFC1: Double full first cousin U: Unrelated, otherwise related X: Either individuals occurring pedigrees Note avuncular cousin relationships distinction made paternal versus maternal, may differ two individuals generate large number sub-classes. pair related via multiple paths, first-listed relationship returned. get different paths pair, use GetRelM Return='Array'. GenBack=2, patmat=FALSE, MGM, MGF, PGM PGF combined GP, rest categories analogous .","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/ComparePairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Pairwise Relationships — ComparePairs","text":"","code":"PairsG <- ComparePairs(Ped_griffin, SeqOUT_griffin[[\"Pedigree\"]],                        patmat = TRUE, ExcludeDummies = TRUE, Return = \"All\") PairsG$Counts #>      Ped2 #> Ped1     M    P    O   FS  MHS  PHS    U    X #>   M     65    0    0    0    0    0    0  102 #>   P      0   79    0    0    0    0    0   84 #>   FS     0    0    0    5    0    0    0    0 #>   MHS    0    0    0    0   87    0    8  116 #>   PHS    0    0    0    0    0   76    6   72 #>   U      0    0    0    0    0    0 9685 9515 #>   X      0    0    0    0    0    0    0    0  # pairwise correct assignment rate: PairsG$Summary[,\"OK\"] / PairsG$Summary[,\"n\"] #>         M         P        FS       MHS       PHS         U  #> 1.0000000 1.0000000 1.0000000 0.9157895 0.9268293 1.0000000   # check specific pair: PairsG$Array[, \"i190_2010_M\", \"i168_2009_F\"] #> Ped1 Ped2  #>  \"M\"  \"X\"  # or RelDF <- PairsG$Dataframe   # for brevity RelDF[RelDF$id.A==\"i190_2010_M\" & RelDF$id.B==\"i168_2009_F\", ] #>              id.A        id.B Ped1 Ped2 #> 33590 i190_2010_M i168_2009_F    M    X  # Colony-style lists of full sib dyads & half sib dyads: FullSibDyads <- with(RelDF, RelDF[Ped1 == \"FS\" & id.A < id.B, ]) HalfSibDyads <- with(RelDF, RelDF[Ped1 == \"HS\" & id.A < id.B, ]) # Use 'id.A < id.B' because each pair is listed 2x"},{"path":"https://jiscah.github.io/reference/Conf_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example output from estimating confidence probabilities: griffins — Conf_griffin","title":"Example output from estimating confidence probabilities: griffins — Conf_griffin","text":"Example output EstConf, inferred   pedigree SeqOUT_griffin used reference pedigree.","code":""},{"path":"https://jiscah.github.io/reference/Conf_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example output from estimating confidence probabilities: griffins — Conf_griffin","text":"","code":"data(Conf_griffin)"},{"path":"https://jiscah.github.io/reference/Conf_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example output from estimating confidence probabilities: griffins — Conf_griffin","text":"list, see sequoia","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Conf_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example output from estimating confidence probabilities: griffins — Conf_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/Conf_griffin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example output from estimating confidence probabilities: griffins — Conf_griffin","text":"","code":"if (FALSE) { Conf_griffin <- EstConf(Pedigree = SeqOUT_griffin$Pedigree,                         LifeHistData = LH_griffin,                         args.sim = list(nSnp = 400, SnpError = 0.001,                                         ParMis=0.4),                         args.seq = list(Module = 'ped', Err=0.001),                         nSim = 20,                         nCores = 5,                         quiet = TRUE) }"},{"path":"https://jiscah.github.io/reference/CountAgeDif.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate Age Differences — CountAgeDif","title":"Tabulate Age Differences — CountAgeDif","text":"Count . pairs per age difference birth years. Quicker   table(outer()).","code":""},{"path":"https://jiscah.github.io/reference/CountAgeDif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate Age Differences — CountAgeDif","text":"","code":"CountAgeDif(BirthYear, BYrange = range(BirthYear))"},{"path":"https://jiscah.github.io/reference/CountAgeDif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate Age Differences — CountAgeDif","text":"BirthYear numeric vector birth years. BYrange range limit counts .","code":""},{"path":"https://jiscah.github.io/reference/DoErrors.html","id":null,"dir":"Reference","previous_headings":"","what":"Fortran Simulate Genotyping Errors — DoErrors","title":"Fortran Simulate Genotyping Errors — DoErrors","text":"Wrapper Fortran function simulate genotyping errors.","code":""},{"path":"https://jiscah.github.io/reference/DoErrors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fortran Simulate Genotyping Errors — DoErrors","text":"","code":"DoErrors(SGeno, Act2Obs)"},{"path":"https://jiscah.github.io/reference/DoErrors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fortran Simulate Genotyping Errors — DoErrors","text":"SGeno matrix genotype data, size nInd x nSnp. Act2Obs array conditional probability observing genotype conditional actual genotype j, size nSnp x 3 x 3.","code":""},{"path":"https://jiscah.github.io/reference/DoErrors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fortran Simulate Genotyping Errors — DoErrors","text":"SGeno errors.","code":""},{"path":"https://jiscah.github.io/reference/DuplicateCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Data for Duplicates. — DuplicateCheck","title":"Check Data for Duplicates. — DuplicateCheck","text":"Check genotype life history data duplicate IDs (  permitted) duplicated genotypes (advised), count many   individuals genotype data included life history data   (permitted). order IDs genotype life history data   required identical.","code":""},{"path":"https://jiscah.github.io/reference/DuplicateCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Data for Duplicates. — DuplicateCheck","text":"","code":"DuplicateCheck(GenoM = NULL, FortPARAM.dup, quiet)"},{"path":"https://jiscah.github.io/reference/DuplicateCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Data for Duplicates. — DuplicateCheck","text":"GenoM matrix genotype data, size nInd x nSnp. FortPARAM.dup list Fortran-ready parameter values, generated MkFortParams. quiet suppress messages.","code":""},{"path":"https://jiscah.github.io/reference/DuplicateCheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Data for Duplicates. — DuplicateCheck","text":"list one following elements: DupGenoID Dataframe, row numbers duplicated IDs genotype data.   Please remove relabel avoid downstream confusion. DupGenotype Dataframe, duplicated genotypes (without identical   IDs). specified number maximum mismatches allowed,   dataframe may include pairs closely related individuals. Mismatch =   number SNPs genotypes differ, LLR = likelihood ratio   'self' likely non-self.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/DyadCompare.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Dyads (DEPRECATED) — DyadCompare","title":"Compare Dyads (DEPRECATED) — DyadCompare","text":"Count number half full sibling pairs correctly   incorrectly assigned. DEPRECATED - PLEASE USE ComparePairs","code":""},{"path":"https://jiscah.github.io/reference/DyadCompare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Dyads (DEPRECATED) — DyadCompare","text":"","code":"DyadCompare(Ped1 = NULL, Ped2 = NULL, na1 = c(NA, \"0\"))"},{"path":"https://jiscah.github.io/reference/DyadCompare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Dyads (DEPRECATED) — DyadCompare","text":"Ped1 original pedigree, dataframe 3 columns: id-dam-sire. Ped2 second (inferred) pedigree. na1 value missing parents Ped1.","code":""},{"path":"https://jiscah.github.io/reference/DyadCompare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Dyads (DEPRECATED) — DyadCompare","text":"3x3 table number pairs assigned full siblings (FS),   half siblings (HS) unrelated (U, including otherwise related) two   pedigrees, classification Ped1 rows Ped2   columns.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/DyadCompare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Dyads (DEPRECATED) — DyadCompare","text":"","code":"if (FALSE) { DyadCompare(Ped1=Ped_HSg5, Ped2=SeqOUT_HSg5$Pedigree) }"},{"path":"https://jiscah.github.io/reference/ErrPerSNP.html","id":null,"dir":"Reference","previous_headings":"","what":"wrapper for Fortran function to estimate error rate for each SNP — ErrPerSNP","title":"wrapper for Fortran function to estimate error rate for each SNP — ErrPerSNP","text":"WARNING: precise, especially low error rates.","code":""},{"path":"https://jiscah.github.io/reference/ErrPerSNP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"wrapper for Fortran function to estimate error rate for each SNP — ErrPerSNP","text":"","code":"ErrPerSNP(Er_hat, GenoM, Parents, DupsV)"},{"path":"https://jiscah.github.io/reference/ErrPerSNP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"wrapper for Fortran function to estimate error rate for each SNP — ErrPerSNP","text":"Er_hat length 3 vector genotyping error rates GenoM Genotype matrix Parents Pedigree, already converted rownumbers GenoM DupsV vector duplicate samples, already converted rownumbers","code":""},{"path":"https://jiscah.github.io/reference/ErrPerSNP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"wrapper for Fortran function to estimate error rate for each SNP — ErrPerSNP","text":"matrix 3 columns: SNP probabilities (observed given   actual) hom|hom, het|hom, hom|het.","code":""},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Genotyping Error Matrix — ErrToM","title":"Generate Genotyping Error Matrix — ErrToM","text":"Make vector matrix specifying genotyping error   pattern, function generate vector/matrix single   value Err. probabilities observed genotypes   (columns) conditional actual genotypes (rows), return function   generate matrices (using single value Err input  function).","code":""},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Genotyping Error Matrix — ErrToM","text":"","code":"ErrToM(Err = NA, flavour = \"version2.9\", Return = \"matrix\")"},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Genotyping Error Matrix — ErrToM","text":"Err estimated genotyping error rate, single number, 3x3 4x4 matrix, length 3 vector. single number, error model used aims deal scoring errors typical SNP arrays. matrix, probability observed genotype (columns) conditional actual genotype (rows). row must therefore sum 1. Return='function', may NA. vector, probabilities (observed given actual) hom|hom, het|hom, hom|het. flavour vector-generating matrix-generating function, one 'version2.9', 'version2.0', 'version1.3' (='SNPchip'), 'version1.1' (='version111'), referring sequoia version used default. used Err single number. Return output, 'matrix' (default), 'vector', 'function' (matrix-generating), 'v_function' (vector-generating)","code":""},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Genotyping Error Matrix — ErrToM","text":"Depending Return, either:  'matrix': 3x3 matrix, probabilities observed genotypes    (columns) conditional actual (rows) 'function': function taking single value Err input,    generating 3x3 matrix 'vector': length 3 vector, probabilities (observed given      actual) hom|hom, het|hom, hom|het.","code":""},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Genotyping Error Matrix — ErrToM","text":"default (flavour = \"version2.9\"), Err   interpreted locus-level error rate (rather allele-level),   equals probability actual heterozygote observed either   homozygote (.e., probability observed AA = probability   observed aa = Err/2). probability one homozygote   observed (Err/2\\()^2\\). inbuilt 'flavours' correspond presumed simulated error structures, changed sequoia versions. appropriate error structure depend genotyping platform; 'version0.9' 'version1.1' inspired SNP array genotyping 'version1.3' 'version2.0' intended general. flavours assume two alleles $$ $$ equivalent, .e. $P(AA|aa) = P(aa|AA)$, $P(aa|Aa)=P(AA|Aa)$, $P(aA|aa)=P(aA|AA)$. matrix form, Pr(observed genotype (columns) | actual genotype (rows)): version2.9: version2.0: version1.3 version1.1 version0.9 (recommended) Err length 3 vector, Return = 'vector'  following probabilities: hom|hom: actual homozygote observed homozygote het|hom: actual homozygote observed heterozygote hom|het: actual heterozygote observed homozygote Pr(observed genotype (columns) | actual genotype (rows)) : assumption made two alleles can treated equally,  .e. observing actual allele $$ $$ likely observing actual $$  $$, e.g. P(obs=1|act=0) = P(obs=1|act=2). SNPs scored via sequencing (e.g. RADseq DArTseq), 3rd  error rate (hom|het) typically considerably higher two,  SNP arrays tends similar P(het|hom).","code":""},{"path":"https://jiscah.github.io/reference/ErrToM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Genotyping Error Matrix — ErrToM","text":"","code":"ErM <- ErrToM(Err = 0.05) ErM #>       obs-0|act obs-1|act obs-2|act #> act-0  0.950000  0.049375  0.000625 #> act-1  0.025000  0.950000  0.025000 #> act-2  0.000625  0.049375  0.950000 ErrToM(ErM, Return = 'vector') #>  hom|hom  het|hom  hom|het  #> 0.000625 0.049375 0.025000    # use error matrix from Whalen, Gorjanc & Hickey 2018 funE <- function(E) {  matrix(c(1-E*3/4, E/2, E/4,           E/4, 1-2*E/4, E/4,           E/4, E/2, 1-E*3/4),           3,3, byrow=TRUE)  } ErrToM(Err = 0.05, flavour = funE) #>       obs-0|act obs-1|act obs-2|act #> act-0    0.9625     0.025    0.0125 #> act-1    0.0125     0.975    0.0125 #> act-2    0.0125     0.025    0.9625 # equivalent to: ErrToM(Err = c(0.05/4, 0.05/2, 0.05/4)) #>       obs-0|act obs-1|act obs-2|act #> act-0    0.9625     0.025    0.0125 #> act-1    0.0125     0.975    0.0125 #> act-2    0.0125     0.025    0.9625"},{"path":"https://jiscah.github.io/reference/EstConf.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence Probabilities — EstConf","title":"Confidence Probabilities — EstConf","text":"Estimate confidence probabilities ('backward') assignment   error rates ('forward') per category (genotyped/dummy) repeatedly   simulating genotype data reference pedigree using   SimGeno, reconstruction pedigree using   sequoia, counting number mismatches using   PedCompare.","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence Probabilities — EstConf","text":"","code":"EstConf(   Pedigree = NULL,   LifeHistData = NULL,   args.sim = list(nSnp = 400, SnpError = 0.001, ParMis = c(0.4, 0.4)),   args.seq = list(Module = \"ped\", Err = 0.001, Tassign = 0.5, CalcLLR = FALSE),   nSim = 10,   nCores = 1,   quiet = TRUE )"},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence Probabilities — EstConf","text":"Pedigree reference pedigree simulate, dataframe columns id-dam-sire. Additional columns ignored. LifeHistData dataframe id, sex (1=female, 2=male, 3=unknown), birth year, optionally .min - .max - YearLast. args.sim list arguments pass SimGeno, nSnp (number SNPs), SnpError (genotyping error rate) ParMis (proportion non-genotyped parents). Set NULL use default values. args.seq list arguments pass sequoia, Module ('par' 'ped'), Err (assumed genotyping error rate), Complex. May include (part ) SeqList, list sequoia output (.e. list-within--list). Set NULL use default values. nSim number iterations simulate - reconstruct - compare perform, .e. number simulated datasets. nCores number computer cores use. >1, package parallel used. Set NULL use one available cores, detected parallel::detectCores() (using cores tends freeze computer). quiet suppress messages. TRUE runs SimGeno sequoia quietly, '' also suppresses messages iteration counter nCores=1 (iteration counter nCores>1).","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence Probabilities — EstConf","text":"list, elements: ConfProb See PedErrors See Pedigree.reference pedigree data simulated LifeHistData  Pedigree.inferred list iteration inferred     pedigree based simulated data SimSNPd list iteration IDs individuals     simulated genotyped PedComp.fwd array Counts 'forward'     PedCompare, PedErrors calculated RunParams list call EstConf semi-nested   list (args.sim, args.seq, nSim, nCores), well default parameter   values SimGeno sequoia. RunTime sequoia runtime per simulation seconds,     measured system.time()['elapsed']. Dataframe ConfProb 7 columns: id.cat, dam.cat, sire.cat Category focal individual, dam,   sire, pedigree inferred based simulated data. Coded   G=genotyped, D=dummy, X=none dam.conf Probability dam correct, given categories   assigned dam sire (ignoring whether sire correct) sire.conf dam.conf, sire pair.conf Probability dam sire correct, given   categories N Number individuals per category-combination, across   nSim iterations Array PedErrors three dimensions: class FalseNeg(atives): assigned (individual + parent genotyped dummyfiable; P1only PedCompare). FalsePos(itives): parent reference pedigree, one assigned based simulated data (P2only) Mismatch: different parents pedigrees cat Category individual + parent, two-letter code   first letter indicates focal individual second parent;   G=Genotyped, D=Dummy, T=Total parent dam sire","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confidence Probabilities — EstConf","text":"confidence probability taken number correct   (matching) assignments, divided assignments made   observed (inferred--simulated) pedigree. contrast, false   negative & false positive assignment rates proportions number   parents true (reference) pedigree. rate calculated   separatedly dams & sires, separately category   (Genotyped/Dummy(fiable)/X (none))   individual, parent co-parent. function know individuals actual Pedigree  genotyped, confidence probabilities need added  Pedigree shown example bottom. confidence \\(1\\) means assignments simulated data correct  category-combination. interpreted (perhaps modified  ) \\(> 1 - 1/N\\), sample size N given last column  ConfProb PedErrors dataframes output.  applies false negative/positive rate \\(0\\) (.e.  interpreted \\(< 1/N\\)).","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"assumptions","dir":"Reference","previous_headings":"","what":"Assumptions","title":"Confidence Probabilities — EstConf","text":"actual true pedigree (typically) unknown, provided   reference pedigree used stand-assumed true   pedigree, unrelated founders. also assumed probability   genotyped equal parents; iteration, new random   set parents (proportion set ParMis) mimicked   non-genotyped. addition, SNPs assumed segregate independently. experimental version offering fine-grained control available   https://github.com/JiscaH/sequoiaExtra .","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"object-size","dir":"Reference","previous_headings":"","what":"Object size","title":"Confidence Probabilities — EstConf","text":"size Kb returned list can become pretty big,   inferred pedigrees included. running EstConf many times   range parameter values, may prudent save required summary   statistics run rather full output.","code":""},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"errors","dir":"Reference","previous_headings":"","what":"Errors","title":"Confidence Probabilities — EstConf","text":"large pedigree try run function multiple   cores, may run \"allocate vector size ...\" errors even   unexpected crashes: enough computer memory separate   run. Try reducing `nCores`.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/EstConf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence Probabilities — EstConf","text":"","code":"# estimate proportion of parents that are genotyped (= 1 - ParMis) sumry_grif <- SummarySeq(SeqOUT_griffin, Plot=FALSE) tmp <- apply(sumry_grif$ParentCount['Genotyped',,,],              MARGIN = c('parentSex', 'parentCat'), FUN = sum) props <- sweep(tmp, MARGIN='parentCat', STATS = rowSums(tmp), FUN = '/') 1 - props[,'Genotyped'] / (props[,'Genotyped'] + props[,'Dummy']) #>       Dam      Sire  #> 0.3867925 0.2178218   # Example for parentage assignment only conf_grif <- EstConf(Pedigree = SeqOUT_griffin$Pedigree,                LifeHistData = SeqOUT_griffin$LifeHist,                args.sim = list(nSnp = 150,   # no. in actual data, or what-if                                SnpError = 5e-3,  # best estimate, or what-if                                CallRate=0.9,     # from SnpStats()                                ParMis=c(0.39, 0.20)),  # calc'd above                args.seq = list(Err=5e-3, Module=\"par\"),  # as in real run                nSim = 1,   # try-out, proper run >=20 (10 if huge pedigree)                nCores=1) #> Simulating parentage assignment only ... #> i= 1 \t 14:08:44  #> Warning:  There are 1 SNPs scored for <50% of individuals   # parent-pair confidence, per category (Genotyped/Dummy/None) conf_grif$ConfProb #>    id.cat dam.cat sire.cat dam.conf sire.conf pair.conf  N #> 14      G       G        G        1         1         1 90 #> 15      G       G        X        1        NA        NA 24 #> 17      G       X        G       NA         1        NA  6 #> 18      G       X        X       NA        NA        NA 40  # Proportion of true parents that was correctly assigned 1 - apply(conf_grif$PedErrors, MARGIN=c('cat','parent'), FUN=sum, na.rm=TRUE) #>     parent #> cat    dam      sire #>   GG 0.950 0.9795918 #>   GD 1.000 0.0000000 #>   GT 0.950 0.8275862 #>   DG 0.000 0.0000000 #>   DD 1.000 0.0000000 #>   DT 0.000 0.0000000 #>   TT 0.912 0.7868852  # add columns with confidence probabilities to pedigree # first add columns with category (G/D/X) Ped.withConf <- getAssignCat(Pedigree = SeqOUT_griffin$Pedigree,                              SNPd = SeqOUT_griffin$PedigreePar$id) Ped.withConf <- merge(Ped.withConf, conf_grif$ConfProb, all.x=TRUE,                       sort=FALSE)  # (note: merge() messes up column order) head(Ped.withConf[Ped.withConf$dam.cat==\"G\", ]) #>    id.cat dam.cat sire.cat          id         dam        sire LLRdam LLRsire #> 31      G       G        G i025_2002_M i014_2001_F i018_2001_M   8.34    7.65 #> 32      G       G        G i110_2006_M i061_2004_F i073_2004_M  10.46    6.15 #> 33      G       G        G i145_2008_F i132_2007_F i127_2007_M   6.69    7.83 #> 34      G       G        G i050_2003_M i033_2002_F i028_2002_M   7.15    5.91 #> 35      G       G        G i080_2004_M i041_2003_F i039_2002_M   8.61    3.22 #> 36      G       G        G i136_2007_M i095_2005_F i089_2005_M   8.97   11.15 #>    LLRpair OHdam OHsire MEpair dam.conf sire.conf pair.conf  N #> 31   17.42     0      0      0        1         1         1 90 #> 32   18.34     0      0      0        1         1         1 90 #> 33   15.94     0      0      0        1         1         1 90 #> 34   16.04     0      0      0        1         1         1 90 #> 35   17.62     1      0      1        1         1         1 90 #> 36   15.77     0      0      0        1         1         1 90  # save output summary if (FALSE) { conf_griff[['Note']] <- 'You could add a note' saveRDS(conf_grif[c('ConfProb','PedComp.fwd','RunParams','RunTime','Note')],    file = 'conf_200SNPs_Err005_Callrate80.RDS') }  ## P(actual FS | inferred as FS) etc. if (FALSE) { PairL <- list() for (i in 1:length(conf_grif$Pedigree.inferred)) {  # nSim   cat(i, \"\\t\")   PairL[[i]] <- ComparePairs(conf_grif$Pedigree.reference,                              conf_grif$Pedigree.inferred[[i]],                              GenBack=1, patmat=TRUE, ExcludeDummies = TRUE,                              Return=\"Counts\") } # P(actual relationship (Ped1) | inferred relationship (Ped2)) PairRel.prop.A <- plyr::laply(PairL, function(M)                      sweep(M, MARGIN='Ped2', STATS=colSums(M), FUN=\"/\")) PairRel.prop <- apply(PairRel.prop.A, 2:3, mean, na.rm=TRUE) #avg across sims round(PairRel.prop, 3) # or: P(inferred relationship | actual relationship) PairRel.prop2 <- plyr::laply(PairL, function(M)    sweep(M, MARGIN='Ped1', STATS=rowSums(M), FUN=\"/\")) }  if (FALSE) { # confidence probability vs. sibship size source('https://raw.githubusercontent.com/JiscaH/sequoiaExtra/main/conf_vs_sibsize.R') conf_grif_nOff <- Conf_by_nOff(conf_grif) conf_grif_nOff['conf',,'GD',] conf_grif_nOff['N',,'GD',] }"},{"path":"https://jiscah.github.io/reference/EstEr.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"Estimate genotyping error rates SNP data, based   pedigree /duplicates. Estimates probabilities (observed given   actual) hom|hom, het|hom, hom|het. APPROXIMATE VALUES!","code":""},{"path":"https://jiscah.github.io/reference/EstEr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"","code":"EstEr(   GenoM,   Pedigree,   Duplicates = NULL,   Er_start = c(0.05, 0.05, 0.05),   perSNP = FALSE )"},{"path":"https://jiscah.github.io/reference/EstEr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"GenoM Genotype matrix Pedigree data.frame columns id - dam - sire Duplicates matrix data.frame 2 columns, id1 & id2 Er_start vector length 3 starting values optim. perSNP logical, estimate error rate per SNP. WARNING precise, use approximate indicator! Try simulated data first, e.g. SimGeno.","code":""},{"path":"https://jiscah.github.io/reference/EstEr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"vector length 3 estimated genotyping error rates:  probabilities hom|hom: actual homozygote observed homozygote het|hom: actual homozygote observed heterozygote hom|het: actual heterozygote observed homozygote three independent parameters, define genotyping error  matrix (see ErrToM) follows: Note optim lower bound 1e-6 upper bound 0.499  used; values returned interpreted  'inestimably small' 'inestimably large', respectively. PLEASE USE  VALUES INPUT SUBSEQUENT ANALYSIS SUBSITUTE SENSIBLE  VALUE!!","code":""},{"path":"https://jiscah.github.io/reference/EstEr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"result interpreted approximate, ballpark estimates! estimated error rates pedigree accurate duplicate samples. Errors individuals without parents offspring counted, errors individuals offspring may noted either. Deviation genotype frequencies among founders Hardy-Weinberg equilibrium may wrongly attributed genotyping errors. Last least, pedigree errors result higher estimated genotyping errors.","code":""},{"path":"https://jiscah.github.io/reference/EstEr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate genotyping error rate (REMOVED; will be re-implemented) — EstEr","text":"","code":"GenoX <- SimGeno(Ped_griffin, nSnp=400, SnpError=c(0.01,0.07, 0.1),                 ParMis=0.1, CallRate=0.9) # EstEr(GenoM=GenoX, Pedigree=Ped_griffin)"},{"path":"https://jiscah.github.io/reference/EstErr.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Genotyping Error Rate — EstErr","title":"Estimate Genotyping Error Rate — EstErr","text":"Estimate genotyping error rate Mendelian errors per SNP.","code":""},{"path":"https://jiscah.github.io/reference/EstErr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Genotyping Error Rate — EstErr","text":"","code":"EstErr(GenoM, Par, ErrFlavour = \"version2.0\")"},{"path":"https://jiscah.github.io/reference/EstErr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Genotyping Error Rate — EstErr","text":"GenoM genotype matrix, sequoia's format: 1 column per SNP, 1 row per individual, genotypes coded 0/1/2/-9, rownames giving individual IDs. Par pedigree dataframe, genotyped parents used. ErrFlavour function takes genotyping error rate Err input, returns 3x3 matrix observed (columns) conditional actual (rows) genotypes, choose inbuilt ones used sequoia 'version2.0', 'version1.3', 'version1.1'. See ErrToM.","code":""},{"path":"https://jiscah.github.io/reference/EstErr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Genotyping Error Rate — EstErr","text":"dataframe columns: Err.hat Error rate, estimated joined offspring-parent   (-parent) genotypes presumed error structure (ErrFlavour) n.dam, n.sire, n.pair Number dams, sires, parent-pairs succesfully   genotyped SNP OHdam, OHsire Count number opposing homozygous cases MEpair Count Mendelian errors, includes opposing homozygous cases","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/FieldMums_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example field-observed mothers: griffins — FieldMums_griffin","title":"Example field-observed mothers: griffins — FieldMums_griffin","text":"Example field pedigree used vignette   PedCompare example. Non-genotyped females IDs 'BlueRed',   'YellowPink', etc.","code":""},{"path":"https://jiscah.github.io/reference/FieldMums_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example field-observed mothers: griffins — FieldMums_griffin","text":"","code":"data(FieldMums_griffin)"},{"path":"https://jiscah.github.io/reference/FieldMums_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example field-observed mothers: griffins — FieldMums_griffin","text":"data frame 144 rows 2 variables (id, mum)","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/FieldMums_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example field-observed mothers: griffins — FieldMums_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/FieldMums_griffin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example field-observed mothers: griffins — FieldMums_griffin","text":"","code":"if (FALSE) { PC_griffin <- PedCompare(Ped1 = cbind(FieldMums_griffin, sire=NA),                          Ped2 = SeqOUT_griffin$Pedigree) }"},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign Family IDs — FindFamilies","title":"Assign Family IDs — FindFamilies","text":"Find clusters connected individuals pedigree, assign   cluster unique family ID (FID).","code":""},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign Family IDs — FindFamilies","text":"","code":"FindFamilies(Pedigree = NULL, SeqList = NULL, MaybeRel = NULL)"},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign Family IDs — FindFamilies","text":"Pedigree dataframe columns id - parent1 - parent2; first 3 columns used. SeqList list returned sequoia. Pedigree provided, element Pedigree list used present, element Pedigreepar otherwise. MaybeRel Output GetMaybeRel, dataframe probable non-assigned relatives.","code":""},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign Family IDs — FindFamilies","text":"numeric vector length equal number unique   individuals pedigree (.e. number rows pedigree running  PedPolish Pedigree).","code":""},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assign Family IDs — FindFamilies","text":"function repeatedly finds ancestors descendants  individual turn, ensures Family ID.  connected individuals related, e.g. grandparents  individual FID, typically unrelated. UseMaybeRel = TRUE, probable relatives added existing family clusters, existing family clusters may linked together. Currently additional family clusters created.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/FindFamilies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign Family IDs — FindFamilies","text":"","code":"PedG <- SeqOUT_griffin$PedigreePar[,1:3] FID_G <- FindFamilies(PedG) PedG[FID_G==4,] #>             id         dam        sire #> 6  i014_2001_F        <NA>        <NA> #> 10 i018_2001_M        <NA>        <NA> #> 15 i025_2002_M i014_2001_F i018_2001_M #> 37 i057_2003_M        <NA> i018_2001_M #> 53 i078_2004_M        <NA> i025_2002_M #> 64 i094_2005_M        <NA> i078_2004_M #> 93 i135_2007_F        <NA> i078_2004_M"},{"path":"https://jiscah.github.io/reference/FoldSibGPs.html","id":null,"dir":"Reference","previous_headings":"","what":"Fold IDs of Sibship Grandparents — FoldSibGPs","title":"Fold IDs of Sibship Grandparents — FoldSibGPs","text":"Fold IDs sibship grandparents 2 x nInd/2 x 2 array,   stored Fortran, stretch vector can   passed Fortran easily transformed back said 3D array.","code":""},{"path":"https://jiscah.github.io/reference/FoldSibGPs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fold IDs of Sibship Grandparents — FoldSibGPs","text":"","code":"FoldSibGPs(PedNum, Ng, Nd)"},{"path":"https://jiscah.github.io/reference/FoldSibGPs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fold IDs of Sibship Grandparents — FoldSibGPs","text":"PedNum pedigree, ids replaced numbers, dummies negative. Ng . genotyped indivs. Nd length 2 vector, . female & male dummies.","code":""},{"path":"https://jiscah.github.io/reference/FoldSibGPs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fold IDs of Sibship Grandparents — FoldSibGPs","text":"integer vector, missing values 0.","code":""},{"path":"https://jiscah.github.io/reference/FortifyPairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Pairs Fortran Compatible — FortifyPairs","title":"Make Pairs Fortran Compatible — FortifyPairs","text":"Convert dataframe Pairs list integer vectors.   Called CalcPairLL.","code":""},{"path":"https://jiscah.github.io/reference/FortifyPairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Pairs Fortran Compatible — FortifyPairs","text":"","code":"FortifyPairs(Pairs, gID, Renamed, LH)"},{"path":"https://jiscah.github.io/reference/FortifyPairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Pairs Fortran Compatible — FortifyPairs","text":"Pairs dataframe columns ID1 - ID2 - Sex1 - Sex2 - AgeDif - focal - k. gID character vector IDs genotyped individuals. Renamed length-2 list (dams, sires) 2-column dataframe. matching character IDs negative numbers, dummified individuals. Element list returned PedToNum. LH lifehistory dataframe, ID - Sex - BirthYear.","code":""},{"path":"https://jiscah.github.io/reference/FortifyPairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Pairs Fortran Compatible — FortifyPairs","text":"named list, elements ID - Sex - AgeDif - focal. first two   per individual thus length 2*nrow(Pairs), last   two length 1*nrow(Pairs).","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Genotype Data — GenoConvert","title":"Convert Genotype Data — GenoConvert","text":"Convert genotype data various formats sequoia's   1-column-per-marker format Colony's 2-columns-per-marker format.","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Genotype Data — GenoConvert","text":"","code":"GenoConvert(   InData = NULL,   InFile = NULL,   InFormat = \"raw\",   OutFile = NA,   OutFormat = \"seq\",   Missing = c(\"-9\", \"??\", \"?\", \"NA\", \"NULL\", \"-1\", c(\"0\")[InFormat %in% c(\"col\",     \"ped\")]),   sep = c(\" \", \"\\t\", \",\", \";\"),   header = NA,   IDcol = NA,   FIDcol = NA,   FIDsep = \"__\",   dropcol = NA,   quiet = FALSE )"},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Genotype Data — GenoConvert","text":"InData dataframe matrix genotypes converted. InFile character string name genotype file converted. InFormat One 'single', 'double', 'col', 'ped', 'raw', 'seq', see Details. OutFile character string name converted file. NA, return matrix genotypes console (default); NULL, write 'GenoForSequoia.txt' current working directory. OutFormat InFormat; 'seq', 'col', 'ped' implemented. 'ped' also sham .map file created, file can read PLINK. 'ped' extensions .ped & .map added specified OutFile filename. Missing vector symbols interpreted missing data. '0' missing data InFormats 'col' 'ped' . sep vector field separator strings tried InFile. OutFile separator uses write.table default, .e. one blank space. header logical value indicating whether file contains header first line. NA (default), set TRUE 'raw', FALSE otherwise. IDcol number giving column individual IDs; 0 indicates rownames (InData ). NA (default), set 2 InFormat 'raw' 'ped', otherwise 1 InFile 0 (rownames) InData, except InData column labeled 'ID'. FIDcol column family IDs, wished used. column 1 InFormat 'raw' 'seq', default used. FIDsep string used paste FID IID together composite-ID (value passed paste's collapse). joining can reversed using PedStripFID. dropcol columns exclude output data, top IDcol FIDcol (become rownames). NA, defaults columns 3-6 InFormat 'raw' 'seq'. Can also used drop SNPs, see example 2-columns-per-SNP input formats. quiet suppress messages warnings.","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Genotype Data — GenoConvert","text":"genotype matrix specified output format. 'OutFile'   specified, matrix written file nothing returned   inside R. converting 0/1/2 format, 2 homozygote   minor allele, 0 homozygote major allele.","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Genotype Data — GenoConvert","text":"first two arguments interchangeable, can given   unnamed. first argument assumed file name class   'character' length 1, genetic data matrix   dataframe.","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"input-formats","dir":"Reference","previous_headings":"","what":"Input formats","title":"Convert Genotype Data — GenoConvert","text":"following formats can specified InFormat: seq (sequoia) genotypes coded 0, 1, 2, missing \\(-9\\),   1 column per marker. Column 1 contains IDs, header row. raw (PLINK) genotypes coded 0, 1, 2, missing NA, 1   column per marker. first 6 columns descriptive (1:FID, 2:IID, 3   6 ignored), header row. produced PLINK's option   --recodeA ped (PLINK) genotypes coded , C, T, G, missing 0, 2   columns per marker. first 6 columns descriptive (1:FID, 2:IID, 3   6 ignored). col (Colony) genotypes coded numeric values, missing 0,   2 columns per marker. Column 1 contains IDs. single 1 column per marker, otherwise unspecified double 2 columns per marker, otherwise unspecified InFormat, default values Missing, header,  IDcol, FIDcol, dropcol can overruled specifying  corresponding input parameters.","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"error-messages","dir":"Reference","previous_headings":"","what":"Error messages","title":"Convert Genotype Data — GenoConvert","text":"Occasionally reading file GenoConvert may give error   'rows unequal length'. GenoConvert makes use   readLines strsplit, much faster   read.table large datafiles, also sensitive   unusual line endings, unusual end--file characters, invisible   characters (spaces tabs) end lines. cases,   try read data file using read.table read.csv, use   GenoConvert dataframe matrix, see example.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert Genotype Data — GenoConvert","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/GenoConvert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Genotype Data — GenoConvert","text":"","code":"if (FALSE) { # Requires PLINK installed & in system PATH:  # tinker with window size, window overlap and VIF to get a set of # 400 - 800 markers (100-200 enough for just parentage): system(\"cmd\", input = \"plink --file mydata --indep 50 5 2\") system(\"cmd\", input = \"plink --file mydata --extract plink.prune.in   --recodeA --out PlinkOUT\")  GenoM <- GenoConvert(InFile = \"PlinkOUT.raw\")  # save time on file conversion next time: write.table(GenoM, file=\"Geno_sequoia.txt\", quote=FALSE, col.names=FALSE) GenoM <- as.matrix(read.table(\"Geno_sequoia.txt\", row.names=1, header=FALSE))  # drop some SNPs, e.g. after a warning of >2 alleles: dropSNP <- c(5,68,101,128) GenoM <- GenoConvert(ColonyFile, InFormat = \"col\",                      dropcol = 1 + c(2*dropSNP-1, 2*dropSNP) )  # circumvent a 'rows have unequal length' error: GenoTmp <- as.matrix(read.table(\"mydata.txt\", header=TRUE, row.names=1)) GenoM <- GenoConvert(InData=GenoTmp, InFormat=\"single\", IDcol=0) }"},{"path":"https://jiscah.github.io/reference/Geno_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example genotype file: Griffins — Geno_griffin","title":"Example genotype file: Griffins — Geno_griffin","text":"Simulated genotype data Pedigree Ped_griffin","code":""},{"path":"https://jiscah.github.io/reference/Geno_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example genotype file: Griffins — Geno_griffin","text":"","code":"data(Geno_griffin)"},{"path":"https://jiscah.github.io/reference/Geno_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example genotype file: Griffins — Geno_griffin","text":"genotype matrix 142 rows (individuals) 200 columns (SNPs).   SNP coded 0/1/2 copies reference allele, -9   missing values. Ids stored rownames.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Geno_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example genotype file: Griffins — Geno_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/Geno_HSg5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example genotype file: 'HSg5' — Geno_HSg5","title":"Example genotype file: 'HSg5' — Geno_HSg5","text":"Simulated genotype data * individuals Pedigree   Ped_HSg5 (*: 40","code":""},{"path":"https://jiscah.github.io/reference/Geno_HSg5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example genotype file: 'HSg5' — Geno_HSg5","text":"","code":"data(Geno_HSg5)"},{"path":"https://jiscah.github.io/reference/Geno_HSg5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example genotype file: 'HSg5' — Geno_HSg5","text":"genotype matrix 920 rows (ids) 200 columns (SNPs).   SNP coded 0/1/2 copies reference allele, -9 missing   values. Ids stored rownames.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Geno_HSg5.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example genotype file: 'HSg5' — Geno_HSg5","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/Geno_HSg5.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example genotype file: 'HSg5' — Geno_HSg5","text":"","code":"if (FALSE) { # this output was created as follows: Geno_HSg5 <- SimGeno(Ped = Ped_HSg5, nSnp = 200, ParMis=0.4,                      CallRate = 0.9, SnpError = 0.005) }"},{"path":"https://jiscah.github.io/reference/GetAncestors.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ancestors — GetAncestors","title":"Get ancestors — GetAncestors","text":"get ancestors individual","code":""},{"path":"https://jiscah.github.io/reference/GetAncestors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ancestors — GetAncestors","text":"","code":"GetAncestors(id, Pedigree)"},{"path":"https://jiscah.github.io/reference/GetAncestors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ancestors — GetAncestors","text":"id id individual Pedigree dataframe columns id - parent1 - parent2; first 3 columns used.","code":""},{"path":"https://jiscah.github.io/reference/GetAncestors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ancestors — GetAncestors","text":"list first element id, second parents, third  grandparents, etc.. element vector ids, first three  elements named, rest numbered. Ancestors unsorted within  list element.","code":""},{"path":"https://jiscah.github.io/reference/GetAncestors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get ancestors — GetAncestors","text":"","code":"Anc_i200  <- GetAncestors('i200_2010_F', Ped_griffin)"},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":null,"dir":"Reference","previous_headings":"","what":"Assignability of Reference Pedigree — getAssignCat","title":"Assignability of Reference Pedigree — getAssignCat","text":"Identify individuals SNP genotyped, can   potentially substituted dummy individual ('Dummifiable').","code":""},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assignability of Reference Pedigree — getAssignCat","text":"","code":"getAssignCat(Pedigree, SNPd, minSibSize = \"1sib1GP\")"},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assignability of Reference Pedigree — getAssignCat","text":"Pedigree dataframe columns id-dam-sire. Reference pedigree. SNPd character vector ids genotyped individuals. minSibSize minimum requirements considered 'dummifiable': '1sib' : sibship size 1, .e. non-genotyped individual       least 1 genotyped offspring. sibship-grandparent       really sibship, can useful situations.       Used CalcOHLLR. '1sib1GP': sibship size 1 least 1 genotyped       grandparent. minimum potentially assignable       sequoia. '2sib': least 2 siblings, without grandparents. Used        PedCompare. .","code":""},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assignability of Reference Pedigree — getAssignCat","text":"Pedigree dataframe 3 additional columns,  id.cat, dam.cat sire.cat, coding similar   used PedCompare: G Genotyped D Dummy 'dummifiable' X genotyped dummifiable, parent pedigree","code":""},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assignability of Reference Pedigree — getAssignCat","text":"assumed individuals SNPd   genotyped sufficient number SNPs. identify samples   -low call rate, use CheckGeno. calculate call rate   samples, see examples . parents indicated assignable may never assigned sequoia,   example parent-offspring pairs determined   older two, grandparents indistinguishable full   avuncular (.e. genetics inconclusive candidate parent   assigned, ageprior inconclusive).","code":""},{"path":"https://jiscah.github.io/reference/getAssignCat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assignability of Reference Pedigree — getAssignCat","text":"","code":"PedA <- getAssignCat(Ped_HSg5, rownames(SimGeno_example)) tail(PedA) #>          id    dam   sire id.cat dam.cat sire.cat #> 995  b05187 a04045 b04098      X       X        X #> 996  a05188 a04045 b04098      X       X        X #> 997  a05189 a04006 b04177      X       X        X #> 998  b05190 a04006 b04177      X       X        X #> 999  b05191 a04006 b04177      X       X        X #> 1000 b05192 a04006 b04177      X       X        X table(PedA$dam.cat, PedA$sire.cat, useNA=\"ifany\") #>     #>       D   G   X #>   D   4  52   0 #>   G   8 232  24 #>   X   0  64 616  # calculate call rate if (FALSE) { CallRates <- apply(MyGenotypes, MARGIN=1,                    FUN = function(x) sum(x!=-9)) / ncol(MyGenotypes) hist(CallRates, breaks=50, col=\"grey\") GoodSamples <- rownames(MyGenotypes)[ CallRates > 0.8] # threshold depends on total number of SNPs, genotyping errors, proportion # of candidate parents that are SNPd (sibship clustering is more prone to # false positives). PedA <- getAssignCat(MyOldPedigree, rownames(GoodSamples)) }"},{"path":"https://jiscah.github.io/reference/GetDescendants.html","id":null,"dir":"Reference","previous_headings":"","what":"Get descendants — GetDescendants","title":"Get descendants — GetDescendants","text":"get descendants individual","code":""},{"path":"https://jiscah.github.io/reference/GetDescendants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get descendants — GetDescendants","text":"","code":"GetDescendants(id, Pedigree)"},{"path":"https://jiscah.github.io/reference/GetDescendants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get descendants — GetDescendants","text":"id id individual Pedigree dataframe columns id - parent1 - parent2; first 3 columns used.","code":""},{"path":"https://jiscah.github.io/reference/GetDescendants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get descendants — GetDescendants","text":"list first element id, second offspring, third  grand-offspring, etc.. element vector ids, first three  elements named, rest numbered.","code":""},{"path":"https://jiscah.github.io/reference/GetDummifiable.html","id":null,"dir":"Reference","previous_headings":"","what":"Dummifiable IDs — GetDummifiable","title":"Dummifiable IDs — GetDummifiable","text":"Get dummifiable individuals, using various possible   criteria","code":""},{"path":"https://jiscah.github.io/reference/GetDummifiable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dummifiable IDs — GetDummifiable","text":"","code":"GetDummifiable(Pedigree, gID, minSibSize)"},{"path":"https://jiscah.github.io/reference/GetDummifiable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dummifiable IDs — GetDummifiable","text":"Pedigree dataframe id - dam - sire. gID vector IDs SNP-genotyped individuals. minSibSize minimum requirements considered dummifiable: '1sib' : sibship size 1, without grandparents.     latter really sibship, can useful situations. '1sib1GP': sibship size 1 least 1 grandparent '2sib': least 2 siblings, without grandparents. Used        PedCompare .","code":""},{"path":"https://jiscah.github.io/reference/GetDummifiable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dummifiable IDs — GetDummifiable","text":"length-2 list (dams, sires) element vector   dummifiable ids","code":""},{"path":"https://jiscah.github.io/reference/GetDummifiable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dummifiable IDs — GetDummifiable","text":"values minSibSize used calling functions 1sib CalcOHLLR, CalcPairLL 1sib1GP getAssignCat (default user called) 2sib PedCompare","code":""},{"path":"https://jiscah.github.io/reference/getGenerations.html","id":null,"dir":"Reference","previous_headings":"","what":"Count Generations — getGenerations","title":"Count Generations — getGenerations","text":"individual pedigree, count number   generations since distant pedigree founder.","code":""},{"path":"https://jiscah.github.io/reference/getGenerations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count Generations — getGenerations","text":"","code":"getGenerations(Ped, StopIfInvalid = TRUE)"},{"path":"https://jiscah.github.io/reference/getGenerations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count Generations — getGenerations","text":"Ped dataframe, pedigree first three columns id - dam - sire. Column names ignored, additional columns. StopIfInvalid pedigree loop detected, stop error (TRUE, default) return Pedigree, see problem(s) occur.","code":""},{"path":"https://jiscah.github.io/reference/getGenerations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count Generations — getGenerations","text":"vector generation number individual, starting   0 founders. Offspring G0 X G0 G1, offspring G0 X G1 G1 x   G1 G2, etc. NA indicates pedigree loop individual   ancestor (pedigree >1000 generations). output name specified, results returned, error   message pedigree contains loop. get details pedigree loop, can use   https://github.com/JiscaH/sequoiaExtra/blob/main/find_pedigree_loop.R","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/getGenerations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count Generations — getGenerations","text":"","code":"# returns nothing if OK, else error: getGenerations(SeqOUT_griffin$Pedigree)  # returns vector with generation numbers: G <- getGenerations(SeqOUT_griffin$Pedigree, StopIfInvalid=FALSE) table(G, useNA='ifany') #> G #>  0  1  2  3  4  5  6  7  8  #> 36 22 19 17 14 13 22 22  5  Ped_plus_G <- cbind(SeqOUT_griffin$Pedigree, G)"},{"path":"https://jiscah.github.io/reference/GetLLRAge.html","id":null,"dir":"Reference","previous_headings":"","what":"LLR-age from Ageprior Matrix — GetLLRAge","title":"LLR-age from Ageprior Matrix — GetLLRAge","text":"Get log10-likelihood ratios specific age difference   matrix AgePriorExtra.","code":""},{"path":"https://jiscah.github.io/reference/GetLLRAge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LLR-age from Ageprior Matrix — GetLLRAge","text":"","code":"GetLLRAge(AgePriorExtra, agedif, patmat)"},{"path":"https://jiscah.github.io/reference/GetLLRAge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LLR-age from Ageprior Matrix — GetLLRAge","text":"AgePriorExtra matrix sequoia output agedif vector age differences, whole numbers. Must occur rownames AgePriorExtra. patmat numeric vector; choose maternal (1), paternal (2) relatives, relationship -likely alternative (3).","code":""},{"path":"https://jiscah.github.io/reference/GetLLRAge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LLR-age from Ageprior Matrix — GetLLRAge","text":"matrix nrow equal length agedif, 7   columns: PO-FS-HS-GP-FA-HA-U.","code":""},{"path":"https://jiscah.github.io/reference/GetLLRAge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LLR-age from Ageprior Matrix — GetLLRAge","text":"","code":"PairsG <- data.frame(ID1=\"i122_2007_M\",                      ID2 = c(\"i124_2007_M\", \"i042_2003_F\", \"i083_2005_M\"),                      AgeDif = c(0,4,2)) cbind(PairsG,       GetLLRAge(SeqOUT_griffin$AgePriorExtra,                 agedif = PairsG$AgeDif, patmat=rep(2,3))) #>           ID1         ID2 AgeDif   PO    FS    HS    GP    FA    HA U #> 1 i122_2007_M i124_2007_M      0 -Inf  0.33  0.60  -Inf -0.12 -0.19 0 #> 2 i122_2007_M i042_2003_F      4 -Inf  -Inf  -Inf  0.32 -0.48 -0.47 0 #> 3 i122_2007_M i083_2005_M      2 0.52 -1.66 -0.13 -0.08  0.23  0.30 0"},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Putative Relatives — GetMaybeRel","title":"Find Putative Relatives — GetMaybeRel","text":"Identify pairs individuals likely related,   assigned provided pedigree.","code":""},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Putative Relatives — GetMaybeRel","text":"","code":"GetMaybeRel(   GenoM = NULL,   SeqList = NULL,   Pedigree = NULL,   LifeHistData = NULL,   AgePrior = NULL,   Module = \"par\",   Complex = \"full\",   Herm = \"no\",   Err = 1e-04,   ErrFlavour = \"version2.0\",   Tassign = 0.5,   Tfilter = -2,   MaxPairs = 7 * nrow(GenoM),   quiet = FALSE,   ParSib = NULL,   MaxMismatch = NA )"},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Putative Relatives — GetMaybeRel","text":"GenoM numeric matrix genotype data: One row per individual, one column per SNP, coded 0, 1, 2 -9 (missing). See also GenoConvert. SeqList list output sequoia. SeqList$Pedigree used present, SeqList$PedigreePar otherwise, overrides input parameter Pedigree. 'Specs' present, elements override input parameters name. list elements  `LifeHist', `AgePriors', `ErrM' also used present, similarly override corresponding input parameters. Pedigree dataframe id - dam - sire columns 1-3. May include non-genotyped individuals, treated dummy individuals. provided, likelihoods (thus maybe-relatives) conditional pedigree. Note: SeqList$Pedigree SeqList$PedigreePar take precedent (function ). LifeHistData data.frame 6 columns: ID max. 30 characters long Sex 1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,            numbers NA = unknown BirthYear birth hatching year, integer, missing values NA   negative number. .min minimum birth year, used BirthYear missing .max maximum birth year, used BirthYear missing Year.last Last year individual offspring. Can   e.g. mammals year death females, year death   males. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring, integers used. Individuals need order `GenoM', genotyped individuals need included. AgePrior Agepriors matrix, generated MakeAgePrior included sequoia output. Affects relationships considered possible (\\(P(|R) / P() > 0\\)). Module type relatives check . One par parent - offspring pairs ped first second degree relatives 'par', pairs returned likely parent-offspring unrelated, potentially including pairs even likely otherwise related. Complex Breeding system complexity. Either \"full\" (default), \"simp\" (simplified, explicit consideration inbred relationships), \"mono\" (monogamous). Herm Hermaphrodites, either \"\", \"\" (distinguish dam sire role, default least 1 individual sex=4), \"B\" (distinction dam sire role). latter deal selfing. Err estimated genotyping error rate, single number, length 3 vector P(hom|hom), P(het|hom), P(hom|het), 3x3 matrix. See details . error rate presumed constant across SNPs, missingness presumed random respect actual genotype. Using Err >5% recommended, Err >10% strongly discouraged. ErrFlavour function takes Err (single number) input, returns length 3 vector 3x3 matrix, choose inbuilt options 'version2.9', 'version2.0', 'version1.3', 'version1.1', referring sequoia version default. Ignored Err vector matrix. See ErrToM details. Tassign minimum LLR required acceptance proposed relationship, relative next likely relationship. Higher values result conservative assignments. Must zero positive. Tfilter threshold log10-likelihood ratio (LLR) proposed relationship versus unrelated, select candidate relatives. Typically negative value, related fact unconditional likelihoods calculated filtering steps. negative values may decrease non-assignment, increase computational time. MaxPairs maximum number putative pairs return. quiet logical, suppress messages. ParSib DEPRECATED, use Module either 'par' check putative parent-offspring pairs , 'sib' check types first second degree relatives. MaxMismatch DEPRECATED IGNORED. Now calculated automatically using CalcMaxMismatch.","code":""},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Putative Relatives — GetMaybeRel","text":"list MaybePar dataframe non-assigned likely parent-offspring pairs,  columns: ID1 ID2 TopRel: likely relationship, using abbreviations listed         LLR: Log10-Likelihood Ratio likely next        likely relationship OH: Number loci two individuals opposite        homozygotes BirthYear1: Birth year ID1 (copied LifeHistData) BirthYear2 AgeDif: Age difference; BirthYear1 - BirthYear2 Sex1: Sex ID1 (copied LifeHistData) Sex2 SnpdBoth: Number loci two individuals        successfully genotyped MaybeRel dataframe non-assigned likely pairs relatives, columns identical MaybePar MaybeTrio dataframe non-assigned parent-parent-offspring     trios, columns: ID parent1 parent2 TopRel: likely relationship, using abbreviations listed         LLRparent1: Log10-Likelihood Ratio parent1        parent ID vs next likely relationship pair,        ignoring parent2 LLRparent2: LLRparent1 LLRpair: LLR parental pair, versus next likely        configuration three individuals (one neither        parent assigned) OHparent1: Number loci ID parent1 opposite        homozygotes OHparent2: OHparent1 MEpair: Number Mendelian errors offspring    parent pair, includes OH well e.g. parents opposing    homozygotes, offspring heterozygote. offspring    OH parents counted 2 errors. SNPd.id.parent1: Number loci ID parent1        successfully genotyped SNPd.id.parent2: SNPd.id.parent1 following categories used column 'TopRel', indicating likely relationship category: PO Parent-Offspring FS Full Siblings HS Half Siblings GP GrandParent - grand-offspring FA Full Avuncular (aunt/uncle) 2nd 2nd degree relatives, enough information distinguish   HS,GP FA Q Unclear, probably 1st, 2nd 3rd degree relatives","code":""},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find Putative Relatives — GetMaybeRel","text":"Module=\"par\", age difference putative pair   temporarily set NA genetic parent-offspring pairs declared   born year may discovered. Module=\"ped\",   relationships possible given age difference, known   LifeHistData, considered.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/GetMaybeRel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Putative Relatives — GetMaybeRel","text":"","code":"if (FALSE) { # without conditioning on pedigree MaybeRel_griffin <- GetMaybeRel(GenoM=Geno_griffin, Err=0.001, Module='par') } names(MaybeRel_griffin) #> [1] \"MaybePar\"  \"MaybeTrio\"  # conditioning on pedigree MaybePO <- GetMaybeRel(GenoM = Geno_griffin, SeqList = SeqOUT_griffin,                       Module = 'par') #> Searching for non-assigned parent-offspring pairs ... (Module = par) #> using Pedigree in SeqList #> using LifeHist in SeqList #> using AgePriors in SeqList #> Genotype matrix looks OK! There are  142  individuals and  400  SNPs. #> settings in SeqList$Specs will overrule input parameters #> Counting opposing homozygous loci between all individuals ... #> Checking for non-assigned Parent-Offspring pairs ... #> Found 0 likely parent-offspring pairs, and 0 other non-assigned pairs of possible relatives head(MaybePO$MaybePar) #> NULL  # instead of providing the entire SeqList, one may specify the relevant # elements separately Maybe <- GetMaybeRel(GenoM = Geno_griffin,                      Pedigree = SeqOUT_griffin$PedigreePar,                      LifeHistData = LH_griffin,                      Err=0.0001, Complex = \"full\",                      Module = \"ped\") #> Searching for non-assigned relative pairs ... (Module = ped) #> Genotype matrix looks OK! There are  142  individuals and  400  SNPs. #> Ageprior: Pedigree-based, overlapping generations, smoothed, MaxAgeParent = 5,5 #> Counting opposing homozygous loci between all individuals ... #> Checking for non-assigned relatives ... #> Found 0 likely parent-offspring pairs, and 131 other non-assigned pairs of possible relatives head(Maybe$MaybeRel) #>           ID1         ID2 TopRel   LLR OH BirthYear1 BirthYear2 AgeDif Sex1 #> 1 i081_2005_F i083_2005_M     FS  5.42  3       2005       2005      0    1 #> 2 i165_2009_F i175_2009_M     FS  5.34  3       2009       2009      0    1 #> 3 i131_2007_F i133_2007_F     FS  5.09  3       2007       2007      0    1 #> 4 i160_2008_F i130_2007_F     FS  2.25  3       2008       2007      1    1 #> 5 i158_2008_M i133_2007_F     HS 17.36  3       2008       2007      1    2 #> 6 i158_2008_M i130_2007_F     HS 16.15  3       2008       2007      1    2 #>   Sex2 SNPdBoth #> 1    2      392 #> 2    2      392 #> 3    1      392 #> 4    1      392 #> 5    1      392 #> 6    1      392  # visualise results, turn dataframe into matrix first: MaybeM <- GetRelM(Pairs = Maybe$MaybeRel) PlotRelPairs(MaybeM)  # or combine with pedigree (note suffix '?') RelM <- GetRelM(Pedigree =SeqOUT_griffin$PedigreePar, Pairs = Maybe$MaybeRel) PlotRelPairs(RelM)"},{"path":"https://jiscah.github.io/reference/GetRelA.html","id":null,"dir":"Reference","previous_headings":"","what":"Array with Pairwise Relationships — GetRelA","title":"Array with Pairwise Relationships — GetRelA","text":"Generate array indicating relationship(s)  pairs individuals according pedigree.","code":""},{"path":"https://jiscah.github.io/reference/GetRelA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Array with Pairwise Relationships — GetRelA","text":"","code":"GetRelA(Ped = NULL, GenBack = 1, patmat = TRUE, directed = TRUE, List = FALSE)"},{"path":"https://jiscah.github.io/reference/GetRelA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Array with Pairwise Relationships — GetRelA","text":"Ped dataframe columns id - dam - sire. GenBack number generations back consider; 1 returns parent-offspring sibling relationships, 2 also returns grand-parental, avuncular first cousins. patmat logical, distinguish paternal versus maternal relative pairs? avuncular pairs, distinction never made. directed logical, distinguish 'O' vs 'P' group 'PO' ? List logical, return list instead default array","code":""},{"path":"https://jiscah.github.io/reference/GetRelA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Array with Pairwise Relationships — GetRelA","text":"3D array indicating pair specified relationship (1) (0). various relationship considered 3rd dimension: M  P  FS full siblings, including double 'half sibs' MS  PS  XS sibs: mother father B, vv etc.","code":""},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix with Pairwise Relationships — GetRelM","title":"Matrix with Pairwise Relationships — GetRelM","text":"Generate matrix 3D array pairwise relationships   pedigree dataframe pairs.","code":""},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix with Pairwise Relationships — GetRelM","text":"","code":"GetRelM(   Pedigree = NULL,   Pairs = NULL,   GenBack = 1,   patmat = FALSE,   directed = TRUE,   Return = \"Matrix\",   Pairs_suffix = \"?\" )"},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix with Pairwise Relationships — GetRelM","text":"Pedigree dataframe columns id - dam - sire. Pairs dataframe columns ID1 - ID2 - Rel, e.g. returned GetMaybeRel. Combining Pedigree Pairs works best relationships coded listed . GenBack number generations back consider; 1 returns parent-offspring sibling relationships, 2 also returns grand-parental, avuncular first cousins. patmat logical, distinguish paternal versus maternal relative pairs? avuncular pairs, distinction never made. directed logical, distinguish e.g. ID1=offspring, ID2=mother ('M') ID1=mother, ID2=offspring ('O')? Defaults TRUE; FALSE scored 'PO', father-offspring pairs, grandparent-- grand-offspring pairs scored 'GPO', avuncular pairs 'FNA' 'HNA'. (currently) compatible patmat. Return='List', pair included twice (ID1-ID2 & ID2-ID1) Return 'Matrix', 'Array', 'List'. 'Matrix' returns N x N matrix closest relationship pair. 'Array' returns N x N x R array R considered relationships whether exists pair (1) (0). See Details . 'List' returns list R considered relationships 2-column matrix IDs pairs relationship. size list (Mb) much smaller matrix array, therefore format suitable pedigrees many thousands individuals. Pairs specified, possible return type 'Matrix'. Pairs_suffix symbol added relationship abbreviations derived Pairs, Pedigree Pairs provided. Can empty string.","code":""},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix with Pairwise Relationships — GetRelM","text":"Return='Matrix', N x N square matrix, N equal   number rows Pedigree (running  PedPolish) number unique individuals  Pairs. Return='Array', N x N x R array returned,   R, number different relationships, determined GenBack patmat. following abbreviations used within returned Matrix,  names 3rd dimension Array List: S Self M Mother P Father MP Mother Father (patmat=FALSE) O Offspring FS Full sibling MHS Maternal half-sibling PHS Paternal half-sibling XHS half-sibling (hermaphrodites) HS half-sibling (patmat=FALSE) MGM Maternal grandmother MGF Maternal grandfather PGM Paternal grandmother PGF Paternal grandfather GP Grandparent (patmat=FALSE) GO Grand-offspring FA Full avuncular; maternal paternal aunt uncle. FN Full nephew/niece HA Half avuncular HN Half nephew/niece DFC1 Double full first cousin FC1 Full first cousin U Unrelated (otherwise related)","code":""},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix with Pairwise Relationships — GetRelM","text":"Double relationships ignored Return='Matrix',   Return='Array'. example, B   mother-offspring paternal siblings (mated father produce   B), mother-offspring relationship indicated   Return='Matrix'. Note full siblings exception rule: Array   indicated 'FS' , 'MHS' 'PHS'. Similarly,   full avuncular pairs indicated 'HA'. Double half-avuncular   relationships indicated FA HA. Pairs provided, GenBack patmat   ignored, check performed abbreviations compatible   functions.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/GetRelM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix with Pairwise Relationships — GetRelM","text":"","code":"Rel.griffin <- GetRelM(Ped_griffin, directed=FALSE)  # few categories Rel.griffin <- GetRelM(Ped_griffin, patmat=TRUE, GenBack=2)  # many cat. table(as.vector(Rel.griffin)) #>  #>    FA   FC1    FN    FS    GO    HA    HN     M   MGF   MGM   MHS     O     P  #>    45     6    45    10   511   957   953   167   132   138   422   330   163  #>   PGF   PGM   PHS     S     U  #>   120   121   308   200 35372  # turning matrix into vector first makes table() much faster PlotRelPairs(Rel.griffin)"},{"path":"https://jiscah.github.io/reference/Inherit_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Inheritance patterns — Inherit_patterns","title":"Inheritance patterns — Inherit_patterns","text":"Inheritance patterns used SimGeno non-autosomal SNPs,   identical Inherit.xlsx","code":""},{"path":"https://jiscah.github.io/reference/Inherit_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inheritance patterns — Inherit_patterns","text":"","code":"data(Inherit_patterns)"},{"path":"https://jiscah.github.io/reference/Inherit_patterns.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Inheritance patterns — Inherit_patterns","text":"array following dimensions: d1 type: autosomal, x-chromosome, y-chromosome, mtDNA d2 offspring sex: female, male, unknown d3 offspring genotype: aa (0), aA (1), Aa (1), AA (2) d4 mother genotype d5 father genotype","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Inherit_patterns.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inheritance patterns — Inherit_patterns","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Sex and Birth Year from PLINK File — LHConvert","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"Convert first six columns PLINK .fam, .ped  .raw file three-column lifehistory file sequoia. Optionally   FID IID combined.","code":""},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"","code":"LHConvert(   PlinkFile = NULL,   UseFID = FALSE,   SwapSex = TRUE,   FIDsep = \"__\",   LifeHistData = NULL )"},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"PlinkFile character string name genotype file converted. UseFID use family ID column. resulting ids (rownames GenoM) form FID__IID. SwapSex change coding PLINK default (1=male, 2=female) sequoia default (1=female, 2=male); numbers set NA. FIDsep characters inbetween FID IID composite-ID. default double underscore used, avoid problems IIDs contain underscore. used UseFID=TRUE. LifeHistData dataframe additional sex birth year info. case conflicts, LifeHistData takes priority, warning. UseFID=TRUE, IDs LifeHistData assumed already FID__IID.","code":""},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"dataframe id, sex birth year, can used input  sequoia.","code":""},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"first 6 columns PLINK .fam, .ped .raw files default FID - IID - father ID (ignored) - mother ID (ignored) - sex - phenotype.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/LHConvert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Sex and Birth Year from PLINK File — LHConvert","text":"","code":"if (FALSE) { # combine FID and IID in dataframe with additional sex & birth years ExtraLH$FID_IID <- paste(ExtraLH$FID, ExtraLH$IID, sep = \"__\") LH.new <- LHConvert(PlinkFile, UseFID = TRUE, FIDsep = \"__\",                     LifeHistData = ExtraLH) }"},{"path":"https://jiscah.github.io/reference/LH_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example life history data: griffins — LH_griffin","title":"Example life history data: griffins — LH_griffin","text":"Example life history data associated griffin pedigree.","code":""},{"path":"https://jiscah.github.io/reference/LH_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example life history data: griffins — LH_griffin","text":"","code":"data(LH_griffin)"},{"path":"https://jiscah.github.io/reference/LH_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example life history data: griffins — LH_griffin","text":"data frame 200 rows 3 variables (ID, Sex, BirthYear)","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/LH_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example life history data: griffins — LH_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/LH_griffin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example life history data: griffins — LH_griffin","text":"","code":"if (FALSE) { BY <- rep(c(2001:2010), each=20) Sex <- sample.int(n=2, size=200, replace=TRUE) ID <- paste0(\"i\", formatC(1:200, width=3, flag=\"0\"), \"_\", BY, \"_\",              ifelse(Sex==1, \"F\", \"M\")) LH_griffin <- data.frame(ID, Sex, BirthYear = BY) }"},{"path":"https://jiscah.github.io/reference/LH_HSg5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example life history file: 'HSg5' — LH_HSg5","title":"Example life history file: 'HSg5' — LH_HSg5","text":"life history file associated   Ped_HSg5, Pedigree II paper.","code":""},{"path":"https://jiscah.github.io/reference/LH_HSg5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example life history file: 'HSg5' — LH_HSg5","text":"","code":"data(LH_HSg5)"},{"path":"https://jiscah.github.io/reference/LH_HSg5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example life history file: 'HSg5' — LH_HSg5","text":"data frame 1000 rows 3 variables: ID Female IDs start '', males 'b'; next 2 numbers give   generation number (00 -- 05), last 3 numbers individual ID   number (runs continuously across generations) Sex 1 = female, 2 = male BirthYear 2000 (generation 0, founders) 2005","code":""},{"path":"https://jiscah.github.io/reference/LH_HSg5.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example life history file: 'HSg5' — LH_HSg5","text":"Huisman, J. (2017) Pedigree reconstruction SNP data:   Parentage assignment, sibship clustering, beyond. Molecular Ecology   Resources 17:1009--1024.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/LH_HSg5.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example life history file: 'HSg5' — LH_HSg5","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/LLRplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Scatter Plot of Pair LLRs — LLRplot","title":"Scatter Plot of Pair LLRs — LLRplot","text":"Plot LLR(rely/U) LLR(relx/U), one combination   relationships, colour coded fcl & top.","code":""},{"path":"https://jiscah.github.io/reference/LLRplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scatter Plot of Pair LLRs — LLRplot","text":"","code":"LLRplot(relx, rely, LLRU, fcl, top, RelCol, bgcol, Tassign = 0.5, Tfilter = -2)"},{"path":"https://jiscah.github.io/reference/LLRplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scatter Plot of Pair LLRs — LLRplot","text":"relx relationship plot x-axis. One 'PO', 'FS', 'HS', 'GP', 'FA', 'HA'. rely relationship plot y-axis; relx. LLRU matrix log10-likelihoods, already scaled LL(U) pair. fcl focal relationship, sets outer circle colour points. top likely relationship, sets inner filling colour points. RelCol named character vector colours use per relationship. bgcol background colour TRUE/FALSE. Tassign assignment threshold, shown grey square bottom-left corner band along diagonal. Tfilter filter threshold, shown dark grey square bottom-left.","code":""},{"path":"https://jiscah.github.io/reference/LLRplot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scatter Plot of Pair LLRs — LLRplot","text":"background plot coloured match relx (bottom   triangle) rely (upper triangle).","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Age Priors — MakeAgePrior","title":"Age Priors — MakeAgePrior","text":"Estimate probability ratios \\(P(R|) / P(R)\\) age   differences five categories parent-offspring sibling   relationships R.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Age Priors — MakeAgePrior","text":"","code":"MakeAgePrior(   Pedigree = NULL,   LifeHistData = NULL,   MinAgeParent = NULL,   MaxAgeParent = NULL,   Discrete = NULL,   Flatten = NULL,   lambdaNW = -log(0.5)/100,   Smooth = TRUE,   Plot = TRUE,   Return = \"LR\",   quiet = FALSE )"},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Age Priors — MakeAgePrior","text":"Pedigree dataframe id - dam - sire columns 1-3, optional column birth years. columns ignored. LifeHistData dataframe 3 5 columns: id - sex (used) - birthyear (optional columns .min - .max - YearLast used), unknown birth years coded negative numbers NA. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring. may include individuals pedigree, individuals pedigree need LifeHistData. MinAgeParent minimum age parent, single number (min across dams sires) vector length two (dams, sires). Defaults 1. conflict minimum age pedigree, pedigree takes precedent. MaxAgeParent maximum age parent, single number (max across dams sires) vector length two (dams, sires). NULL, set latest - earliest birth year LifeHistData, estimated pedigree one provided. See details . Discrete discrete generations? default (NULL), discrete generations assumed parent-offspring pairs age difference 1, siblings age difference 0, least 20 pairs category (mother, father, maternal sibling, paternal sibling). Otherwise, overlapping generations presumed. Discrete=TRUE (explicitly deduced), Smooth Flatten always automatically set FALSE. Use Discrete=FALSE enforce (potential ) overlapping generations. Flatten logical. deal small sample sizes relationships, calculate weighed average observed age difference distribution among relatives flat (0/1) distribution. Flatten=NULL (default) automatically set TRUE fewer 20 parents known age either sex assigned, fewer 20 maternal paternal siblings known age difference. Also advisable sampled relative pairs known age difference non-typical pedigree whole. lambdaNW control weighing factors Flatten=TRUE. Weights calculated \\(W(R) = 1 - exp(-lambdaNW * N(R))\\), \\(N(R)\\) number pairs relationship R age difference known. Large values (>0.2) put strong emphasis pedigree, small values (<0.0001) cause pedigree ignored. Default results \\(W=0.5\\) \\(N=100\\). Smooth smooth tails dips distribution? Sets dips (<10% average neighbouring ages) average neighbouring ages, sets age end (oldest observed age) LR(end)/2, assigns small value (0.001) ages front (youngest observed age) new end. Peaks smoothed , less likely cause problems dips, likely genuine characteristics species. set FALSE generations overlap (Discrete=TRUE). Plot plot heatmap results? Return return matrix likelihood-ratio \\(P(|R) / P()\\) (\"LR\") list including also various intermediate statistics (\"\") ? quiet suppress messages.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Age Priors — MakeAgePrior","text":"matrix probability ratio age difference two   individuals conditional certain type relative   (\\(P(|R)\\)) versus random draw sample (\\(P()\\)).   Assuming conditional independence, equals probability ratio   certain type relative conditional age difference, versus   random draw. matrix one row per age difference (0 - nAgeClasses) five   columns, one relationship type, abbreviations: M Mothers P Fathers FS Full siblings MS Maternal half-siblings PS Paternal half-siblings Return='', list returned following elements: BirthYearRange vector length 2 MaxAgeParent vector length 2, see details tblA.R matrix counts per age difference (rows) /      relationship (columns) combination, plus column 'X' age      differences across pairs individuals PA.R Proportions, .e. tblA.R divided colSums,     full-sibling correction applied necessary (see vignette). LR.RU..raw Proportions PA.R standardised global age      difference distribution (column 'X'); LR.RU.prior flattening      smoothing Weights vector length 4, weights used flatten     distributions LR.RU.ageprior, flattend /smoothed Specs.AP names input Pedigree    LifeHistData (NULL), lambdaNW, 'effective'      settings (.e. automatic update) Discrete,      Smooth, Flatten.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Age Priors — MakeAgePrior","text":"\\(\\alpha_{,R}\\) ratio observed   counts pairs age difference relationship R (\\(N_{,R}\\)),   expected counts age relationship independent   (\\(N_{.,.}*p_A*p_R\\)). pedigree reconstruction, \\(\\alpha_{,R}\\) multiplied   genetic-\\(P(R|G)\\) obtain probability   pair relatives type R conditional age difference   genotypes. age-difference prior used pairs genotyped individuals,   well dummy individuals. assumes propensity pair   given age difference sampled depend   relationship, ratio \\(P(|R) / P()\\) differ   sampled unsampled pairs. details, see vignette.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"caution","dir":"Reference","previous_headings":"","what":"CAUTION","title":"Age Priors — MakeAgePrior","text":"small sample correction Smooth /Flatten   prevents errors one dataset, may introduce errors another;   single solution fits wide variety life histories   datasets impossible. Please inspect matrix, e.g.   PlotAgePrior, adjust input parameters /output   matrix necessary.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"single-cohort","dir":"Reference","previous_headings":"","what":"Single cohort","title":"Age Priors — MakeAgePrior","text":"individuals LifeHistData birth year,   assumed Discrete=TRUE MaxAgeParent=1. Consequently,   assumed avuncular pairs present sample; cousins   considered alternative. enforce overlapping generations,   thereby consideration full- half- avuncular relationships, set   MaxAgeParent value greater \\(1\\). birth year information given , single cohort assumed,  rules apply.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"other-time-units","dir":"Reference","previous_headings":"","what":"Other time units","title":"Age Priors — MakeAgePrior","text":"\"Birth year\" may arbitrary time unit relevant species   (day, month, decade), long parents always born   putative offspring, never time unit (e.g. parent's   BirthYear= 1 (2001) offspring BirthYear=5 (2005)). Negative   numbers NA's interpreted unknown, fractional numbers   allowed.","code":""},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"maxageparent","dir":"Reference","previous_headings":"","what":"MaxAgeParent","title":"Age Priors — MakeAgePrior","text":"maximum parental age sex equals maximum : maximum age parents Pedigree, input parameter MaxAgeParent, maximum range birth years LifeHistData (including      .min .max). used previous NA,      fewer 20 parents either sex assigned. 1, Discrete=TRUE previous three NA age distribution assigned parents capture maximum  possible age parents, advised specify MaxAgeParent  one sexes. may hinder subsequent assignment  dummy parents grandparents. compatible Smooth.  largest age difference pedigree larger specified  MaxAgeParent, pedigree takes precedent (.e. largest  two used). @section grandparents & avuncular  agepriors grand-parental avuncular pairs calculated  sequoia, included output  `AgePriorExtra`.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/MakeAgePrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Age Priors — MakeAgePrior","text":"","code":"# without pedigree or lifehistdata: MakeAgePrior(MaxAgeParent = c(2,3)) #> Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 2,3  #>   M P FS MS PS #> 0 0 0  1  1  1 #> 1 1 1  1  1  1 #> 2 1 1  0  0  1 #> 3 0 1  0  0  0 #> 4 0 0  0  0  0 MakeAgePrior(Discrete=TRUE) #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1  #>   M P FS MS PS #> 0 0 0  1  1  1 #> 1 1 1  0  0  0 #> 2 0 0  0  0  0  # single cohort: MakeAgePrior(LifeHistData = data.frame(ID = letters[1:5], Sex=3,   BirthYear=1984)) #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1 #>   M P FS MS PS #> 0 0 0  1  1  1 #> 1 1 1  0  0  0 #> 2 0 0  0  0  0  # overlapping generations: # without pedigree: MaxAgeParent = max age difference between any pair +1 MakeAgePrior(LifeHistData = SeqOUT_griffin$LifeHist) #> Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 10,10  #>    M P FS MS PS #> 0  0 0  1  1  1 #> 1  1 1  1  1  1 #> 2  1 1  1  1  1 #> 3  1 1  1  1  1 #> 4  1 1  1  1  1 #> 5  1 1  1  1  1 #> 6  1 1  1  1  1 #> 7  1 1  1  1  1 #> 8  1 1  1  1  1 #> 9  1 1  1  1  1 #> 10 1 1  0  0  0 #> 11 0 0  0  0  0 # with pedigree: MakeAgePrior(Pedigree=Ped_griffin,              LifeHistData=SeqOUT_griffin$LifeHist,              Smooth=FALSE, Flatten=FALSE) #> Ageprior: Pedigree-based, overlapping generations, MaxAgeParent = 3,3  #>       M     P    FS    MS    PS #> 0 0.000 0.000 5.043 4.316 3.862 #> 1 3.476 1.967 2.798 2.636 2.971 #> 2 2.011 3.167 0.077 0.691 0.583 #> 3 0.340 0.959 0.000 0.000 0.000 #> 4 0.000 0.000 0.000 0.000 0.000 # with small-sample correction: MakeAgePrior(Pedigree=Ped_griffin,              LifeHistData=SeqOUT_griffin$LifeHist,              Smooth=TRUE, Flatten=TRUE) #> Ageprior: Pedigree-based, overlapping generations, flattened, smoothed, MaxAgeParent = 5,5  #>       M     P    FS    MS    PS #> 0 0.000 0.000 2.761 3.574 2.918 #> 1 2.698 1.655 1.783 2.270 2.321 #> 2 1.693 2.467 0.598 0.760 0.721 #> 3 0.548 0.972 0.299 0.380 0.360 #> 4 0.274 0.486 0.001 0.001 0.001 #> 5 0.001 0.001 0.000 0.000 0.000 #> 6 0.000 0.000 0.000 0.000 0.000  # Call from sequoia() via args.AP: Seq_HSg5 <- sequoia(SimGeno_example, LH_HSg5, Module=\"par\",                 args.AP=list(Discrete = TRUE),  # non-overlapping generations                 CalcLLR = FALSE,   # skip time-consuming calculation of LLR's                 Plot = FALSE)      # no summary plots when finished #> Genotype matrix looks OK! There are  214  individuals and  200  SNPs. #> There are 106 females, 108 males, 0 individuals of unknown sex, and 0 hermaphrodites. #> Exact birth years are from 2000 to 2001 #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1 #>  #> ~~~ Duplicate check ~~~ #>  #> ~~~ Parentage assignment ~~~ #> Assign parents ... #> Initial total LL : #> [1] -18301.9 #> Post-parentage total LL : #> [1] -13690.07 #> Estimating birth years ... #> assigned 126 dams and 165 sires to 214 individuals #> Possibly not all parents were assigned, consider running GetMaybeRel() conditional on this pedigree to check"},{"path":"https://jiscah.github.io/reference/MaybeRel_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example output from check for relatives: griffins — MaybeRel_griffin","title":"Example output from check for relatives: griffins — MaybeRel_griffin","text":"Example output check parent-offspring pairs   parent-parent-offspring trios GetMaybeRel,   Geno_griffin input (simulated   Ped_griffin).","code":""},{"path":"https://jiscah.github.io/reference/MaybeRel_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example output from check for relatives: griffins — MaybeRel_griffin","text":"","code":"data(MaybeRel_griffin)"},{"path":"https://jiscah.github.io/reference/MaybeRel_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example output from check for relatives: griffins — MaybeRel_griffin","text":"list 2 dataframes, 'MaybePar' 'MaybeTrio'. See   GetMaybeRel details.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/MaybeRel_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example output from check for relatives: griffins — MaybeRel_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/MaybeRel_griffin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example output from check for relatives: griffins — MaybeRel_griffin","text":"","code":"if (FALSE) { MaybeRel_griffin <- GetMaybeRel(GenoM = Geno_griffin, Err=0.001,                                 Module = 'par') }"},{"path":"https://jiscah.github.io/reference/MergeFill.html","id":null,"dir":"Reference","previous_headings":"","what":"Special Merge — MergeFill","title":"Special Merge — MergeFill","text":"regular merge, combine data columns  name.","code":""},{"path":"https://jiscah.github.io/reference/MergeFill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special Merge — MergeFill","text":"","code":"MergeFill(df1, df2, by, overwrite = FALSE, ...)"},{"path":"https://jiscah.github.io/reference/MergeFill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special Merge — MergeFill","text":"df1 first dataframe (lowest priority overwrite=TRUE). df2 second dataframe (highest priority overwrite=TRUE). columns used merging, required. overwrite FALSE (default), NA's df1 replaced values df2. TRUE, values df1 overwritten values df2, except df2 NA. ... additional arguments merge, .","code":""},{"path":"https://jiscah.github.io/reference/MkAPdefault.html","id":null,"dir":"Reference","previous_headings":"","what":"Make default 1/0 ageprior — MkAPdefault","title":"Make default 1/0 ageprior — MkAPdefault","text":"Create ageprior matrix based min max age parents.","code":""},{"path":"https://jiscah.github.io/reference/MkAPdefault.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make default 1/0 ageprior — MkAPdefault","text":"","code":"MkAPdefault(MinP, MaxP, Disc)"},{"path":"https://jiscah.github.io/reference/MkAPdefault.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make default 1/0 ageprior — MkAPdefault","text":"MinP Minimum age dams, sires MaxP Maximum age dams, sires Disc Discrete generations? TRUE/FALSE/NULL","code":""},{"path":"https://jiscah.github.io/reference/MkFortParams.html","id":null,"dir":"Reference","previous_headings":"","what":"PARAM to FortPARAM — MkFortParams","title":"PARAM to FortPARAM — MkFortParams","text":"Convert list PARAM list integer-  double-vectors, passed Fortran.","code":""},{"path":"https://jiscah.github.io/reference/MkFortParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PARAM to FortPARAM — MkFortParams","text":"","code":"MkFortParams(PARAM, fun = \"main\")"},{"path":"https://jiscah.github.io/reference/MkFortParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PARAM to FortPARAM — MkFortParams","text":"PARAM list input parameters. fun function MkFortParams called, determines elements included output list.","code":""},{"path":"https://jiscah.github.io/reference/MkFortParams.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PARAM to FortPARAM — MkFortParams","text":"list elements Ng Integer, number individuals SpecsInt 8 integers: nSnp MaxMismatchV; DUP - OH - MaxSibshipSize Complx, 0=mono, 1=simp, 2=full quiet, -1=verbose, 0=FALSE, 1=TRUE nAgeCl, nrow(AgePriors)  SpecsDbl 2 double precision numbers: Tfilter  (< 0) Tassign  (> 0)  ErrM double, 3x3 matrix passed length-9 vector SpecsIntMkPed fun='main' MaxSibIter AgeEffect, 0=, 1=yes, 2=extra CalcLLR, 0=FALSE, 1=TRUE Herm, 0=, 1= dam/sire distinction, 2=dam/sire distinction  SpecsIntAmb fun='mayberel' ParSib  1=par, 2=ped nAmbMax","code":""},{"path":"https://jiscah.github.io/reference/MkGenoErrors.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Genotyping Errors — MkGenoErrors","title":"Simulate Genotyping Errors — MkGenoErrors","text":"Generate errors missing values (simulated) genotype   matrix.","code":""},{"path":"https://jiscah.github.io/reference/MkGenoErrors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Genotyping Errors — MkGenoErrors","text":"","code":"MkGenoErrors(   SGeno,   CallRate = 0.99,   SnpError = 5e-04,   ErrorFV = function(E) c((E/2)^2, E - (E/2)^2, E/2),   ErrorFM = NULL,   Error.shape = 0.5,   CallRate.shape = 1,   WithLog = FALSE )"},{"path":"https://jiscah.github.io/reference/MkGenoErrors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Genotyping Errors — MkGenoErrors","text":"SGeno matrix genotype data Sequoia's format: 1 row per individual, 1 column per SNP, genotypes coded 0/1/2. CallRate either single number mean call rate (genotyping success), vector call rate SNP, named vector call rate individual. third case, ParMis ignored, individuals pedigree (id parent) included vector presumed non-genotyped. SnpError either single value combined ErrorFV, length 3 vector probabilities (observed given actual) hom|hom, het|hom, hom|het; vector 3XnSnp matrix genotyping error rate(s) SNP. ErrorFV function taking error rate (scalar) argument returning length 3 vector hom->hom, hom->het, het->hom. ErrorFM function taking error rate (scalar) argument returning 3x3 matrix probabilities actual genotype (rows) observed genotype j (columns). See details. use, set ErrorFV = NULL Error.shape first shape parameter (alpha) beta-distribution per-SNP error rates. higher value results flatter distribution. CallRate.shape Error.shape, per-SNP call rates. WithLog Include dataframe output datapoints edited, columns id - SNP - actual (original, input) - observed (edited, output).","code":""},{"path":"https://jiscah.github.io/reference/MkGenoErrors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Genotyping Errors — MkGenoErrors","text":"input genotype matrix, genotypes replaced,   set missing (-9). WithLog=TRUE, list 3 elements: GenoM,   Log, Counts_actual (genotype counts input, allow double checking   simulated genotyping error rate).","code":""},{"path":"https://jiscah.github.io/reference/mtSame2Dif.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and recode mtSame matrix — mtSame2Dif","title":"Check and recode mtSame matrix — mtSame2Dif","text":"Recode 1=different, 0=","code":""},{"path":"https://jiscah.github.io/reference/mtSame2Dif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and recode mtSame matrix — mtSame2Dif","text":"","code":"mtSame2Dif(mtSame = NULL, gID = NULL)"},{"path":"https://jiscah.github.io/reference/mtSame2Dif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and recode mtSame matrix — mtSame2Dif","text":"mtSame matrix indicating whether individuals (might) mitochondrial haplotype (1),  definitely (0). individuals need included order important, may square. gID rownames `GenoM`","code":""},{"path":"https://jiscah.github.io/reference/mtSame2Dif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and recode mtSame matrix — mtSame2Dif","text":"square gID x gID matrix indicating whether individuals   definitely different mitochondrial haplotype (1), (possibly)   (0).","code":""},{"path":"https://jiscah.github.io/reference/NumToID.html","id":null,"dir":"Reference","previous_headings":"","what":"Change Numeric Pedigree back to Character Pedigree — NumToID","title":"Change Numeric Pedigree back to Character Pedigree — NumToID","text":"Reverse PedToNum, 1 column time.","code":""},{"path":"https://jiscah.github.io/reference/NumToID.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change Numeric Pedigree back to Character Pedigree — NumToID","text":"","code":"NumToID(x, k = 0, gID = NULL, DumPrefix = c(\"F\", \"M\"))"},{"path":"https://jiscah.github.io/reference/NumToID.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change Numeric Pedigree back to Character Pedigree — NumToID","text":"x vector numbers. k 1=dam, 2=sire, needed distinguish dummy females dummy males. gID vector IDs SNP-genotyped individuals; rownames genotype matrix exact order. DumPrefix length-2 character vector make dummy IDs; length-3 case hermaphrodites.","code":""},{"path":"https://jiscah.github.io/reference/NumToID.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change Numeric Pedigree back to Character Pedigree — NumToID","text":"character vector IDs.","code":""},{"path":"https://jiscah.github.io/reference/OHperSNP.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Genotyping Error Rate — OHperSNP","title":"Estimate Genotyping Error Rate — OHperSNP","text":"Estimate genotyping error rate Mendelian errors per SNP.","code":""},{"path":"https://jiscah.github.io/reference/OHperSNP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Genotyping Error Rate — OHperSNP","text":"","code":"OHperSNP(GenoM, Par, Dups = NULL)"},{"path":"https://jiscah.github.io/reference/OHperSNP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Genotyping Error Rate — OHperSNP","text":"GenoM genotype matrix, sequoia's format: 1 column per SNP, 1 row per individual, genotypes coded 0/1/2/-9, rownames giving individual IDs. Par pedigree dataframe, genotyped parents used. Dups pairs duplicates","code":""},{"path":"https://jiscah.github.io/reference/OHperSNP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Genotyping Error Rate — OHperSNP","text":"dataframe columns: n.dam, n.sire, n.pair Number dams, sires, parent-pairs successfully   genotyped SNP OHdam, OHsire Count number opposing homozygous cases MEpair Count Mendelian errors, includes opposing homozygous cases n.dups, n.diff Number duplicate pairs successfully genotyped   SNP; number differences","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/orderLH.html","id":null,"dir":"Reference","previous_headings":"","what":"Order Lifehistory Data — orderLH","title":"Order Lifehistory Data — orderLH","text":"Order lifehistory data match order IDs genotype data,   filling gaps missing values.","code":""},{"path":"https://jiscah.github.io/reference/orderLH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Order Lifehistory Data — orderLH","text":"","code":"orderLH(LH = NULL, gID = NULL)"},{"path":"https://jiscah.github.io/reference/orderLH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Order Lifehistory Data — orderLH","text":"LH dataframe lifehistory information: ID max. 30 characters long, Sex 1 = females, 2 = males, numbers = unknown, Birth Year (hatching year) Use negative numbers denote  missing values. .min minimum birth year (optional) .max maximum birth year (optional) gID character vector IDs genotype data, order occurrence.","code":""},{"path":"https://jiscah.github.io/reference/orderLH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Order Lifehistory Data — orderLH","text":"dataframe 5 columns, individuals exactly   order gID, including padding 'empty' rows individual   gID input-LH. Missing values recoded 3   'Sex' column, -999 birth year columns.","code":""},{"path":"https://jiscah.github.io/reference/ParamToSpecs.html","id":null,"dir":"Reference","previous_headings":"","what":"PARAM to Specs — ParamToSpecs","title":"PARAM to Specs — ParamToSpecs","text":"Convert list PARAM 1-row dataframe Specs.   called sequoia.","code":""},{"path":"https://jiscah.github.io/reference/ParamToSpecs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PARAM to Specs — ParamToSpecs","text":"","code":"ParamToSpecs(PARAM, TimeStart, ErrFlavour)"},{"path":"https://jiscah.github.io/reference/ParamToSpecs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PARAM to Specs — ParamToSpecs","text":"PARAM list input parameters. TimeStart time sequoia run started. ErrFlavour character name function.","code":""},{"path":"https://jiscah.github.io/reference/ParamToSpecs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PARAM to Specs — ParamToSpecs","text":"1-row Specs dataframe.","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Two Pedigrees — PedCompare","title":"Compare Two Pedigrees — PedCompare","text":"Compare inferred pedigree (Ped2) previous simulated   pedigree (Ped1), including comparison sibship clusters sibship   grandparents.","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Two Pedigrees — PedCompare","text":"","code":"PedCompare(   Ped1 = NULL,   Ped2 = NULL,   DumPrefix = c(\"F0\", \"M0\"),   SNPd = NULL,   Symmetrical = TRUE,   minSibSize = \"1sib1GP\",   Plot = TRUE )"},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Two Pedigrees — PedCompare","text":"Ped1 first (e.g. original) pedigree, dataframe columns id-dam-sire; first 3 columns used. Ped2 second pedigree, e.g. newly inferred SeqOUT$Pedigree SeqOUT$PedigreePar, columns id-dam-sire. DumPrefix character vector prefixes identifying dummy individuals Ped2. Use 'F0' ('M0') avoid matching regular individuals IDs starting 'F' ('M'), provided Ped2 fewer 999 dummy females (males). SNPd character vector IDs genotyped individuals. NULL, defaults IDs occurring Ped1 Ped2 starting prefixes DumPrefix. Symmetrical determining category individuals (Genotyped/Dummy/X), use 'highest' category across two pedigrees (TRUE, default) consider Ped1 (Symmetrical = FALSE). minSibSize minimum requirements considered 'dummifiable',  passed getAssignCat: '1sib' : sibship size 1, without grandparents.     latter really sibship, can useful situations. '1sib1GP': sibship size 1 least 1 grandparent (default) '2sib': least 2 siblings, without grandparents       (default prior version 2.4) Plot show square Venn diagrams counts?","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Two Pedigrees — PedCompare","text":"list Counts 7 x 5 x 2 named numeric array   number matches mismatches, see Counts.detail large numeric array number matches   mismatches, detail possible combination categories MergedPed dataframe side--side comparison two   pedigrees ConsensusPed consensus pedigree, Pedigree 2 taking priority   Pedigree 1 DummyMatch Dataframe dummy IDs Pedigree 2 (id.2), best-matching individual Pedigree 1 (id.1). Also includes class dam & sire, well counts offspring per outcome class (.Match, .Mismatch, etc.) Mismatch subset MergedPed mismatches Ped1 Ped2,  defined Ped1only Mismatches, parents Ped1 assigned   Ped2 Ped2only Mismatches, parents Ped2 missing   Ped1 'MergedPed', 'Mismatch', 'Ped1only' 'Ped2only' provide following columns: id ids Pedigree 1 2. dummy individuals, id pedigree 2 dam.1, sire.1 parents Pedigree 1 dam.2, sire.2 parents Pedigree 2 id.r, dam.r, sire.r real id dummy individuals parents Pedigree 2, .e. best-matching non-genotyped individual Pedigree 1, \"nomatch\". sibship Pedigree 1 divided 2 sibships Pedigree 2, smaller one denoted \"nomatch\" id.dam.cat, id.sire.cat category individual (first letter) highest category dam (sire) Pedigree 1 2: G=Genotyped, D=(potential) dummy, X=none. Individual, one-letter categories generated getAssignCat. Using 'best' category pedigrees makes comparison two inferred pedigrees symmetrical intuitive. dam.class, sire.class classification dam sire: Match, Mismatch, P1only, P2only, '_' parent assigned either pedigree first dimension Counts denotes following categories: GG Genotyped individual, assigned genotyped parent either   pedigree GD Genotyped individual, assigned dummy parent, least 1   genotyped sibling genotyped grandparent Pedigree 1) GT Genotyped individual, total DG Dummy individual, assigned genotyped parent (.e., grandparent    sibship Pedigree 2) DD Dummy individual, assigned dummy parent (.e., avuncular   relationship sibships Pedigree 2) DT Dummy total TT Total total, includes genotyped individuals, plus   non-genotyped individuals Pedigree 1, plus non-replaced dummy   individuals (see ) Pedigree 2 second dimension Counts gives outcomes: Total total number individuals parent assigned    either pedigrees Match parent assigned pedigrees (non-missing).      dummy parents, considered match inferred sibship      contains offspring non-genotyped parent, consists      half individual's offspring. Mismatch Different parents assigned two pedigrees.    sibship according Pedigree 1 split two sibships Pedigree    2, smaller fraction included count . P1only Parent Pedigree 1 2; includes non-assignable     parents (e.g. genotyped genotyped offspring). P2only Parent Pedigree 2 1. third dimension Counts separates maternal paternal assignments, e.g. paternal 'DT' assignment fathers maternal paternal sibships (.e., dummies sexes). 'ConsensusPed', priority used parent.r (\"nomatch\") >   parent.2 > parent.1. columns 'id.cat', dam.cat' 'sire.cat' two   additional levels compared 'MergedPed': G Genotyped D Dummy individual (Pedigree 2) R Dummy individual pedigree 2 replaced best matching     non-genotyped individual pedigree 1 U Ungenotyped, Unconfirmed (parent Pedigree 1, dummy     match Pedigree 2) X parent either pedigree","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare Two Pedigrees — PedCompare","text":"comparison divided different classes `assignable'   parents (getAssignCat). includes cases focal   individual parent according Ped1 Genotyped (G-G), well   cases non-genotyped parent according Ped1 can lined   sibship Dummy parent Ped2 (G-D), non-genotyped focal   individual Ped1 can matched dummy individual Ped2 (D-G   D-D). SNPd NULL (default), DumPrefix set NULL,   intersect IDs Pedigrees 1 2 taken vector   genotyped individuals.","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"assignable","dir":"Reference","previous_headings":"","what":"Assignable","title":"Compare Two Pedigrees — PedCompare","text":"Note 'assignable' may overly optimistic. parents   Ped1 indicated assignable may never assigned sequoia,   example parent-offspring pairs determined   older two, grandparents indistinguishable full   avuncular (.e. genetics inconclusive candidate parent   assigned, ageprior inconclusive).","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"dummifiable","dir":"Reference","previous_headings":"","what":"Dummifiable","title":"Compare Two Pedigrees — PedCompare","text":"Considered potential dummy individuals non-genotyped individuals   Pedigree 1 , according either pedigree, least 2 genotyped   offspring, least one genotyped offspring genotyped parent.","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"mismatches","dir":"Reference","previous_headings":"","what":"Mismatches","title":"Compare Two Pedigrees — PedCompare","text":"Perhaps unexpectedly, cases siblings correct dummy   parent rather genotyped Ped1-parent assigned, classified   mismatch (siblings). typically due   low assumed genotyping error rate, wrong parental birth year,   issue requires user inspection. identify cases,   ComparePairs may help.","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"genotyped-mystery-samples-","dir":"Reference","previous_headings":"","what":"Genotyped 'mystery samples'","title":"Compare Two Pedigrees — PedCompare","text":"Pedigree 2 includes samples ID unknown, behaviour  PedCompare depends whether temporary IDs samples  included SNPd. included, matching (actual) IDs  Pedigree 1 flagged mismatches (IDs differ).  included SNPd, SNPd explicitly provided,  matches accepted, situation indistinguishable comparing  dummy parents across pedigrees. course conditional relatives mystery sample  assigned Pedigree 2.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare Two Pedigrees — PedCompare","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/PedCompare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Two Pedigrees — PedCompare","text":"","code":"compare <- PedCompare(Ped_griffin, SeqOUT_griffin$Pedigree)  compare$Counts[\"TT\",,]  # totals only; 45 dams & 47 sires non-assigned #>           parent #> class      dam sire #>   Total    167  163 #>   Match    125  122 #>   Mismatch   0    0 #>   P1only    42   41 #>   P2only     0    0 compare$Counts[,,\"dam\"]  # dams only #>     class #> cat  Total Match Mismatch P1only P2only #>   GG    65    65        0      0      0 #>   GD    56    41        0     15      0 #>   GT   125   106        0     19      0 #>   DG    23    14        0      9      0 #>   DD    12     5        0      7      0 #>   DT    39    19        0     20      0 #>   TT   167   125        0     42      0  # inspect non-assigned in Ped2, id genotyped, dam might-be-dummy PedM <- compare$MergedPed  # for brevity PedM[PedM$id.dam.cat=='GD' & PedM$dam.class=='P1only',] #>              id       dam.1      sire.1 dam.2      sire.2        id.r dam.r #> 45  i028_2002_M i005_2001_F        <NA>  <NA>        <NA> i028_2002_M  <NA> #> 48  i033_2002_F i013_2001_F        <NA>  <NA>        <NA> i033_2002_F  <NA> #> 49  i034_2002_F i011_2001_F        <NA>  <NA>        <NA> i034_2002_F  <NA> #> 56  i044_2003_F i011_2001_F i019_2001_M  <NA>        <NA> i044_2003_F  <NA> #> 64  i055_2003_M i012_2001_F i040_2002_M  <NA> i040_2002_M i055_2003_M  <NA> #> 66  i059_2003_M i013_2001_F i036_2002_M  <NA> i036_2002_M i059_2003_M  <NA> #> 68  i062_2004_M i012_2001_F i058_2003_M  <NA>        <NA> i062_2004_M  <NA> #> 71  i067_2004_F i005_2001_F i029_2002_M  <NA> i029_2002_M i067_2004_F  <NA> #> 75  i072_2004_M i048_2003_F i010_2001_M  <NA>        <NA> i072_2004_M  <NA> #> 76  i073_2004_M i060_2003_F i003_2001_M  <NA>        <NA> i073_2004_M  <NA> #> 105 i113_2006_M i087_2005_F i053_2003_M  <NA>        <NA> i113_2006_M  <NA> #> 106 i114_2006_M i060_2003_F i090_2005_M  <NA>        <NA> i114_2006_M  <NA> #> 115 i127_2007_M i087_2005_F i085_2005_M  <NA>        <NA> i127_2007_M  <NA> #> 119 i132_2007_F i093_2005_F i117_2006_M  <NA>        <NA> i132_2007_F  <NA> #> 135 i157_2008_F i125_2007_F i082_2005_M  <NA>        <NA> i157_2008_F  <NA> #>     sire.r id.dam.cat id.sire.cat dam.class sire.class #> 45    <NA>         GD          GX    P1only          _ #> 48    <NA>         GD          GX    P1only          _ #> 49    <NA>         GD          GX    P1only          _ #> 56    <NA>         GD          GD    P1only     P1only #> 64    <NA>         GD          GG    P1only      Match #> 66    <NA>         GD          GG    P1only      Match #> 68    <NA>         GD          GD    P1only     P1only #> 71    <NA>         GD          GG    P1only      Match #> 75    <NA>         GD          GD    P1only     P1only #> 76    <NA>         GD          GX    P1only     P1only #> 105   <NA>         GD          GD    P1only     P1only #> 106   <NA>         GD          GD    P1only     P1only #> 115   <NA>         GD          GD    P1only     P1only #> 119   <NA>         GD          GD    P1only     P1only #> 135   <NA>         GD          GD    P1only     P1only # zoom in on specific dam PedM[which(PedM$dam.1==\"i011_2001_F\"), ] #>             id       dam.1      sire.1 dam.2 sire.2        id.r dam.r sire.r #> 49 i034_2002_F i011_2001_F        <NA>  <NA>   <NA> i034_2002_F  <NA>   <NA> #> 56 i044_2003_F i011_2001_F i019_2001_M  <NA>   <NA> i044_2003_F  <NA>   <NA> #>    id.dam.cat id.sire.cat dam.class sire.class #> 49         GD          GX    P1only          _ #> 56         GD          GD    P1only     P1only # no sire for 'i034_2002_F' -> impossible to tell if half-sibs or avuncular  # overview of all non-genotyped -- dummy matches head(compare$DummyMatch) #>    id.2        id.1 Sex dam.class sire.class off.Match off.Mismatch off.P1only #> 1 F0001 i115_2006_F   1    P1only      Match         4            0          1 #> 2 F0002 i140_2007_F   1     Match      Match         2            0          0 #> 3 F0003 i101_2006_F   1     Match      Match        11            0          3 #> 4 F0004 i032_2002_F   1         _     P1only         3            0          0 #> 5 F0005 i037_2002_F   1         _          _         2            0          0 #> 6 F0006 i155_2008_F   1     Match      Match         3            0          0 #>   off.P2only #> 1          0 #> 2          0 #> 3          0 #> 4          0 #> 5          0 #> 6          0  # success of paternity assignment, if genotyped mother correctly assigned dimnames(compare$Counts.detail) #> $id.cat #> [1] \"G\" \"D\" \"X\" #>  #> $dam.cat #> [1] \"G\" \"D\" \"X\" #>  #> $sire.cat #> [1] \"G\" \"D\" \"X\" #>  #> $dam.class #> [1] \"Match\"    \"Mismatch\" \"P1only\"   \"P2only\"   \"_\"        #>  #> $sire.class #> [1] \"Match\"    \"Mismatch\" \"P1only\"   \"P2only\"   \"_\"        #>  compare$Counts.detail[\"G\",\"G\",,\"Match\",] #>         sire.class #> sire.cat Match Mismatch P1only P2only  _ #>        G    41        0      0      0  0 #>        D    14        0      7      0  0 #>        X     0        0      1      0  2  # default before version 3.5: minSibSize = '2sib' compare_2s <- PedCompare(Ped_griffin, SeqOUT_griffin$Pedigree,                          minSibSize = '2sib')  compare_2s$Counts[,,\"dam\"]  # note decrease in Total 'dummies #>     class #> cat  Total Match Mismatch P1only P2only #>   GG    65    65        0      0      0 #>   GD    51    38        0     13      0 #>   GT   125   106        0     19      0 #>   DG     9     8        0      1      0 #>   DD     7     4        0      3      0 #>   DT    17    12        0      5      0 #>   TT   167   125        0     42      0 with(compare_2s$MergedPed, table(id.dam.cat, dam.class)) #>           dam.class #> id.dam.cat Match P1only  _ #>         DD     4      3  0 #>         DG     8      1  0 #>         DX     0      1 10 #>         GD    38     13  0 #>         GG    65      0  0 #>         GX     3      6 17 #>         XD     0      4  0 #>         XG     6      9  0 #>         XX     1      5  6 # some with id.cat = 'X' or dam.cat='X' are nonetheless dam.class='Match'"},{"path":"https://jiscah.github.io/reference/PedPolish.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix Pedigree — PedPolish","title":"Fix Pedigree — PedPolish","text":"Ensure parents & genotyped individuals included,   remove duplicates, rename columns, replace 0 NA v.v..","code":""},{"path":"https://jiscah.github.io/reference/PedPolish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix Pedigree — PedPolish","text":"","code":"PedPolish(   Pedigree,   gID = NULL,   ZeroToNA = TRUE,   NAToZero = FALSE,   DropNonSNPd = TRUE,   FillParents = FALSE,   KeepAllColumns = TRUE,   KeepAllRows = FALSE,   NullOK = FALSE,   LoopCheck = TRUE,   StopIfInvalid = TRUE )"},{"path":"https://jiscah.github.io/reference/PedPolish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix Pedigree — PedPolish","text":"Pedigree dataframe first 3 columns id, dam, sire. gID character vector ids genotyped individuals (rownames genotype matrix). ZeroToNA logical, replace 0's missing values NA's (defaults TRUE). NAToZero logical, replace NA's missing values 0's. TRUE, ZeroToNA automatically set FALSE. DropNonSNPd logical, remove non-genotyped individuals (keep non-genotyped parents), & sort pedigree order gID. FillParents logical, individuals 1 parent assigned, set parent dummy (without assigning siblings grandparents). Makes pedigree compatible R packages software requires individuals either 2 0 parents, kinship. KeepAllColumns Keep columns Pedigree (TRUE, default), id - dam - sire (FALSE). KeepAllRows Keep rows Pedigree (TRUE), drop rows id = NA (FALSE, default). Duplicated rows always removed. NullOK logical, OK Ped NULL? NULL returned. LoopCheck logical, check invalid pedigree loops calling getGenerations. StopIfInvalid pedigree loop detected, stop error (TRUE, default).","code":""},{"path":"https://jiscah.github.io/reference/PedPolish.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fix Pedigree — PedPolish","text":"Recognized column names exact partial match (case ignored): id \"id\", \"iid\", \"\" dam \"dam\", \"mother\", \"mot\", \"mom\", \"mum\", \"mat\" sire \"sire\", \"father\", \"fat\", \"dad\", \"pat\" sequoia requires column order id - dam - sire; columns 2 3 swapped function necessary.","code":""},{"path":"https://jiscah.github.io/reference/PedPolish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fix Pedigree — PedPolish","text":"","code":"if (FALSE) { # To get the output pedigree into kinship2 compatible format: PedP <- sequoia::PedPolish(SeqOUT$Pedigree, DropNonSNPd=FALSE,                            FillParents = TRUE) PedP$Sex <- with(PedP, ifelse(id %in% dam, \"female\",  \"male\")) # default to 'male' to avoid warning: \"More than 25% of the gender values are #  'unknown'\"  Ped.fix <- with(PedP, kinship2::fixParents(id=id, dadid=sire, momid=dam,                                            sex=Sex)) Ped.k <- with(Ped.fix, kinship2::pedigree(id, dadid, momid, sex, missid=0)) }"},{"path":"https://jiscah.github.io/reference/PedStripFID.html","id":null,"dir":"Reference","previous_headings":"","what":"Back-transform IDs — PedStripFID","title":"Back-transform IDs — PedStripFID","text":"Reverse joining FID IID GenoConvert LHConvert","code":""},{"path":"https://jiscah.github.io/reference/PedStripFID.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back-transform IDs — PedStripFID","text":"","code":"PedStripFID(Ped, FIDsep = \"__\")"},{"path":"https://jiscah.github.io/reference/PedStripFID.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back-transform IDs — PedStripFID","text":"Ped pedigree returned sequoia (e.g. SeqOUT$Pedigree). FIDsep characters inbetween FID IID composite-ID.","code":""},{"path":"https://jiscah.github.io/reference/PedStripFID.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Back-transform IDs — PedStripFID","text":"pedigree 6 columns FID family ID focal individual (offspring). id within-family focal individual dam.FID original family ID assigned dam dam within-family dam sire.FID original family ID assigned sire sire within-family sire","code":""},{"path":"https://jiscah.github.io/reference/PedStripFID.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Back-transform IDs — PedStripFID","text":"Note family IDs ones provided,  automatically updated. New, numeric ones can obtained   FindFamilies.","code":""},{"path":"https://jiscah.github.io/reference/PedToNum.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn Character Pedigree into Numeric Pedigree — PedToNum","title":"Turn Character Pedigree into Numeric Pedigree — PedToNum","text":"Genotyped individuals get rownumber genotype matrix,   non-genotyped individuals either get arbitrary negative number   (DoDummies = 'new') individuals dummy ID get   corresponding negative number (DoDummies = 'old'). Note   number series overlap dummy males dummy females.","code":""},{"path":"https://jiscah.github.io/reference/PedToNum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn Character Pedigree into Numeric Pedigree — PedToNum","text":"","code":"PedToNum(   Pedigree = NULL,   gID = NULL,   DoDummies = \"new\",   DumPrefix = c(\"F0\", \"M0\") )"},{"path":"https://jiscah.github.io/reference/PedToNum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn Character Pedigree into Numeric Pedigree — PedToNum","text":"Pedigree dataframe id - dam - sire. assumed PedPolish called beforehand column names correct columns .character. gID vector IDs SNP-genotyped individuals. DoDummies 'new', 'old', '' (ignore non-genotyped individuals). DumPrefix Prefix identify dummies DoDummies = 'old'","code":""},{"path":"https://jiscah.github.io/reference/PedToNum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn Character Pedigree into Numeric Pedigree — PedToNum","text":"list PedPar nInd x 2 matrix numeric IDs parents     genotyped individuals DumPar matrix parents dummies, see     FoldSibGPs Renamed length-2 list (dams, sires) element dataframe     columns: 'name' (original character ID), 'num' (number ID, negative)     dummified individual Nd length 2 vector, . dummies found/created dams sires","code":""},{"path":"https://jiscah.github.io/reference/PedToNum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turn Character Pedigree into Numeric Pedigree — PedToNum","text":"DoDummies='new', GetDummifiable used   minSibSize = \"1sib\", existing dummy coding ignored   (F0001, F0002 may become -3, -6). DoDummies='old', existing   dummy coding respected (F0001, F0002 become -1, -2),   non-genotyped individuals ignored.","code":""},{"path":"https://jiscah.github.io/reference/Ped_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example pedigree: griffins — Ped_griffin","title":"Example pedigree: griffins — Ped_griffin","text":"Example pedigree overlapping generations polygamy.","code":""},{"path":"https://jiscah.github.io/reference/Ped_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example pedigree: griffins — Ped_griffin","text":"","code":"data(Ped_griffin)"},{"path":"https://jiscah.github.io/reference/Ped_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example pedigree: griffins — Ped_griffin","text":"data frame 200 rows 4 variables (id, dam, sire, birthyear)","code":""},{"path":"https://jiscah.github.io/reference/Ped_griffin.html","id":"code","dir":"Reference","previous_headings":"","what":"Code","title":"Example pedigree: griffins — Ped_griffin","text":"R code used create pedigree can found /data-raw.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Ped_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example pedigree: griffins — Ped_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/Ped_HSg5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example pedigree: 'HSg5' — Ped_HSg5","title":"Example pedigree: 'HSg5' — Ped_HSg5","text":"pedigree five non-overlapping generations considerable inbreeding. female mated two random males male three random females, producing four full-sib offspring per mating. Pedigree II paper.","code":""},{"path":"https://jiscah.github.io/reference/Ped_HSg5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example pedigree: 'HSg5' — Ped_HSg5","text":"","code":"data(Ped_HSg5)"},{"path":"https://jiscah.github.io/reference/Ped_HSg5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example pedigree: 'HSg5' — Ped_HSg5","text":"data frame 1000 rows 3 variables (id, dam, sire)","code":""},{"path":"https://jiscah.github.io/reference/Ped_HSg5.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example pedigree: 'HSg5' — Ped_HSg5","text":"Huisman, J. (2017) Pedigree reconstruction SNP data:   Parentage assignment, sibship clustering, beyond. Molecular Ecology   Resources 17:1009--1024.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/Ped_HSg5.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example pedigree: 'HSg5' — Ped_HSg5","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/PlotAgePrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Age Priors — PlotAgePrior","title":"Plot Age Priors — PlotAgePrior","text":"Visualise age-difference based prior probability ratios   heatmap.","code":""},{"path":"https://jiscah.github.io/reference/PlotAgePrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Age Priors — PlotAgePrior","text":"","code":"PlotAgePrior(AP = NULL, legend = TRUE)"},{"path":"https://jiscah.github.io/reference/PlotAgePrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Age Priors — PlotAgePrior","text":"AP matrix age priors (\\(P(|R)/P()\\)) age differences rows relationships columns; default M: maternal parent (mother), P: paternal parent (father), FS: full siblings, MS: maternal siblings (full + half), PS: paternal siblings. legend TRUE, new plotting window started layout used plot legend next main plot. Set FALSE want add panel existing plot (e.g. par(mfcol=c(2,2))).","code":""},{"path":"https://jiscah.github.io/reference/PlotAgePrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Age Priors — PlotAgePrior","text":"heatmap.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/PlotAgePrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Age Priors — PlotAgePrior","text":"","code":"PlotAgePrior(SeqOUT_griffin$AgePriors)  PlotAgePrior(SeqOUT_griffin$AgePriorExtra)"},{"path":"https://jiscah.github.io/reference/PlotPairLL.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Pair Log10-Likelihoods — PlotPairLL","title":"Plot Pair Log10-Likelihoods — PlotPairLL","text":"Colour-coded scatter plots e.g. LLR(PO/U) LLR(FS/U),   various relationship combinations.","code":""},{"path":"https://jiscah.github.io/reference/PlotPairLL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Pair Log10-Likelihoods — PlotPairLL","text":"","code":"PlotPairLL(   PairLL,   combo = list(c(\"FS\", \"PO\"), c(\"HS\", \"FS\"), c(\"GP\", \"HS\"), c(\"FA\", \"HS\")),   nrows = NULL,   ncols = NULL,   bgcol = TRUE,   Tassign = 0.5,   Tfilter = -2 )"},{"path":"https://jiscah.github.io/reference/PlotPairLL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Pair Log10-Likelihoods — PlotPairLL","text":"PairLL dataframe, output CalcPairLL. combo list length-2 character vectors, specifying likelihoods plot . Choose 'PO', 'FS', 'HS', 'GP', 'FA', 'HA'. first one gets plotted x-axis, second y-axis. Subsequent figures drawn row-wise. nrows number rows figure layout. NULL, set ceiling(length(combo)/ncols). ncols number columns figure layout. nrows ncols NULL, ncols set ceiling(sqrt(length(combo))), nrows equal ncols one less. bgcol logical, colour upper lower triangle background figure match specified relationship combo. Tassign assignment threshold, shown grey square bottom-left corner band along diagonal. Tfilter filter threshold, shown dark grey square bottom-left.","code":""},{"path":"https://jiscah.github.io/reference/PlotPairLL.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Pair Log10-Likelihoods — PlotPairLL","text":"colour point determined columns focal   (outer circle) TopRel (inner filling) PairLL. Impossible relationships (LL > 0 PairLL) shown -Inf   axes, present.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/PlotPairLL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Pair Log10-Likelihoods — PlotPairLL","text":"","code":"Pairs <- data.frame(ID1 = \"a01005\",                     ID2 = c(\"a00013\", \"a00008\", \"a00011\", \"b00001\",                             \"b01006\", \"b01007\", \"b01013\", \"b01014\"),                     focal = rep(c(\"PO\", \"HS\"), each=4)) PLL <- CalcPairLL(Pairs, GenoM=SimGeno_example, Plot=FALSE) PlotPairLL(PLL,            combo = list(c(\"FS\", \"PO\"), c(\"HS\", \"FS\"), c(\"GP\", \"HS\"),                         c(\"FA\", \"HS\"), c(\"HA\", \"FA\"), c(\"FA\", \"GP\")),            nrows = 3)"},{"path":"https://jiscah.github.io/reference/PlotPedComp.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise PedCompare Output — PlotPedComp","title":"Visualise PedCompare Output — PlotPedComp","text":"square Venn diagrams PedCompare   Counts.","code":""},{"path":"https://jiscah.github.io/reference/PlotPedComp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise PedCompare Output — PlotPedComp","text":"","code":"PlotPedComp(Counts, sameSize = FALSE)"},{"path":"https://jiscah.github.io/reference/PlotPedComp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise PedCompare Output — PlotPedComp","text":"Counts 7x5x2 array counts matches mismatches per category (genotyped vs dummy), returned PedCompare. sameSize logical, make per-category Venn diagrams size TRUE, make size proportional counts (FALSE, default). TRUE, warning printed bottom.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/PlotPedComp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualise PedCompare Output — PlotPedComp","text":"","code":"PC.g <- PedCompare(Ped1 = cbind(FieldMums_griffin, sire=NA),                    Ped2 = SeqOUT_griffin$Pedigree) PlotPedComp(PC.g$Counts)"},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Pairwise Relationships — PlotRelPairs","title":"Plot Pairwise Relationships — PlotRelPairs","text":"Plot pairwise 1st 2nd degree relationships   individuals, similar Colony's dyad plot.","code":""},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Pairwise Relationships — PlotRelPairs","text":"","code":"PlotRelPairs(   RelM = NULL,   subset.x = NULL,   subset.y = NULL,   drop.U = TRUE,   pch.symbols = FALSE,   cex.axis = 0.7,   mar = c(5, 5, 1, 8) )"},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Pairwise Relationships — PlotRelPairs","text":"RelM square matrix relationships pairs individuals, generated GetRelM. Row column names individual IDs. subset.x vector IDs show x-axis; y-axis include siblings, parents grandparents individuals. subset.y vector IDs show y-axis; x-axis include siblings, offspring grandoffspring individuals. Specify either subset.x subset.y (neither), . drop.U logical: omit individuals without relatives plot, omit individuals without parents x-axis. Ignored subset.x subset.y specified. pch.symbols logical: use different symbols different relationships (TRUE) colours heatmap-like fashion (FALSE). Question marks plot indicate one symbols supported machine. cex.axis magnification used axis annotation. Decrease value R dropping axis labels prevent overlapping. mar numerical vector form c(bottom, left, top, right) gives number lines margin specified four sides plot.","code":""},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Pairwise Relationships — PlotRelPairs","text":"subsetted, rearranged RelM returned  invisible. numbers unique pairs relationship type given   figure legend. number 'self' pairs refers number   individuals x-axis, may occur y-axis  drop.U=TRUE subset specified.","code":""},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Pairwise Relationships — PlotRelPairs","text":"Parents shown diagonal (y-axis parent x-axis),   siblings diagonal. present, grandparents full aunts/uncles   also shown diagonal. Individuals sorted dam ID   sire ID siblings grouped together, generation   (getGenerations) later generations closer   origin. RelM based dataframe pairs rather pedigree,   parents grandparents similarly displayed diagonal,   order individuals arbitrary ID x-axis   likely grandparent one y-axis vice versa. Second   degree relatives unknown classification ('2nd', may HS, GP FA)   shown diagonal. switch pedigree-based versus   pairs-based made whether parent-offspring pairs coded 'M','P',   'MP', 'O' (unidirectional, pedigree) 'PO' (bidirectional,   pairs). Note half-avuncular (double) full cousin pairs ignored.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/PlotRelPairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Pairwise Relationships — PlotRelPairs","text":"","code":"Rel.griffin <- GetRelM(Ped_griffin, patmat=TRUE, GenBack=2) PlotRelPairs(Rel.griffin)   if (FALSE) { PlotRelPairs(Rel.griffin, pch.symbols = TRUE) # plot with unicode symbols not supported on all platforms }  # parents & grandparents of 2008 cohort: PlotRelPairs(Rel.griffin,              subset.x = Ped_griffin$id[Ped_griffin$birthyear ==2008])  # offspring & grand-offspring of 2002 cohort: PlotRelPairs(Rel.griffin,              subset.y = Ped_griffin$id[Ped_griffin$birthyear ==2002])"},{"path":"https://jiscah.github.io/reference/PlotSeqSum.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Summary Overview of sequoia Output — PlotSeqSum","title":"Plot Summary Overview of sequoia Output — PlotSeqSum","text":"visualise numbers assigned parents, sibship sizes,   parental LLRs","code":""},{"path":"https://jiscah.github.io/reference/PlotSeqSum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Summary Overview of sequoia Output — PlotSeqSum","text":"","code":"PlotSeqSum(SeqSum, Pedigree = NULL, Panels = \"all\", ask = TRUE)"},{"path":"https://jiscah.github.io/reference/PlotSeqSum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Summary Overview of sequoia Output — PlotSeqSum","text":"SeqSum list output SummarySeq. Pedigree dataframe least id, dam sire columns 1-3, respectively. columns parental LLRs /Mendelian errors present, plotted well. Panels character vector panel(s) plot. Choose '', 'G.parents' (parents genotyped individuals), 'D.parents' (parents dummies), 'O.parents' (parents non-genotyped non-dummies), sibships', 'LLR', 'OH'. ask ask user key stroke proceeding next plot.","code":""},{"path":"https://jiscah.github.io/reference/PlotSeqSum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Summary Overview of sequoia Output — PlotSeqSum","text":"","code":"sumry <- SummarySeq(SeqOUT_griffin, Plot=FALSE) PlotSeqSum(sumry, SeqOUT_griffin$Pedigree, Panels='all', ask=FALSE)"},{"path":"https://jiscah.github.io/reference/PlotSnpStats.html","id":null,"dir":"Reference","previous_headings":"","what":"plot SnpStats results — PlotSnpStats","title":"plot SnpStats results — PlotSnpStats","text":"scatter plots histograms allele frequency, missingness,   estimated genotyping error, across SNPs","code":""},{"path":"https://jiscah.github.io/reference/PlotSnpStats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot SnpStats results — PlotSnpStats","text":"","code":"PlotSnpStats(OUT)"},{"path":"https://jiscah.github.io/reference/PlotSnpStats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot SnpStats results — PlotSnpStats","text":"output SnpStats","code":""},{"path":"https://jiscah.github.io/reference/PlotSnpStats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot SnpStats results — PlotSnpStats","text":"plots","code":""},{"path":"https://jiscah.github.io/reference/rc.html","id":null,"dir":"Reference","previous_headings":"","what":"Find siblings — rc","title":"Find siblings — rc","text":"Find siblings","code":""},{"path":"https://jiscah.github.io/reference/rc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find siblings — rc","text":"","code":"rc(x, Ped)"},{"path":"https://jiscah.github.io/reference/rc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find siblings — rc","text":"x ID Ped pedigree columns id - dam - sire","code":""},{"path":"https://jiscah.github.io/reference/rc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find siblings — rc","text":"individuals full half siblings x,   three-column matrix column names id1 (x), id2 (siblings),   RC (relatedness category, 'FS' 'HS').","code":""},{"path":"https://jiscah.github.io/reference/SelectNotSampled.html","id":null,"dir":"Reference","previous_headings":"","what":"select non-genotyped parents — SelectNotSampled","title":"select non-genotyped parents — SelectNotSampled","text":"select non-genotyped parents","code":""},{"path":"https://jiscah.github.io/reference/SelectNotSampled.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"select non-genotyped parents — SelectNotSampled","text":"","code":"SelectNotSampled(Ped, ParMis)"},{"path":"https://jiscah.github.io/reference/SelectNotSampled.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"select non-genotyped parents — SelectNotSampled","text":"Ped pedigree, PedPolish() ParMis single number vector length two proportion parents fully missing genotype","code":""},{"path":"https://jiscah.github.io/reference/SelectNotSampled.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"select non-genotyped parents — SelectNotSampled","text":"vector genotype matrix row numbers non-sampled individuals","code":""},{"path":"https://jiscah.github.io/reference/SeqOUT_griffin.html","id":null,"dir":"Reference","previous_headings":"","what":"Example output from pedigree inference: griffins — SeqOUT_griffin","title":"Example output from pedigree inference: griffins — SeqOUT_griffin","text":"Example output sequoia run including sibship clustering,   Geno_griffin input (simulated   Ped_griffin).","code":""},{"path":"https://jiscah.github.io/reference/SeqOUT_griffin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example output from pedigree inference: griffins — SeqOUT_griffin","text":"","code":"data(SeqOUT_griffin)"},{"path":"https://jiscah.github.io/reference/SeqOUT_griffin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example output from pedigree inference: griffins — SeqOUT_griffin","text":"list, see sequoia","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SeqOUT_griffin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example output from pedigree inference: griffins — SeqOUT_griffin","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/SeqOUT_griffin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example output from pedigree inference: griffins — SeqOUT_griffin","text":"","code":"if (FALSE) { SeqOUT_griffin <- sequoia(GenoM = Geno_griffin,                           LifeHistData = LH_griffin,                           Module = 'ped') }"},{"path":"https://jiscah.github.io/reference/SeqOUT_HSg5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","title":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","text":"Example output sequoia run including sibship   clustering, based Pedigree Geno_HSg5.","code":""},{"path":"https://jiscah.github.io/reference/SeqOUT_HSg5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","text":"","code":"data(SeqOUT_HSg5)"},{"path":"https://jiscah.github.io/reference/SeqOUT_HSg5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","text":"list, see sequoia","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SeqOUT_HSg5.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/SeqOUT_HSg5.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example output from pedigree inference: 'HSg5' — SeqOUT_HSg5","text":"","code":"if (FALSE) { # this output was created as follows: Geno <- SimGeno(Ped = Ped_HSg5, nSnp = 200) SeqOUT_HSg5 <- sequoia(GenoM = Geno, LifeHistData = LH_HSg5, Module = \"ped\",                        Err = 0.005) } # some ways to inspect the output; see vignette for more info: names(SeqOUT_HSg5) #>  [1] \"Specs\"            \"ErrM\"             \"args.AP\"          \"Snps-LowCallRate\" #>  [5] \"AgePriors\"        \"LifeHist\"         \"DupLifeHistID\"    \"NoLH\"             #>  [9] \"PedigreePar\"      \"TotLikPar\"        \"LifeHistPar\"      \"Pedigree\"         #> [13] \"DummyIDs\"         \"TotLikSib\"        \"AgePriorExtra\"    \"LifeHistSib\"      SeqOUT_HSg5$Specs #>       NumberIndivGenotyped NumberSnps GenotypingErrorRate MaxMismatchDUP #> Specs                  920        200               0.005             11 #>       MaxMismatchOH MaxMismatchME Tfilter Tassign nAgeClasses MaxSibshipSize #> Specs             5             8      -2     0.5           6            100 #>       Module DummyPrefixFemale DummyPrefixMale Complexity Herm UseAge CalcLLR #> Specs    ped                 F               M       full   no    yes    TRUE #>       ErrFlavour SequoiaVersion           TimeStart             TimeEnd #> Specs version2.0         2.3.18 2022-12-17 13:26:47 2022-12-17 13:29:23 SummarySeq(SeqOUT_HSg5)"},{"path":"https://jiscah.github.io/reference/SeqParSib.html","id":null,"dir":"Reference","previous_headings":"","what":"Fortran Wrapper for Pedigree Reconstruction — SeqParSib","title":"Fortran Wrapper for Pedigree Reconstruction — SeqParSib","text":"Call main Fortran part sequoia, convert output   list dataframes.","code":""},{"path":"https://jiscah.github.io/reference/SeqParSib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fortran Wrapper for Pedigree Reconstruction — SeqParSib","text":"","code":"SeqParSib(   ParSib,   FortPARAM,   GenoM,   LhIN,   AgePriors,   Parents,   mtDif,   DumPfx,   quiet )"},{"path":"https://jiscah.github.io/reference/SeqParSib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fortran Wrapper for Pedigree Reconstruction — SeqParSib","text":"ParSib either \"par\" call parentage assignment, \"sib\" call rest algorithm. FortPARAM named vector parameter values, generated ParamToSpecs. GenoM matrix genotype data, size nInd x nSnp. LhIN life history data: ID - sex - birth year. AgePriors matrix agepriors, size `FortPARAM[\"nAgeClasses\"]` 8. Parents matrix rownumbers assigned parents, size nInd 2. mtDif matrix indicating whether individuals definitely different mitochondrial haplotype (1), (possibly) (0). Size nInd x nInd. DumPfx dummy prefixes quiet suppress messages.","code":""},{"path":"https://jiscah.github.io/reference/SeqParSib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fortran Wrapper for Pedigree Reconstruction — SeqParSib","text":"list PedigreePar Pedigree pedigree DummyIDs Info dummies (included parentage-) TotLikParents TotLikSib Total log-likelihood per iteration AgePriorExtra Ageprior including columns grandparental   avuncular relationships LifeHistPar LifeHistSib Includes sex birthyear estimate   inferred pedigree individuals initially unknown sex   /birthyear . detailed description output see sequoia.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":null,"dir":"Reference","previous_headings":"","what":"Pedigree Reconstruction — sequoia","title":"Pedigree Reconstruction — sequoia","text":"Perform pedigree reconstruction based SNP data, including   parentage assignment sibship clustering.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pedigree Reconstruction — sequoia","text":"","code":"sequoia(   GenoM = NULL,   LifeHistData = NULL,   SeqList = NULL,   Module = \"ped\",   Err = 1e-04,   Tfilter = -2,   Tassign = 0.5,   MaxSibshipSize = 100,   DummyPrefix = c(\"F\", \"M\"),   Complex = \"full\",   Herm = \"no\",   UseAge = \"yes\",   args.AP = list(Flatten = NULL, Smooth = TRUE),   mtSame = NULL,   CalcLLR = TRUE,   quiet = FALSE,   Plot = NULL,   StrictGenoCheck = TRUE,   ErrFlavour = \"version2.0\",   MaxSibIter = 42,   MaxMismatch = NA,   FindMaybeRel = FALSE )"},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pedigree Reconstruction — sequoia","text":"GenoM numeric matrix genotype data: One row per individual, one column per SNP, coded 0, 1, 2 -9 (missing). See also GenoConvert. LifeHistData data.frame 6 columns: ID max. 30 characters long Sex 1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,            numbers NA = unknown BirthYear birth hatching year, integer, missing values NA   negative number. .min minimum birth year, used BirthYear missing .max maximum birth year, used BirthYear missing Year.last Last year individual offspring. Can   e.g. mammals year death females, year death   males. \"Birth year\" may arbitrary discrete time unit relevant species (day, month, decade), long parents never born time unit offspring, integers used. Individuals need order `GenoM', genotyped individuals need included. SeqList list output previous run, re-used current run. Used elements `PedigreePar', `LifeHist', `AgePriors', `Specs', `ErrM', override corresponding input parameters. elements need present, elements ignored. SeqList$Specs provided,  input parameters name items ignored, except Module/MaxSibIter. Module one pre input check, return SeqList$Specs dup Also check duplicate genotypes par Also perform parentage assignment (genotyped parents     genotyped offspring) ped (Also) perform full pedigree reconstruction, including     sibship clustering grandparent assignment. far time     consuming, may take several hours large datasets. NOTE: `MaxSibIter` fully deprecated: `MaxSibIter` differs default (42), `Module` equals default ('ped'), MaxSibIter overrides `Module`. Err estimated genotyping error rate, single number, length 3 vector P(hom|hom), P(het|hom), P(hom|het), 3x3 matrix. See details . error rate presumed constant across SNPs, missingness presumed random respect actual genotype. Using Err >5% recommended, Err >10% strongly discouraged. Tfilter threshold log10-likelihood ratio (LLR) proposed relationship versus unrelated, select candidate relatives. Typically negative value, related fact unconditional likelihoods calculated filtering steps. negative values may decrease non-assignment, increase computational time. Tassign minimum LLR required acceptance proposed relationship, relative next likely relationship. Higher values result conservative assignments. Must zero positive. MaxSibshipSize maximum number offspring single individual (generous safety margin advised). DummyPrefix character vector length 2 prefixes dummy dams (mothers) sires (fathers); maximum 20 characters . Length 3 vector case hermaphrodites (default prefix 'H'). Complex Breeding system complexity. Either \"full\" (default), \"simp\" (simplified, explicit consideration inbred relationships), \"mono\" (monogamous). Herm Hermaphrodites, either \"\", \"\" (distinguish dam sire role, default least 1 individual sex=4), \"B\" (distinction dam sire role). latter deal selfing. UseAge either \"yes\" (default), \"\" (use age differences filtering), \"extra\" (additional rounds extra reliance ageprior, may boost assignments increased risk erroneous assignments). Used full reconstruction . args.AP list arguments passed MakeAgePrior, e.g. `Discrete` (non-overlapping generations), `MinAgeParent`, `MaxAgeParent`. mtSame NEW matrix indicating whether individuals (might) mitochondrial haplotype (1), may thus matrilineal relatives, (0). Row names column names match IDs `GenoM`. individuals need included order important. Please report issues. details see mtDNA vignette. CalcLLR TRUE/FALSE; calculate log-likelihood ratios assigned parents (genotyped + dummy; parent vs. otherwise related). Time-consuming large datasets. Can done separately CalcOHLLR. quiet suppress messages: TRUE/FALSE/\"verbose\". Plot display plots SnpStats, MakeAgePrior, SummarySeq. Defaults (NULL) TRUE quiet=FALSE \"verbose\", FALSE quiet=TRUE. get error 'figure margins large', enlarge plotting area (drag mouse). Error 'invalid graphics state' can dealt clearing plotting area dev.(). StrictGenoCheck Automatically exclude individuals genotyped <5 unavoidable default version 2.4.1. Otherwise excluded (nearly) monomorphic SNPs, SNPs scored fewer 2 individuals, individuals scored fewer 2 SNPs. ErrFlavour function takes Err (single number) input, returns length 3 vector 3x3 matrix, choose inbuilt options 'version2.9', 'version2.0', 'version1.3', 'version1.1', referring sequoia version default. Ignored Err vector matrix. See ErrToM details. MaxSibIter DEPRECATED, use Module number iterations sibship clustering, including assignment grandparents sibships avuncular relationships sibships. Clustering continues convergence MaxSibIter reached. Set 0 parentage assignment . MaxMismatch DEPRECATED IGNORED. Now calculated automatically using CalcMaxMismatch. FindMaybeRel DEPRECATED IGNORED, advised run GetMaybeRel separately.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pedigree Reconstruction — sequoia","text":"list following components, depending  Module. input except GenoM included output. AgePriors Matrix age-difference based probability ratios   relationship, used full pedigree reconstruction; see   MakeAgePrior details. running parentage   assignment (Module=\"par\") returned AgePriors updated   incorporate information assigned parents, ready use   full pedigree reconstruction. args.AP (input) arguments used specify age prior matrix.   custom ageprior provided via SeqList$AgePrior, matrix   returned instead DummyIDs Dataframe pedigree dummy individuals, well sex, estimated birth year (point estimate, upper lower bound 95% confidence interval; see also CalcBYprobs), number offspring, offspring IDs. version 2.1 onwards, includes dummy offspring. DupGenotype Dataframe, duplicated genotypes (different IDs,  duplicate IDs allowed). specified number maximum mismatches   used . Note dataframe may include pairs closely   related individuals, monozygotic twins. DupLifeHistID Dataframe, row numbers duplicated IDs life   history dataframe. convenience , may signal problem.   first entry used. ErrM (input) Error matrix; probability observed genotype (columns)   conditional actual genotype (rows) ExcludedInd Individuals GenoM excluded   low genotyping success rate (<50%). ExcludedSNPs Column numbers SNPs GenoM excluded   low genotyping success rate (<10%). LifeHist (input) Dataframe sex birth year data. missing   birth years coded '-999', missing sex '3'. LifeHistPar LifeHist additional columns 'Sexx' (inferred Sex assigned part parent-pair), '.est' (mode birth year probability distribution), '.lo' (lower limit 95% highest density region), '.hi' (higher limit), inferred parentage assignment. '.est' NA probability distribution flat '.lo' '.hi'. LifeHistSib LifeHistPar, estimated full pedigree reconstruction NoLH Vector, IDs genotype data life history data  provided. Pedigree Dataframe assigned genotyped dummy parents   Sibship step; entries dummy individuals added bottom. PedigreePar Dataframe assigned parents Parentage step. Specs Named vector parameter values. TotLikParents Numeric vector, Total likelihood genotype data   initiation iteration Parentage. TotLikSib Numeric vector, Total likelihood genotype data   initiation iteration Sibship clustering. AgePriorExtra AgePriors, including columns grandparents  avuncular pairs. updated parentage assignment, returned  used run. DummyClones Hermaphrodites : female-male dummy ID pairs refer   non-genotyped individual List elements PedigreePar Pedigree following columns: id Individual ID dam Assigned mother, NA sire Assigned father, NA LLRdam Log10-Likelihood Ratio (LLR) female mother,  versus next likely relationship focal individual  female. See Details relationships considered, see  CalcPairLL underlying likelihood values  details) LLRsire idem, male parent LLRpair LLR parental pair, versus next likely   configuration three individuals (one neither parent   assigned) OHdam Number loci offspring mother    opposite homozygotes OHsire idem, father MEpair Number Mendelian errors offspring    parent pair, includes OH well e.g. parents opposing    homozygotes, offspring heterozygote. offspring    OH parents counted 2 errors.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pedigree Reconstruction — sequoia","text":"pair candidate relatives, likelihoods calculated   parent-offspring (PO), full siblings (FS), half siblings   (HS), grandparent-grandoffspring (GG), full avuncular (niece/nephew -   aunt/uncle; FA), half avuncular/great-grandparental/cousins (HA),   unrelated (U). Assignments made likelihood ratio (LLR)   focal relationship likely alternative exceed threshold   Tassign. Dummy parents sibships denoted F0001, F0002, ... (mothers)   M0001, M0002, ... (fathers), appended bottom   pedigree, may assigned real dummy parents (.e.   sibship-grandparents). dummy parent assigned singletons. Full explanation various options interpretation output   provided vignettes package website,   https://jiscah.github.io/index.html .","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"genotyping-error-rate","dir":"Reference","previous_headings":"","what":"Genotyping error rate","title":"Pedigree Reconstruction — sequoia","text":"genotyping error rate Err can specified three different ways: single number, combined ErrFlavour      ErrToM create length 3 vector (next item).      default (ErrFlavour = 'version2.9'), P(hom|hom)=$(E/2)^2$,      P(het|hom)=$E-(E/2)^2$, P(hom|het)=$E/2$. length 3 vector (NEW version 2.6), probabilities     observe actual homozygote homozygote (hom|hom), observe     homozygote heterozygote (het|hom), observe actual     heterozygote homozygote (hom|het). assumes two alleles     equivalent respect genotyping errors, .e. $P(AA|aa) =     P(aa|AA)$, $P(aa|Aa)=P(AA|Aa)$, $P(aA|aa)=P(aA|AA)$. 3x3 matrix, probabilities observed genotype (columns)     conditional actual genotype (rows). needed assumption     previous item hold. See ErrToM details.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"-too-few-assignments-","dir":"Reference","previous_headings":"","what":"(Too) Few Assignments?","title":"Pedigree Reconstruction — sequoia","text":"Possibly Err much lower actual genotyping error rate. Alternatively, true parent assigned : unclear parent offspring, due unknown birth   year one individuals unclear whether parent father mother unclear parent e.g. full sibling grandparent, due   insufficient genetic data true half-siblings clustered : unclear maternal paternal half-siblings unclear half-siblings, full avuncular, grand-parental unclear type relatives due insufficient genetic    data pairs non-assigned likely/definitely relatives can found  GetMaybeRel. method pairwise 'assignments', see  https://jiscah.github.io/articles/pairLL_classification.html ;  information, see vignette.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"disclaimer","dir":"Reference","previous_headings":"","what":"Disclaimer","title":"Pedigree Reconstruction — sequoia","text":"every effort made ensure sequoia provides claims , absolutely guarantee results provided correct. Use sequoia entirely risk.","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"website","dir":"Reference","previous_headings":"","what":"Website","title":"Pedigree Reconstruction — sequoia","text":"https://jiscah.github.io/","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pedigree Reconstruction — sequoia","text":"Huisman, J. (2017) Pedigree reconstruction SNP data:   Parentage assignment, sibship clustering, beyond. Molecular Ecology   Resources 17:1009--1024.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pedigree Reconstruction — sequoia","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/sequoia.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pedigree Reconstruction — sequoia","text":"","code":"# ===  EXAMPLE 1: simulated data  === head(SimGeno_example[,1:10]) #>        V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 #> a00013  0  0  0  1  0  0  0  1   0   2 #> a00008  1  1  1  1  2  1  1  1   1   0 #> a00011  0  2  1  2  2  1  0  2   0   0 #> a00023  0  0  1  1  1  0  0  0   2   0 #> a00006  1  1  1  0  0  0  0  0   1   1 #> a00004  0  1  1  1  2  1  1  0   0   1 head(LH_HSg5) #>       ID Sex BirthYear #> 1 a00001   1      2000 #> 2 a00002   1      2000 #> 3 a00003   1      2000 #> 4 a00004   1      2000 #> 5 a00005   1      2000 #> 6 a00006   1      2000 # parentage assignment: SeqOUT <- sequoia(GenoM = SimGeno_example, Err = 0.005,                   LifeHistData = LH_HSg5, Module=\"par\", Plot=TRUE) #> Genotype matrix looks OK! There are  214  individuals and  200  SNPs. #> There are 106 females, 108 males, 0 individuals of unknown sex, and 0 hermaphrodites. #> Exact birth years are from 2000 to 2001 #> Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 2,2  #>  #> ~~~ Duplicate check ~~~ #>  #> ~~~ Parentage assignment ~~~ #> Assign parents ... #> Initial total LL : #> [1] -18301.94 #> Post-parentage total LL : #> [1] -13484.17 #> Estimating birth years ... #> Calculating parental LLR ... #> assigned 130 dams and 167 sires to 214 individuals #> Possibly not all parents were assigned, consider running GetMaybeRel() conditional on this pedigree to check  names(SeqOUT) #>  [1] \"Specs\"         \"ErrM\"          \"args.AP\"       \"AgePriors\"     #>  [5] \"LifeHist\"      \"DupLifeHistID\" \"NoLH\"          \"PedigreePar\"   #>  [9] \"TotLikPar\"     \"AgePriorExtra\" \"LifeHistPar\"   SeqOUT$PedigreePar[34:42, ] #>        id    dam   sire LLRdam LLRsire LLRpair OHdam OHsire MEpair #> 34 a01002   <NA>   <NA>     NA      NA      NA    NA     NA     NA #> 35 b01003   <NA>   <NA>     NA      NA      NA    NA     NA     NA #> 36 b01004   <NA>   <NA>     NA      NA      NA    NA     NA     NA #> 37 a01005 a00013 b00001   2.03    3.80    6.31     1      0      1 #> 38 b01006 a00013 b00001   1.66    3.11    5.79     1      0      1 #> 39 b01007 a00013 b00001   1.31    2.93    4.53     1      0      2 #> 40 a01008 a00013 b00001  -0.13    3.63    5.59     2      0      2 #> 41 b01009 a00008 b00016   0.13    4.09    6.54     1      0      2 #> 42 a01010 a00008 b00016   3.44    4.26    7.46     0      0      1  # compare to true (or old) pedigree: PC <- PedCompare(Ped_HSg5, SeqOUT$PedigreePar)  PC$Counts[\"GG\",,] #>           parent #> class      dam sire #>   Total    130  170 #>   Match    130  167 #>   Mismatch   0    0 #>   P1only     0    3 #>   P2only     0    0  # \\donttest{ # parentage assignment + full pedigree reconstruction: # (note: this can be rather time consuming) SeqOUT2 <- sequoia(GenoM = SimGeno_example, Err = 0.005,                   LifeHistData = LH_HSg5, Module=\"ped\", quiet=\"verbose\") #> Genotype matrix looks OK! There are  214  individuals and  200  SNPs. #> There are 106 females, 108 males, 0 individuals of unknown sex, and 0 hermaphrodites. #> Exact birth years are from 2000 to 2001 #> Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 2,2  #>  #> ~~~ Duplicate check ~~~ #>  #> ~~~ Parentage assignment ~~~ #> Counting opposing homozygous loci between all individuals ... #> Assign parents ... #> Initial total LL : #> [1] -18301.94 #> Round 01: #> [1] -13484.17 #> Round 02: #> [1] -13484.17 #> Post-parentage total LL : #> [1] -13484.17 #> Estimating birth years ... #> Calculating parental LLR ... #> assigned 130 dams and 167 sires to 214 individuals #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1  #>  #> ~~~ Full pedigree reconstruction ~~~ #> Counting opposing homozygous loci between all individuals ... #> Sibships - Initial Total LL : #> [1] -13484.17 #> Parents pre-check ... #> Total LL : #> [1] -13484.17 #> --- Round 01 start --- #> Find pairs ... #> [1] 200 #> n pairs: #> [1] 151 #> Clustering ... #> Total LL, time: #> [1] -12315.80      0.22 #> Merge clusters ... #> Total LL, time: #> [1] -12315.80      0.03 #> Sibship parent replacement... #> Total LL, time: #> [1] -12315.80      0.02 #> Parents & grow clusters... #> Total LL, time: #> [1] -12315.80      1.84 #> Round 01 end, Total LogLik; time (sec): #> [1] -12315.80      2.36 #> No. dams, sires for real indiv.: #> [1] 182 182 #> No. dummies: #> [1] 7 1 #> --------------- #> --- Round 02 start --- #> Find pairs ... #> [1] 200 #> n pairs: #> [1] 0 #> Clustering ... #> Total LL, time: #> [1] -12315.80      0.03 #> Merge clusters ... #> Total LL, time: #> [1] -12315.80      0.02 #> Sibship parent replacement... #> Total LL, time: #> [1] -12315.80      0.03 #> Grandparents of half-sib clusters ... #> Total LL, time: #> [1] -12315.80      0.02 #> Parents & grow clusters... #> Total LL, time: #> [1] -12315.80      0.02 #> Round 02 end, Total LogLik; time (sec): #> [1] -12315.80      0.16 #> No. dams, sires for real indiv.: #> [1] 182 182 #> No. dummies: #> [1] 7 1 #> --------------- #> --- Round 03 start --- #> Find pairs ... #> [1] 200 #> n pairs: #> [1] 0 #> Clustering ... #> Total LL, time: #> [1] -12315.80      0.03 #> Grandparent - grandoffspring pairs ... #> Total LL, time: #> [1] -12315.80      0.02 #> Merge clusters ... #> Total LL, time: #> [1] -12315.80      0.02 #> Sibship parent replacement... #> Total LL, time: #> [1] -12315.80      0.03 #> Grandparents of half-sib clusters ... #> Total LL, time: #> [1] -12315.80      0.02 #> Grandparents of full sib clusters ... #> Total LL, time: #> [1] -12315.80      0.03 #> Parents & grow clusters... #> Total LL, time: #> [1] -12315.80      0.02 #> Round 03 end, Total LogLik; time (sec): #> [1] -12315.8      0.2 #> No. dams, sires for real indiv.: #> [1] 182 182 #> No. dummies: #> [1] 7 1 #> --------------- #> Estimating birth years ... #> Calculating parental LLR ... #> assigned 182 dams and 182 sires to 214 + 8 individuals (real + dummy)  #> Possibly not all relatives were assigned, consider running GetMaybeRel() conditional on this pedigree to check  SeqOUT2$Pedigree[34:42, ] #>        id    dam   sire LLRdam LLRsire LLRpair OHdam OHsire MEpair #> 34 a01002  F0002  M0001   4.11    3.34    7.74    NA     NA     NA #> 35 b01003  F0002  M0001   5.28    1.96    5.26    NA     NA     NA #> 36 b01004  F0002  M0001   4.25    3.29    5.82    NA     NA     NA #> 37 a01005 a00013 b00001   4.48    6.40    8.53     1      0      1 #> 38 b01006 a00013 b00001   3.82    6.66    7.83     1      0      1 #> 39 b01007 a00013 b00001   3.63    5.30    6.58     1      0      2 #> 40 a01008 a00013 b00001   3.65    5.13    8.06     2      0      2 #> 41 b01009 a00008 b00016   3.69    4.10    6.54     1      0      2 #> 42 a01010 a00008 b00016   5.73    4.99    7.66     0      0      1  PC2 <- PedCompare(Ped_HSg5, SeqOUT2$Pedigree)  PC2$Counts[\"GT\",,] #>           parent #> class      dam sire #>   Total    182  182 #>   Match    182  182 #>   Mismatch   0    0 #>   P1only     0    0 #>   P2only     0    0 PC2$Counts[,,\"dam\"] #>     class #> cat  Total Match Mismatch P1only P2only #>   GG   130   130        0      0      0 #>   GD    52    52        0      0      0 #>   GT   182   182        0      0      0 #>   DG     0     0        0      0      0 #>   DD     0     0        0      0      0 #>   DT     0     0        0      0      0 #>   TT   960   182        0    778      0  # different kind of pedigree comparison: ComparePairs(Ped1=Ped_HSg5, Ped2=SeqOUT$PedigreePar, patmat=TRUE) #>      Ped2 #> Ped1       M      P      O     FS    MHS    PHS      U      X #>   M      130      0      0      0      0      0      0    830 #>   P        0    167      0      0      0      0      3    790 #>   FS       0      0      0    206     12     59     13   1310 #>   MHS      0      0      0      0    217      0     97   1446 #>   PHS      0      0      0      0      0    587     71   3022 #>   U        0      0      0      0      0      0  21229 469311 #>   X        0      0      0      0      0      0      0      0  # results overview: SummarySeq(SeqOUT2)       # important to run with approx. correct genotyping error rate: SeqOUT2.b <- sequoia(GenoM = SimGeno_example, #  Err = 1e-4 by default                   LifeHistData = LH_HSg5, Module=\"ped\", Plot=FALSE) #> Genotype matrix looks OK! There are  214  individuals and  200  SNPs. #> There are 106 females, 108 males, 0 individuals of unknown sex, and 0 hermaphrodites. #> Exact birth years are from 2000 to 2001 #> Ageprior: Flat 0/1, overlapping generations, MaxAgeParent = 2,2 #>  #> ~~~ Duplicate check ~~~ #>  #> ~~~ Parentage assignment ~~~ #> Assign parents ... #> Initial total LL : #> [1] -18301.9 #> Post-parentage total LL : #> [1] -13732.71 #> Estimating birth years ... #> Calculating parental LLR ... #> assigned 125 dams and 162 sires to 214 individuals #> Ageprior: Flat 0/1, discrete generations, MaxAgeParent = 1,1 #>  #> ~~~ Full pedigree reconstruction ~~~ #> Sibships - Initial Total LL : #> [1] -13732.71 #> Round 01 end, Total LogLik; time (sec): #> [1] -12535.17      2.59 #> No. dams, sires for real indiv.: #> [1] 179 180 #> Round 02 end, Total LogLik; time (sec): #> [1] -12535.17      0.19 #> No. dams, sires for real indiv.: #> [1] 179 180 #> Round 03 end, Total LogLik; time (sec): #> [1] -12535.17      0.22 #> No. dams, sires for real indiv.: #> [1] 179 180 #> Estimating birth years ... #> Calculating parental LLR ... #> assigned 179 dams and 180 sires to 214 + 9 individuals (real + dummy) #> Possibly not all relatives were assigned, consider running GetMaybeRel() conditional on this pedigree to check PC2.b <- PedCompare(Ped_HSg5, SeqOUT2.b$Pedigree)  PC2.b$Counts[\"GT\",,] #>           parent #> class      dam sire #>   Total    182  182 #>   Match    177  180 #>   Mismatch   2    0 #>   P1only     3    2 #>   P2only     0    0 # }  if (FALSE) { # ===  EXAMPLE 2: real data  === # ideally, select 400-700 SNPs: high MAF & low LD # save in 0/1/2/NA format (PLINK's --recodeA) GenoM <- GenoConvert(InFile = \"inputfile_for_sequoia.raw\",                      InFormat = \"raw\")  # can also do Colony format SNPSTATS <- SnpStats(GenoM) # perhaps after some data-cleaning: write.table(GenoM, file=\"MyGenoData.txt\", row.names=T, col.names=F)  # later: GenoM <- as.matrix(read.table(\"MyGenoData.txt\", row.names=1, header=F)) LHdata <- read.table(\"LifeHistoryData.txt\", header=T) # ID-Sex-birthyear SeqOUT <- sequoia(GenoM, LHdata, Err=0.005) SummarySeq(SeqOUT)  SeqOUT$notes <- \"Trial run on cleaned data\"  # add notes for future reference saveRDS(SeqOUT, file=\"sequoia_output_42.RDS\")  # save to R-specific file writeSeq(SeqOUT, folder=\"sequoia_output\")  # save to several plain text files  # runtime: SeqOUT$Specs$TimeEnd - SeqOUT$Specs$TimeStart }"},{"path":"https://jiscah.github.io/reference/SibMatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the closest matching inferred sibship to a true sibship — SibMatch","title":"Find the closest matching inferred sibship to a true sibship — SibMatch","text":"Find closest matching inferred sibship true sibship","code":""},{"path":"https://jiscah.github.io/reference/SibMatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the closest matching inferred sibship to a true sibship — SibMatch","text":"","code":"SibMatch(SimX, Infrd, SNPd)"},{"path":"https://jiscah.github.io/reference/SibMatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the closest matching inferred sibship to a true sibship — SibMatch","text":"SimX vector IDs true (Ped1) sibship Infrd list vectors IDs inferred (Ped2) sibships SNPd character vector IDs genotyped individuals","code":""},{"path":"https://jiscah.github.io/reference/SibMatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the closest matching inferred sibship to a true sibship — SibMatch","text":"named numeric vector number matches ('NumMatch'),   position best match ('Best'), inferred sibship size   best match ('Tot'), number matching IDs ('OK'),   number mismatches ('err').","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Genotypes — SimGeno","title":"Simulate Genotypes — SimGeno","text":"Simulate SNP genotype data pedigree, optional   missingness, genotyping errors, non-genotyped parents.","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Genotypes — SimGeno","text":"","code":"SimGeno(   Pedigree,   nSnp = 400,   ParMis = c(0, 0),   MAF = 0.3,   CallRate = 0.99,   SnpError = 5e-04,   ErrorFV = function(E) c((E/2)^2, E - (E/2)^2, E/2),   ErrorFM = NULL,   ReturnStats = FALSE,   quiet = FALSE )"},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Genotypes — SimGeno","text":"Pedigree dataframe, pedigree first three columns id - dam - sire, additional columns ignored. nSnp number SNPs simulate. ParMis single number vector length two proportion parents fully missing genotype. Ignored CallRate named vector. NOTE: default changed 0.4 (version 2.8.5) 0 (version 2.9). MAF either single number minimum minor allele frequency, allele frequencies sampled uniformly minimum 0.5, vector minor allele frequency locus. cases, MAF among pedigree founders, MAF sample deviate due drift. CallRate either single number mean call rate (genotyping success), vector call rate SNP, named vector call rate individual. third case, ParMis ignored, individuals pedigree (id parent) included vector presumed non-genotyped. SnpError either single value combined ErrorFV, length 3 vector probabilities (observed given actual) hom|hom, het|hom, hom|het; vector 3XnSnp matrix genotyping error rate(s) SNP. ErrorFV function taking error rate (scalar) argument returning length 3 vector hom->hom, hom->het, het->hom. ErrorFM function taking error rate (scalar) argument returning 3x3 matrix probabilities actual genotype (rows) observed genotype j (columns). See details. use, set ErrorFV = NULL ReturnStats addition genotype matrix, return input parameters mean & quantiles MAF, error rate call rates. quiet suppress messages.","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Genotypes — SimGeno","text":"ReturnStats=FALSE (default), matrix genotype   data sequoia's input format, encoded 0/1/2/-9. ReturnStats=TRUE, named list three elements: list   'ParamsIN', matrix 'SGeno', list 'StatsOUT': AF Frequency 'observed' genotypes '1' allele AF.act Allele frequency 'actual' (without genotyping errors &     missingness) SnpError Error rate per SNP (actual /= observed observed /=     missing) SnpCallRate Non-missing per SNP IndivError Error rate per individual IndivCallRate Non-missing per individual","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Genotypes — SimGeno","text":"founders, .e. individuals   known parents, genotypes drawn according provided MAF   assuming Hardy-Weinberg equilibrium. Offspring genotypes generated   following Mendelian inheritance, assuming loci completely   independent. Individuals one known parent allowed: locus,   one allele inherited known parent, drawn   genepool according provided MAF.","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"genotyping-errors","dir":"Reference","previous_headings":"","what":"Genotyping errors","title":"Simulate Genotypes — SimGeno","text":"SnpError length 3 vector, genotyping errors generated   following length 3 vector probabilities 1) actual homozygote   observed homozygote, 2) actual homozygote observed   heterozygote, 3) heterozygote observed homozygote.   assumption made two alleles can treated equally, .e.   observing actual allele $$ $$ likely observing actual $$   $$. SnpError single value, default interpreted   locus-level error rate (rather allele-level), equals   probability homozygote observed heterozygote,   probability heterozygote observed either homozygote (.e.,   probability observed AA = probability observed aa =   SnpError/2). probability one homozygote observed   (SnpError/2\\()^2\\). single value rendered   3x3 error matrix fully flexible specified via ErrorFM;   see link{ErrToM} details. default values SnpError=5e-4 ErrorFM='version2.0'   correspond length 3 vector c((5e-4/2)^2, 5e-4/2,   5e-4*(1-5e-4/2)). beta-distribution used simulate variation error rate   SNPs, shape parameter distribution can specified via   MkGenoErrors. also possible specify error rate   per SNP.","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"call-rate","dir":"Reference","previous_headings":"","what":"Call Rate","title":"Simulate Genotypes — SimGeno","text":"Variation call rates across SNPs assumed follow highly skewed   (beta) distribution, many SNPs call rates close 1,   narrowing tail lower call rates. first shape parameter defaults 1   (see MkGenoErrors), second shape parameter   defined via mean CallRate. 99.9% SNPs call   rate 0.8 (0.9; 0.95) higher, use mean call rate 0.969 (0.985;   0.993). Variation call rate samples can specified providing   named vector CallRate. Otherwise, variation call rate   error rate samples occurs side-effect random nature   individuals hit per-SNP errors drop-outs. Finer control   possible first generating error-free genotype matrix,   calling MkGenoErrors directly (subsets ) matrix.","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"disclaimer","dir":"Reference","previous_headings":"","what":"Disclaimer","title":"Simulate Genotypes — SimGeno","text":"simulation highly simplistic assumes   SNPs segregate completely independently, SNPs   Hardy-Weinberg equilibrium pedigree founders. assumes   genotyping errors due heritable mutations SNPs,   missingness random e.g. due heritable mutations SNP   flanking regions. Results based simulated data provide   minimum estimate number SNPs required, optimistic estimate   pedigree reconstruction performance.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Genotypes — SimGeno","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/SimGeno.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Genotypes — SimGeno","text":"","code":"Geno_A <- SimGeno(Pedigree = Ped_griffin, nSnp=200, ParMis=c(0.1, 0.6),                   MAF = 0.25, SnpError = 0.001)  Geno_B <- SimGeno(Pedigree = Ped_HSg5, nSnp = 100, ParMis = 0.2,                  SnpError = c(0.01, 0.04, 0.1))  Geno_C <- SimGeno(Pedigree = Ped_griffin, nSnp=200, ParMis=0, CallRate=0.6,                   SnpError = 0.05, ErrorFV=function(E) c(E/10, E/10, E))  # genotype matrix with duplicated samples: Dups_grif <- data.frame(ID1 = c('i006_2001_M', 'i021_2002_M', 'i064_2004_F')) Dups_grif$ID2 <- paste0(Dups_grif$ID1, '_2') Err <- c(0.01, 0.04, 0.1) Geno_act <- SimGeno(Ped_griffin, nSnp=500, ParMis=0, CallRate=1, SnpError=0) Geno_sim <- MkGenoErrors(Geno_act, SnpError=Err, CallRate=0.99) Geno_dups <- MkGenoErrors(Geno_act[Dups_grif$ID1, ], SnpError=Err,                           CallRate=0.99) rownames(Geno_dups) <- Dups_grif$ID2 Geno_sim <- rbind(Geno_sim, Geno_dups)"},{"path":"https://jiscah.github.io/reference/SimGeno_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Example genotype file: 'HSg5' — SimGeno_example","title":"Example genotype file: 'HSg5' — SimGeno_example","text":"Simulated genotype data cohorts 1+2 Pedigree   Ped_HSg5","code":""},{"path":"https://jiscah.github.io/reference/SimGeno_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example genotype file: 'HSg5' — SimGeno_example","text":"","code":"data(SimGeno_example)"},{"path":"https://jiscah.github.io/reference/SimGeno_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example genotype file: 'HSg5' — SimGeno_example","text":"genotype matrix 214 rows (ids) 200 columns (SNPs).   SNP coded 0/1/2 copies reference allele, -9 missing   values. Ids stored rownames.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SimGeno_example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example genotype file: 'HSg5' — SimGeno_example","text":"Jisca Huisman, jisca.huisman@gmail.com","code":""},{"path":"https://jiscah.github.io/reference/SmoothAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth out dips in ageprior matrix — SmoothAP","title":"Smooth out dips in ageprior matrix — SmoothAP","text":"...","code":""},{"path":"https://jiscah.github.io/reference/SmoothAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth out dips in ageprior matrix — SmoothAP","text":"","code":"SmoothAP(V, tiny = 0.001)"},{"path":"https://jiscah.github.io/reference/SmoothAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth out dips in ageprior matrix — SmoothAP","text":"V column ageprior matrix (vector); strictly positive tiny smallest non-zero value V","code":""},{"path":"https://jiscah.github.io/reference/SmoothAP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Smooth out dips in ageprior matrix — SmoothAP","text":"Sets dips (<10% average neighbouring ages) average   neighbouring ages, sets age end (oldest observed age)   LR(end)/2, assigns small value (0.001) ages front   (youngest observed age) new end. Peaks smoothed ,   less likely cause problems dips, likely   genuine characteristics species.","code":""},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":null,"dir":"Reference","previous_headings":"","what":"SNP Summary Statistics — SnpStats","title":"SNP Summary Statistics — SnpStats","text":"Estimate allele frequency (AF), missingness Mendelian errors per SNP.","code":""},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SNP Summary Statistics — SnpStats","text":"","code":"SnpStats(GenoM, Pedigree = NULL, Duplicates = NULL, Plot = TRUE, ErrFlavour)"},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SNP Summary Statistics — SnpStats","text":"GenoM genotype matrix, sequoia's format: 1 column per SNP, 1 row per individual, genotypes coded 0/1/2/-9, row names giving individual IDs. Pedigree dataframe 3 columns: ID - parent1 - parent2. Additional columns non-genotyped individuals ignored. Used count Mendelian errors per SNP (poorly) estimate error rate. Duplicates dataframe pairs duplicated samples Plot show histograms results? ErrFlavour DEPRECATED IGNORED. used estimate Err.hat","code":""},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SNP Summary Statistics — SnpStats","text":"matrix number rows equal number SNPs  (=number columns GenoM), Pedigree provided 2 columns: AF Allele frequency 'second allele' (one   homozygote coded 2) Mis Proportion missing calls HWE.p p-value chi-square test Hardy-Weinberg equilibrium Pedigree provided, 8 additional columns: n.dam, n.sire, n.pair Number dams, sires, parent-pairs successfully   genotyped SNP OHdam, OHsire Count number opposing homozygous cases MEpair Count Mendelian errors, includes opposing homozygous cases   one parent genotyped n.dups, n.diff Number duplicate pairs successfully genotyped   SNP; number differences. latter count cases one   duplicate successfully genotyped SNP","code":""},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SNP Summary Statistics — SnpStats","text":"Calculation summary statistics can done PLINK,   SNPs low minor allele frequency high missingness filtered   prior pedigree reconstruction. function provided aid   inspect relationship AF, missingness genotyping error   find suitable combination SNP filtering thresholds use. pedigree reconstruction, SNPs zero one copies alternate   allele dataset (MAF \\(\\le 1/2N\\)) considered fixed,   excluded.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SnpStats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SNP Summary Statistics — SnpStats","text":"","code":"Genotypes <- SimGeno(Ped_HSg5, nSnp=100, CallRate = runif(100, 0.5, 0.8),                      SnpError = 0.05) SnpStats(Genotypes)   # only plots; data is returned invisibly SNPstats <- SnpStats(Genotypes, Pedigree=Ped_HSg5)"},{"path":"https://jiscah.github.io/reference/SpecsToParam.html","id":null,"dir":"Reference","previous_headings":"","what":"Specs to PARAM — SpecsToParam","title":"Specs to PARAM — SpecsToParam","text":"Convert 1-row dataframe Specs list PARAM,   optionally including various objects list.","code":""},{"path":"https://jiscah.github.io/reference/SpecsToParam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specs to PARAM — SpecsToParam","text":"","code":"SpecsToParam(Specs, ErrM = NULL, ErrFlavour = NULL, dimGeno = NULL, ...)"},{"path":"https://jiscah.github.io/reference/SpecsToParam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specs to PARAM — SpecsToParam","text":"Specs 1-row dataframe, element sequoia output list. ... objects append list, ErrM quiet.","code":""},{"path":"https://jiscah.github.io/reference/SpecsToParam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specs to PARAM — SpecsToParam","text":"named list.","code":""},{"path":"https://jiscah.github.io/reference/SummarySeq.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Sequoia Output or Pedigree — SummarySeq","title":"Summarise Sequoia Output or Pedigree — SummarySeq","text":"Number assigned parents grandparents sibship sizes,   split genotyped, dummy, 'observed'.","code":""},{"path":"https://jiscah.github.io/reference/SummarySeq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Sequoia Output or Pedigree — SummarySeq","text":"","code":"SummarySeq(   SeqList = NULL,   Pedigree = NULL,   DumPrefix = c(\"F0\", \"M0\"),   SNPd = NULL,   Plot = TRUE,   Panels = \"all\" )"},{"path":"https://jiscah.github.io/reference/SummarySeq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Sequoia Output or Pedigree — SummarySeq","text":"SeqList list returned sequoia. elements 'Pedigree' 'PedigreePar' 'AgePriors' used. ids 'PedigreePar', , presumed genotyped. Pedigree dataframe, pedigree first three columns id - dam - sire. Column names ignored, additional columns, except columns OHdam, OHsire, MEpair, LLRdam, LLRsire, LLRpair (plotting ). DumPrefix character vector length 2 prefixes dummy dams (mothers) sires (fathers). read SeqList's 'Specs' provided. Used distinguish dummies non-dummies. Length 3 case hermaphrodites. SNPd character vector ids SNP genotyped individuals. used Pedigree provided instead SeqList, distinguish genetically assigned parents 'observed' parents (e.g. observed field, assigned previously using microsatellites). NULL (default), parents presumed observed. Plot show barplots histograms results, well parental LLRs, Mendelian errors, agepriors, present. Panels character vector panel(s) plot. Choose '', 'G.parents' (parents genotyped individuals), 'D.parents' (parents dummy individuals), 'sibships' (distribution sibship sizes), 'LLR' (log10-likelihood ratio parent/otherwise related), 'OH' (count opposite homozygote SNPs).","code":""},{"path":"https://jiscah.github.io/reference/SummarySeq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Sequoia Output or Pedigree — SummarySeq","text":"list following elements: PedSummary 2-column matrix basic summary statistics, similar   used returned Pedantics' pedStatSummary (now   archived CRAN). First column refers complete pedigree, second   column SNP-genotyped individuals . Maternal siblings sharing dummy   parent counted 2nd column sibs genotyped,   one sibs dummy individual. ParentCount array number assigned parents,   split : offspringCat: Genotyped, Dummy, Observed* (*:     Pedigree provided rather SeqList, ids     listed SNPd conform DumPrefix +     number (.e. (almost) al individuals SNPd = NULL,     default). offspringSex: Female, Male, Unknown, Herm* (*: hermaphrodite,     individuals occur dam sire). Based     whether individual occurs Dam Sire. parentSex: Dam Sire parentCat: Genotyped, Dummy, Observed*, None (*:     offspringCat) GPCount array number assigned grandparents,   split : offspringCat: Genotyped, Dummy, Observed*, grandparent kind: maternal grandmothers (MGM),   maternal grandfathers (MGF), paternal grandmothers (PGM), paternal   grandfathers (PGF) grandparentCat: Genotyped, Dummy, Observed*, None SibSize list elements 'mat' (maternal half + full siblings),   'pat' (paternal half + full siblings), 'full' (full siblings).   matrix number rows equal maximum sibship size, 3   columns, splitting type parent: Genotyped, Dummy, Observed.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/SummarySeq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise Sequoia Output or Pedigree — SummarySeq","text":"","code":"SummarySeq(Ped_griffin)   sumry_grif <- SummarySeq(SeqOUT_griffin, Panels=c(\"G.parents\", \"OH\"))   sumry_grif$PedSummary #>                        All SNPd #> records                170  142 #> maternities            125   65 #> paternities            122   79 #> full sibs                5    5 #> maternal half sib      131   87 #> paternal half sibs     114   77 #> maternal grandmothers   91   77 #> maternal grandfathers   90   80 #> paternal grandmothers   73   60 #> paternal grandfathers   73   61 #> maximum pedigree depth   8    7 #> founders                36   39"},{"path":"https://jiscah.github.io/reference/tryCatch.W.E.html","id":null,"dir":"Reference","previous_headings":"","what":"tryCatch both warnings (with value) and errors — tryCatch.W.E","title":"tryCatch both warnings (with value) and errors — tryCatch.W.E","text":"Catch ** save errors warnings, case warning, also keep computed result.","code":""},{"path":"https://jiscah.github.io/reference/tryCatch.W.E.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"tryCatch both warnings (with value) and errors — tryCatch.W.E","text":"","code":"tryCatch.W.E(expr)"},{"path":"https://jiscah.github.io/reference/tryCatch.W.E.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"tryCatch both warnings (with value) and errors — tryCatch.W.E","text":"expr R expression evaluate","code":""},{"path":"https://jiscah.github.io/reference/tryCatch.W.E.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"tryCatch both warnings (with value) and errors — tryCatch.W.E","text":"list 'value' 'warning',   'value' may error caught.","code":""},{"path":"https://jiscah.github.io/reference/tryCatch.W.E.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"tryCatch both warnings (with value) and errors — tryCatch.W.E","text":"Martin Maechler; Copyright (C) 2010-2012  R Core Team","code":""},{"path":"https://jiscah.github.io/reference/Vcomp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two vectors — Vcomp","title":"Compare two vectors — Vcomp","text":"Compare vector inferred sibs vector `true' sibs","code":""},{"path":"https://jiscah.github.io/reference/Vcomp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two vectors — Vcomp","text":"","code":"Vcomp(Infrd, Simld, SNPd)"},{"path":"https://jiscah.github.io/reference/Vcomp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two vectors — Vcomp","text":"Infrd vector inferred sibs Simld vector true sibs SNPd character vector IDs genotyped individuals","code":""},{"path":"https://jiscah.github.io/reference/Vcomp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two vectors — Vcomp","text":"named numeric vector length 4, total length Simld,   length intersect two vectors, number occurring   Infrd Simld ('err'), number occuring Simld   Infrd ('missed').","code":""},{"path":"https://jiscah.github.io/reference/VennSquares.html","id":null,"dir":"Reference","previous_headings":"","what":"Square Venn diagram — VennSquares","title":"Square Venn diagram — VennSquares","text":"Draw Venn diagram squares, match/mismatch   overlapping area.","code":""},{"path":"https://jiscah.github.io/reference/VennSquares.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Square Venn diagram — VennSquares","text":"","code":"VennSquares(count, BL = c(0, 0), COL, withText = TRUE, withLegend = FALSE)"},{"path":"https://jiscah.github.io/reference/VennSquares.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Square Venn diagram — VennSquares","text":"count length 5 named vector: 'Total', 'Match', 'Mismatch', 'P1only', 'P2only'. BL length 2 vector coordinates bottom-mid Ped1 square. COL length 4 character vector colours, named 'Match', 'Mismatch', 'Ped1', 'Ped2'. withText logical, add count rectangle. withLegend logical, add legend bottom plot.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/writeColumns.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Data to a File Column-wise — writeColumns","title":"Write Data to a File Column-wise — writeColumns","text":"Write data.frame matrix text file, using white space padding keep columns aligned print.","code":""},{"path":"https://jiscah.github.io/reference/writeColumns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Data to a File Column-wise — writeColumns","text":"","code":"writeColumns(x, file = \"\", row.names = TRUE, col.names = TRUE)"},{"path":"https://jiscah.github.io/reference/writeColumns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Data to a File Column-wise — writeColumns","text":"x object written, preferably matrix data frame. , attempted coerce x matrix. file character string naming file. row.names logical value indicating whether row names x written along x. col.names logical value indicating whether column names x written along x.","code":""},{"path":"https://jiscah.github.io/reference/writeSeq.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Sequoia Output to File — writeSeq","title":"Write Sequoia Output to File — writeSeq","text":"various list elements returned sequoia   written text files specified folder, separate sheets   single excel file (requires library openxlsx).","code":""},{"path":"https://jiscah.github.io/reference/writeSeq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Sequoia Output to File — writeSeq","text":"","code":"writeSeq(   SeqList,   GenoM = NULL,   MaybeRel = NULL,   PedComp = NULL,   OutFormat = \"txt\",   folder = \"Sequoia-OUT\",   file = \"Sequoia-OUT.xlsx\",   ForVersion = 2,   quiet = FALSE )"},{"path":"https://jiscah.github.io/reference/writeSeq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Sequoia Output to File — writeSeq","text":"SeqList list returned sequoia, written . GenoM matrix genetic data (optional). Ignored OutFormat='xls', resulting file become large excel. MaybeRel list results GetMaybeRel (optional). PedComp list results PedCompare (optional). SeqList$DummyIDs combined PedComp$DummyMatch provided. OutFormat 'xls' 'txt'. folder directory text files written; created already exists. Relative current working directory, NULL current working directory. Ignored OutFormat='xls'. file name excel file write , ignored OutFormat='txt'. ForVersion choose '1' back-compatibility stand-alone sequoia versions 1.x quiet suppress messages.","code":""},{"path":"https://jiscah.github.io/reference/writeSeq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write Sequoia Output to File — writeSeq","text":"text files can used input stand-alone Fortran   version sequoia, e.g. genotype data large R. See   vignette('sequoia') details.","code":""},{"path":[]},{"path":"https://jiscah.github.io/reference/writeSeq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Sequoia Output to File — writeSeq","text":"","code":"if (FALSE) { writeSeq(SeqList, OutFormat=\"xls\", file=\"MyFile.xlsx\")  # add additional sheet to the excel file: library(openxlsx) wb <- loadWorkbook(\"MyFile.xlsx\") addWorksheet(wb, sheetName = \"ExtraData\") writeData(wb, sheet = \"ExtraData\", MyData, rowNames=FALSE) saveWorkbook(wb, \"MyFile.xlsx\", overwrite=TRUE, returnValue=TRUE)  # or: (package requires java & is trickier to install) xlsx::write.xlsx(MyData, file = \"MyFile.xlsx\", sheetName=\"ExtraData\",       col.names=TRUE, row.names=FALSE, append=TRUE, showNA=FALSE) }"},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-290","dir":"Changelog","previous_headings":"","what":"sequoia 2.9.0","title":"sequoia 2.9.0","text":"CRAN release: 2024-03-01 fix bug MkGenoErrors (used SimGeno) causing 3x many hom|hom errors SnpError single value: first beta-distributed per-SNP genotyping error rates El generated, (El/2)2 calculated. Now single value default first morphed length 3 vector (hom|hom, het|hom, hom|het), three beta distributions generated. adds log MkGenoErrors SimGeno ParMis default changed 0.4 0 default genotyping pattern slightly changed ensure probability homozyogote genotyping error identical heterozygote (see ErrToM). Beta-version EstEr (estimation genotyping errors) removed due inaccurate estimations misuse. (probably) re-implemented future version.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-283","dir":"Changelog","previous_headings":"","what":"sequoia 2.8.3","title":"sequoia 2.8.3","text":"CRAN release: 2023-12-19 fixes bugs introduced since version 2.5, plus various edits source code improve assignment rate fix bug CalcMaxMismatch: OH parents counts 2 mismatches (1)","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-273","dir":"Changelog","previous_headings":"","what":"sequoia 2.7.3","title":"sequoia 2.7.3","text":"fix bug causing negative parental LLRs, possibly non-assignments speed increase lower call rates add OutFormat ‘ped’ GenoConvert, fix bug OutFormat ‘col’","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-272","dir":"Changelog","previous_headings":"","what":"sequoia 2.7.2","title":"sequoia 2.7.2","text":"CRAN release: 2023-09-06 change EstConf example nSim=1 ensure runtime < 5 sec pass CRAN check","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-271","dir":"Changelog","previous_headings":"","what":"sequoia 2.7.1","title":"sequoia 2.7.1","text":"add mtSame: specify individuals different mitochondrial haplotype improved parentage assignment performance many genetically similar candidate parents fixes CRAN issue ‘use Fortran’s random number generator’","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-260","dir":"Changelog","previous_headings":"","what":"sequoia 2.6.0","title":"sequoia 2.6.0","text":"add specification assumed genotyping error rate via length 3 vector: hom|hom, het|hom, hom|het expand CalcPairLL helpfile","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-256","dir":"Changelog","previous_headings":"","what":"sequoia 2.5.6","title":"sequoia 2.5.6","text":"CRAN release: 2023-04-22 fixes CRAN pretest NOTES, including broken links vignette","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-254","dir":"Changelog","previous_headings":"","what":"sequoia 2.5.4","title":"sequoia 2.5.4","text":"add updated vignettes (main + age); accidentally included old versions 2.5.3 fixed bug CalcBYprobs, caused Year.last ignored","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-253","dir":"Changelog","previous_headings":"","what":"sequoia 2.5.3","title":"sequoia 2.5.3","text":"CRAN release: 2023-03-21 fixes CRAN error ‘DLL requires use native symbols’","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes--minor-changes-2-5-1","dir":"Changelog","previous_headings":"","what":"Bug fixes & minor changes","title":"sequoia 2.5.1","text":"fix error ‘sibship number bounds’ fix error LifeHistData$Sex includes NA fix several minor bugs affecting rare cases","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"new-features--major-changes-2-5-0","dir":"Changelog","previous_headings":"","what":"New features & major changes","title":"sequoia 2.5.0","text":"improved performance large proportion birth years exactly known optional column Year.last added LifeHistData (last possible offspring birth year) New functions GetAncestors GetDescendants","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes--minor-changes-2-5-0","dir":"Changelog","previous_headings":"","what":"Bug fixes & minor changes","title":"sequoia 2.5.0","text":"New parameter MinAgeParent MakeAgePrior() New parameter StrictGenoCheck, Strict CheckGeno() ; update msgs update CheckLH, now flexible column order LifeHistData. changed maxmismatch qntl = 0.999^(1/nrow(GenoM)) 0.9999^(1/nrow(GenoM)) functions calling CalcMaxMismatch","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes--minor-changes-2-4-2","dir":"Changelog","previous_headings":"","what":"Bug fixes & minor changes","title":"sequoia 2.4.2","text":"checks 6 generations back making assignment avoid individual ancestor (5) fix bug SnpStats() AF=0 SNP missing individuals.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-241","dir":"Changelog","previous_headings":"","what":"sequoia 2.4.1","title":"sequoia 2.4.1","text":"CRAN release: 2023-01-08","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"new-features--major-changes-2-4-1","dir":"Changelog","previous_headings":"","what":"New features & major changes","title":"sequoia 2.4.1","text":"R markdown file create (serve first draft ) summary report input output, called via sequoia_report() PedCompare() parameter minSibSize (minimum sibship size non-genotyped parent considered ‘dummyfiable’) changed default value 2sib (2 genotyped siblings) 1sib1GP. reflects increased success reconstructing grandoffspring-grandparent pairs newest version, make output PedCompare(,minSibSize='2sib') confusing. also affects EstConf(). GetRelM() now allows input Pedigree Pairs. .o. allows PlotRelPairs() inferred pedigree plus GetMaybeRel() output.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"minor-changes-2-4-1","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"sequoia 2.4.1","text":"switch library xlsx openxlsx writeSeq() (easier install) adds purl=FALSE vignette chunks & include SeqOUT_HSg5 quicker vignette compilation include additional griffin example data: Geno_griffin, Conf_griffin (output EstConf()) MaybeRel_griffin (output GetMaybeRel()), well script used create (mk_griffin_data.R) many examples rewritten, clarification & speed package check plotting function SummarySeq() internal now exported (PlotSeqSum()) output sequoia() now includes args.AP. SummarySeq(), Pedigree provided rather SeqList SNPd=NULL, individuals categorised Observed (: Genotyped). PedPolish() now arguments specify whether drop extra columns (besides id-dam-sire) whether keep rows non-unique NA ids. SnpStats() now includes HWE tests","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-2-4-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"sequoia 2.4.1","text":"fixes several memory issues identified CRAN fixes various bugs SimGeno() non-autosomal inheritance; option still experimental non-autosomal SNPs supported pedigree reconstruction. fixes allocate vector size ... issue GetRelM() large pedigrees, affected MakeAgePrior() thereby sequoia(). EstConf() $ConfProb used wrong denominator, namely number parents reference pedigree rather inferred pedigree. fixes bug resulting LL(FA)=777 (‘impossible’) pairs 4 parents unknown. Likely affected CalcPairLL(), LL(HS)=LL(GP)=LL(FA) pairs. Origin time unknown. fixes bug GenoConvert() Informat='single'.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-235","dir":"Changelog","previous_headings":"","what":"sequoia 2.3.5","title":"sequoia 2.3.5","text":"CRAN release: 2021-05-22 fixes bug: OH count always zero co-parent","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-234","dir":"Changelog","previous_headings":"","what":"sequoia 2.3.4","title":"sequoia 2.3.4","text":"CRAN release: 2021-05-15 fixes bug CalcPairLL() HS likelihood conditioning pedigree incorrect. /minimal effect pedigree reconstruction. fixes bug DuplicateCheck() (always automatically called sequoia()) rare occasions caused R crash","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-233","dir":"Changelog","previous_headings":"","what":"sequoia 2.3.3","title":"sequoia 2.3.3","text":"CRAN release: 2021-05-02 fixes minor bugs identified CRAN valgrind gcc-ASAN","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-232","dir":"Changelog","previous_headings":"","what":"sequoia 2.3.2","title":"sequoia 2.3.2","text":"CRAN release: 2021-04-29 minor edits vignette comply CRAN precheck","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"new-features--major-changes-2-3-1","dir":"Changelog","previous_headings":"","what":"New features & major changes","title":"sequoia 2.3.1","text":"Hermaphrodites: dummy individuals offspring dam sire now prefix ‘H’; closer links two ‘clonal’ sibship parts pedigree reconstruction improved performance Assignment sibship grandparents moved check & assignment additional parents; proved increase correct assignments without increasing incorrect assignments. new function CalcBYprobs() estimate probability individual born year y.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"minor-changes-2-3-1","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"sequoia 2.3.1","text":"various edits Fortran code improving general performance.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-2-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"sequoia 2.3.1","text":"fixed inconsistent rounding EstConf() output bug GenoConvert() regarding InData vs InFile","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"major-bug-fixes-2-3-0","dir":"Changelog","previous_headings":"","what":"Major bug fixes","title":"sequoia 2.3.0","text":"now possible run assumed genotyping error rate Err=0 improvements large proportion birth years missing various bugs related hermaphrodites","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"reduced-computational-time-2-3-0","dir":"Changelog","previous_headings":"","what":"Reduced computational time","title":"sequoia 2.3.0","text":"Sibship clustering etc. now done oldest youngest individual instead order occurrence genotype file, giving quicker convergence final high likelihood pedigree.","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"new-features--major-changes-2-2-2","dir":"Changelog","previous_headings":"","what":"New features & major changes","title":"sequoia 2.2.2","text":"hermaphrodites: re-implemented greatly improved sibship clustering. Specification hermaphrodite vs diocious now separate input parameter Herm instead specified via Complex. New output list element DummyClones improved performance large proportion birth years missing new function CalcRped() calculate pedigree relatedness. Uses package kinship2.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-2-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"sequoia 2.2.2","text":"Various smaller bugs fixed, affecting assignment rate","code":""},{"path":[]},{"path":"https://jiscah.github.io/news/index.html","id":"new-features--major-changes-2-1-0","dir":"Changelog","previous_headings":"","what":"New features & major changes","title":"sequoia 2.1.0","text":"parameter ‘maxSibIter’ (-9/-1/0/>0) deprecated replaced ‘Module’ (pre/dup/par/ped). sequoia(): Option FindMaybeRel deprecated; call GetMaybeRel() directly instead. new function CalcPairLL(), returns likelihoods 7 considered relationships (PO, FS, HS, GP, FA, HA, U) specified pair individuals new function RelPlot() Colony-like visualisation pairwise relationships (automatically called ComparePairs())","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-2-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"sequoia 2.1.0","text":"sequoia(): fixed error object 'ErrM' found re-using output previous sequoia run. Circumvent bug version 2.0.7 fooling program think ’s output older version: names(ParOUT$Specs)[match(\"MaxMismatchOH\", names(ParOUT$Specs))] <- \"foo\". sequoia(): fixed bug causing genotyped parents always monogamous Complx='mono'. various functions: fixed error dummy prefixes different number characters (Error data.frame(id = c([s(nd[1]), 1], [s(nd[2]), 2]), VtoM(TMP$dumparrf,  : arguments imply differing number rows) ) GetMaybeRel(): fixed error (subscript) logical subscript long input pedigree contains dummies GetMaybeRel(): fixed error causing likely GP pairs included output PedCompare(): fixed id.dam.cat id.sire.cat ‘NANA’ instead XD, XG XX Symmetrical=TRUE PlotAgePrior(): Avoid using grDevices::hcl.colors() R versions <3.6, function yet available ComparePairs(): fixed bug Pairs2 Ped2 specified MakeAgePrior(): fixed bug FS pairs input pedigree MakeAgePrior(): MaxAgeParent ignored pedigree overlapping generations supplied","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"minor-changes-2-1-0","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"sequoia 2.1.0","text":"examples now set \\donttest instead \\dontrun, can run using example(). Note can quite time consuming, especially EstConf(). new function PlotPedComp() visualise PedCompare() output SimGeno(): deprecated input parameters (since v 1.3.1) dropped completely getAssignCat() longer drops additional columns input pedigree Speed increase CalcOHLLR(, CalcLLR = FALSE) thorough input checks, consistent across different functions PedCompare() output element DummyMatch now also include output class matched individual’s parents & offspring Duplicate check sequoia() now returns pairs LL_duplicate - max(LL_{duplicate}) > T_filter; call rates low may substantially shorter list previous versions, pairs fewer MaxMismatchDUP differences listed. ComparePairs() can now called single pedigree, well compare two pedigrees plotting window Rstudio small Plot=TRUE, functions print message return results usual, instead throwing error returning results. MakeAgePrior(): consistent implementation; now called sequoia() lifehistory data genotyped individuals. EstConf() now also returns full Counts table PedCompare(); $RunParams now holds evaluated input paramters, instead e.g. V[] called inside loop.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-207","dir":"Changelog","previous_headings":"","what":"sequoia 2.0.7","title":"sequoia 2.0.7","text":"CRAN release: 2020-05-18","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"new-features-2-0-7","dir":"Changelog","previous_headings":"","what":"New features","title":"sequoia 2.0.7","text":"genotyping error matrix (probability observed genotype conditional actual) now fully customisable relevant functions, see help file new function ErrToM. default changed slightly version 1.3. new function CalcOHLLR() calculate Mendelian errors parental log-likelihood ratios pedigree new function getAssignable() flag genotyped ‘dummifiable’ individuals pedigree new function ComparePairs() compare pairwise relationships 2 pedigrees; replaces now-deprecated DyadCompare. function PedPolish() now user available.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"major-changes-2-0-7","dir":"Changelog","previous_headings":"","what":"Major changes","title":"sequoia 2.0.7","text":"Deprecated option MaxMismatch function sequoia, now calculated internally new function CalcMaxMismatch based number SNPs, presumed genotyping error rate, minor allele frequencies function EstConf() now also estimates confidence parent-pairs; output changed considerably. rewrote function PedCompare() increase clarity code easier maintenance; changed output format somewhat. Added vignette ageprior, rewrote sections main vignette incorporate new functions Fortran part, re-implemented (candidate) (grand)parent-pairs filtered assigned","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-2-0-7","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"sequoia 2.0.7","text":"GenoConvert() skipped first individual reading .raw file. Circumvent bug earlier versions using option header=FALSE (header row removed …) ConfProb() expected input parameter nSim strictly integer, now relaxed value convertible whole number fixed ERROR! ***Invalid ParProb!*** triggered SNPs monomorphic fixed SEGFAULT triggered SNPs high missingness (>80%); possibly sibship size bounds fixed Error arguments imply differing number rows dummy parents 1 sex fixed various mostly minor bugs Fortran code fixed bugs regarding ‘link time optimisation’","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"minor-changes-2-0-7","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"sequoia 2.0.7","text":"LifeHistData may 2 additional columns, minimum maximum possible birth year second example pedigree (Ped_griffin) illustrate overlapping generations, used age vignette SummarySeq(): added pedigree summary table identical subset table returned R package pedantics’ pedStatSummary; package archived CRAN. Added option Panels plot () specific panel(s).","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-133","dir":"Changelog","previous_headings":"","what":"Sequoia 1.3.3","title":"Sequoia 1.3.3","text":"CRAN release: 2019-06-20","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-1-3-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Sequoia 1.3.3","text":"fixes bug caused R crash (Fortran array indexing --bounds)","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-131","dir":"Changelog","previous_headings":"","what":"Sequoia 1.3.1","title":"Sequoia 1.3.1","text":"CRAN release: 2019-06-14","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"new-features-1-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"Sequoia 1.3.1","text":"several functions become user-visible: CheckGeno(), MkGenoErrors(), GetMaybeRel(), GetRelCat() plotting functions added: PlotAgePrior() SummarySeq() function SimGeno() input parameters changed, old ones deprecated","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"minor-changes-1-3-1","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"Sequoia 1.3.1","text":"extended vignette function overview & FAQ numerous edits fortran source code better handle certain (rarer) types relatives","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"bug-fixes-1-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Sequoia 1.3.1","text":"various bug fixes fortran source code","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-111","dir":"Changelog","previous_headings":"","what":"sequoia 1.1.1","title":"sequoia 1.1.1","text":"CRAN release: 2018-08-13","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"major-changes-1-1-1","dir":"Changelog","previous_headings":"","what":"Major changes","title":"sequoia 1.1.1","text":"possibly.","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-100","dir":"Changelog","previous_headings":"","what":"sequoia 1.0.0","title":"sequoia 1.0.0","text":"CRAN release: 2018-03-29","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"sequoia 1.0.0","text":"added functions EstConf, SnpStats","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"major-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"sequoia 1.0.0","text":"considerable changes Fortran code","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-092","dir":"Changelog","previous_headings":"","what":"sequoia 0.9.2","title":"sequoia 0.9.2","text":"CRAN release: 2017-07-17","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"new-features-0-9-2","dir":"Changelog","previous_headings":"","what":"New features","title":"sequoia 0.9.2","text":"added functionality hermaphrodites (silico cloned male + female)","code":""},{"path":"https://jiscah.github.io/news/index.html","id":"sequoia-072","dir":"Changelog","previous_headings":"","what":"sequoia 0.7.2","title":"sequoia 0.7.2","text":"CRAN release: 2017-02-13 First version CRAN!","code":""}]
